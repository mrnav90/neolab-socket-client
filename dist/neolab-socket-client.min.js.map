{"version":3,"sources":["webpack:///neolab-socket-client.min.js","webpack:///webpack/bootstrap 3819740d35250a8bc260?6c06","webpack:///./src/index.js?9552","webpack:///./~/socketcluster-client/index.js?568c","webpack:///./~/socketcluster-client/lib/scsocket.js?3c51","webpack:///./~/buffer/index.js?1a55","webpack:///./~/base64-js/index.js?2add","webpack:///./~/ieee754/index.js?70fe","webpack:///./~/isarray/index.js?eabc","webpack:///./~/component-emitter/index.js?ea2f","webpack:///./~/sc-channel/index.js?69f2","webpack:///./~/socketcluster-client/lib/response.js?b602","webpack:///./~/sc-errors/index.js?205a","webpack:///./~/sc-errors/decycle.js?a5b8","webpack:///./~/socketcluster-client/lib/auth.js?9bed","webpack:///./~/sc-formatter/index.js?a52a","webpack:///./~/socketcluster-client/lib/sctransport.js?09ff","webpack:///./~/querystring/index.js?fce8","webpack:///./~/querystring/decode.js?c250","webpack:///./~/querystring/encode.js?e86b","webpack:///./~/socketcluster-client/lib/ws-browser.js?3739","webpack:///./~/linked-list/index.js?c0bd","webpack:///./~/linked-list/_source/linked-list.js?8ab7","webpack:///./~/base-64/base64.js?68a6","webpack:///(webpack)/buildin/module.js?c3c2","webpack:///./~/clone/clone.js?a97b","webpack:///./~/socketcluster-client/lib/scsocketcreator.js?2e61"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","SCSocket","SCSocketCreator","Emitter","connect","options","destroy","connections","version","global","Buffer","SCChannel","AuthEngine","Response","formatter","SCTransport","querystring","LinkedList","base64","clone","scErrors","InvalidArgumentsError","InvalidMessageError","SocketProtocolError","TimeoutError","BadConnectionError","isBrowser","window","opts","maxTimeout","verifyDuration","reconnectOptions","self","this","state","CLOSED","authState","UNAUTHENTICATED","signedAuthToken","authToken","pendingReconnect","pendingReconnectTimeout","preparingPendingSubscriptions","connectTimeout","ackTimeout","channelPrefix","disconnectOnUnload","authTokenName","pingTimeout","Math","pow","propertyName","_localEvents","connectAbort","disconnect","message","error","raw","fail","kickOut","subscribe","unsubscribe","subscribeStateChange","authStateChange","authenticate","deauthenticate","removeAuthToken","subscribeRequest","connectAttempts","_emitBuffer","channels","_cid","callIdGenerator","autoReconnect","autoReconnectOptions","initialDelay","randomness","multiplier","maxDelay","subscriptionRetryOptions","authEngine","auth","codecEngine","codec","path","replace","query","parse","autoConnect","_channelEmitter","addEventListener","_unloadHandler","prototype","Object","create","CONNECTING","OPEN","AUTHENTICATED","PENDING","ignoreStatuses","socketProtocolIgnoreStatuses","errorStatuses","socketProtocolErrorStatuses","_privateEventHandlerMap","#publish","data","undecoratedChannelName","_undecorateChannelName","channel","isSubscribed","emit","#kickOut","_triggerChannelUnsubscribe","#setAuthToken","response","triggerAuthenticate","err","_onSCError","_changeToAuthenticatedState","token","end","saveToken","#removeAuthToken","removeToken","oldToken","_changeToUnauthenticatedStateAndClearTokens","#disconnect","transport","close","code","getState","getBytesReceived","callback","open","clearTimeout","_reconnectTimeoutRef","off","on","status","_onSCOpen","_onSCClose","event","res","_onSCEvent","reconnect","removeEventListener","oldState","stateChangeData","newState","_extractAuthTokenData","processPendingSubscriptions","decodeBase64","encodedString","decodedString","buffer","atob","decode","toString","encodeBase64","btoa","encode","tokenData","tokenParts","split","encodedTokenData","JSON","e","getAuthToken","getSignedAuthToken","authStatus","isAuthenticated","authError","hydrateError","name","_tryReconnect","timeout","initialTimeout","exponent","round","random","setTimeout","autoSubscribeOnConnect","_flushEmitBuffer","listeners","length","_suspendSubscriptions","channelName","hasOwnProperty","SUBSCRIBED","UNSUBSCRIBED","_abortAllPendingEventsDueToBadConnection","failureType","nextNode","eventObject","errorMessage","currentNode","head","next","detach","openAbort","failureMessage","handler","apply","arguments","object","emitObject","_handleEventAckTimeout","eventNode","_emit","Item","cloneData","append","send","publish","pubData","_decorateChannelName","_triggerChannelSubscribe","subscriptionOptions","_triggerChannelSubscribeFail","meetsAuthRequirements","waitForAuth","_cancelPendingSubscribeCallback","_pendingSubscriptionCid","cancelPendingResponse","decoratedChannelName","indexOf","_trySubscribe","noTimeout","batch","setOptions","_tryUnsubscribe","currentChannel","destroyChannel","unwatch","subscriptions","includePending","includeChannel","subs","push","pendingChannels","i","sort","a","b","ap","priority","bp","forEach","watch","removeListener","removeAllListeners","watchers","typedArraySupport","arr","Uint8Array","__proto__","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","Error","allocUnsafe","from","value","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","undefined","checked","string","actual","isEncoding","write","slice","fromArrayLike","array","byteOffset","obj","isBuffer","len","copy","isnan","type","isArray","SlowBuffer","loweredCase","isView","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","bidirectionalIndexOf","val","dir","isNaN","arrayIndexOf","lastIndexOf","read","buf","indexSize","readUInt16BE","foundIndex","found","j","arrLength","valLength","String","hexWrite","offset","remaining","strLen","parsed","Number","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","fromByteArray","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","min","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","INVALID_BASE64_RE","trim","units","leadSurrogate","Infinity","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","poolSize","_augment","Symbol","species","defineProperty","configurable","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","pos","swap16","swap32","swap64","equals","inspect","match","join","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","placeHoldersCount","b64","tmp","placeHolders","Arr","l","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","len2","extraBytes","parts","maxChunkLength","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","rt","abs","log","LN2","mixin","key","fn","_callbacks","once","callbacks","cb","splice","args","hasListeners","client","InvalidActionError","socket","sent","_respond","responseData","rid","dehydrateError","AuthTokenExpiredError","expiry","captureStackTrace","isStrict","callee","stack","AuthTokenInvalidError","AuthTokenNotBeforeError","date","AuthTokenError","SilentMiddlewareBlockedError","InvalidOptionsError","ServerProtocolError","HTTPServerError","ResourceLimitError","BrokerError","ProcessExitError","UnknownError","unserializableErrorProperties","decycle","1001","1002","1003","1005","1006","1007","1008","1009","1010","1011","4000","4001","4002","4003","4004","4005","4006","4007","1000","domain","domainEmitter","domainThrown","includeStackTrace","dehydratedError","hydratedError","objects","paths","derez","nu","Boolean","Date","RegExp","$ref","stringify","_internalStorage","isLocalStorageEnabled","_checkLocalStorageEnabled","localStorage","setItem","removeItem","loadToken","getItem","base64Chars","arrayBufferToBase64","arraybuffer","substring","binaryToBase64Replacer","rehydratedBuffer","input","WebSocket","createWebSocket","uri","_pingTimeoutTicker","_callbackMap","_batchSendList","host","port","schema","secure","timestampRequests","timestampParam","getTime","hostname","wsSocket","binaryType","onopen","_onOpen","onclose","_onClose","reason","onmessage","flags","_onMessage","onerror","_connectTimeoutRef","_resetPingTimeout","_handshake","_onError","force","badConnectionError","_handleEventObject","rehydratedError","cid","readyState","sendObject","bytesReceived","packet","simpleEventObject","Function","serializeObject","formatError","sendObjectBatch","_batchTimeout","pubSubBatchDuration","sendObjectSingle","prop","qs","sep","eq","regexp","maxKeys","idx","kstr","vstr","k","v","decodeURIComponent","stringifyPrimitive","keys","map","ks","encodeURIComponent","ws","protocols","instance","WorkerGlobalScope","MozWebSocket","List","ListItem","ListItemPrototype","ListPrototype","of","items","iterator","item","tail","toArray","result","prepend","prev","__WEBPACK_AMD_DEFINE_RESULT__","root","InvalidCharacterError","TABLE","REGEX_SPACE_CHARACTERS","freeExports","freeGlobal","bitCounter","bitStorage","position","test","charAt","padding","webpackPolyfill","deprecate","children","_instanceof","parent","circular","depth","includeNonEnumerable","_clone","child","proto","index","attrs","symbols","symbol","descriptor","allPropertyNames","nativeMap","nativeSet","nativePromise","resolve","reject","then","__isArray","__isRegExp","source","__getRegExpFlags","lastIndex","__isDate","useBuffer","getPrototypeOf","allParents","allChildren","keyChild","valueChild","entryChild","add","getOwnPropertyDescriptor","getOwnPropertySymbols","enumerable","getOwnPropertyNames","__objToStr","o","re","ignoreCase","multiline","Map","_","Set","Promise","clonePrototype","getMultiplexId","queryArray","queryMap","protocolPrefix","queryString","isUrlSecure","location","protocol","getPort","isSecureDefault","isSecure","multiplexId","multiplex","_connections"],"mappings":"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","file":"neolab-socket-client.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SCSocket = __webpack_require__(2);\n\tvar SCSocketCreator = __webpack_require__(24);\n\t\n\tmodule.exports.SCSocketCreator = SCSocketCreator;\n\tmodule.exports.SCSocket = SCSocket;\n\t\n\tmodule.exports.Emitter = __webpack_require__(7);\n\t\n\tmodule.exports.connect = function (options) {\n\t  return SCSocketCreator.connect(options);\n\t};\n\t\n\tmodule.exports.destroy = function (options) {\n\t  return SCSocketCreator.destroy(options);\n\t};\n\t\n\tmodule.exports.connections = SCSocketCreator.connections;\n\t\n\tmodule.exports.version = '8.0.1';\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, Buffer) {var Emitter = __webpack_require__(7);\n\tvar SCChannel = __webpack_require__(8).SCChannel;\n\tvar Response = __webpack_require__(9).Response;\n\tvar AuthEngine = __webpack_require__(12).AuthEngine;\n\tvar formatter = __webpack_require__(13);\n\tvar SCTransport = __webpack_require__(14).SCTransport;\n\tvar querystring = __webpack_require__(15);\n\tvar LinkedList = __webpack_require__(19);\n\tvar base64 = __webpack_require__(21);\n\tvar clone = __webpack_require__(23);\n\t\n\tvar scErrors = __webpack_require__(10);\n\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\tvar InvalidMessageError = scErrors.InvalidMessageError;\n\tvar SocketProtocolError = scErrors.SocketProtocolError;\n\tvar TimeoutError = scErrors.TimeoutError;\n\tvar BadConnectionError = scErrors.BadConnectionError;\n\t\n\tvar isBrowser = typeof window != 'undefined';\n\t\n\t\n\tvar SCSocket = function (opts) {\n\t  var self = this;\n\t\n\t  Emitter.call(this);\n\t\n\t  this.id = null;\n\t  this.state = this.CLOSED;\n\t  this.authState = this.UNAUTHENTICATED;\n\t  this.signedAuthToken = null;\n\t  this.authToken = null;\n\t  this.pendingReconnect = false;\n\t  this.pendingReconnectTimeout = null;\n\t  this.preparingPendingSubscriptions = false;\n\t\n\t  this.connectTimeout = opts.connectTimeout;\n\t  this.ackTimeout = opts.ackTimeout;\n\t  this.channelPrefix = opts.channelPrefix || null;\n\t  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\n\t  this.authTokenName = opts.authTokenName;\n\t\n\t  // pingTimeout will be ackTimeout at the start, but it will\n\t  // be updated with values provided by the 'connect' event\n\t  this.pingTimeout = this.ackTimeout;\n\t\n\t  var maxTimeout = Math.pow(2, 31) - 1;\n\t\n\t  var verifyDuration = function (propertyName) {\n\t    if (self[propertyName] > maxTimeout) {\n\t      throw new InvalidArgumentsError('The ' + propertyName +\n\t        ' value provided exceeded the maximum amount allowed');\n\t    }\n\t  };\n\t\n\t  verifyDuration('connectTimeout');\n\t  verifyDuration('ackTimeout');\n\t  verifyDuration('pingTimeout');\n\t\n\t  this._localEvents = {\n\t    'connect': 1,\n\t    'connectAbort': 1,\n\t    'disconnect': 1,\n\t    'message': 1,\n\t    'error': 1,\n\t    'raw': 1,\n\t    'fail': 1,\n\t    'kickOut': 1,\n\t    'subscribe': 1,\n\t    'unsubscribe': 1,\n\t    'subscribeStateChange': 1,\n\t    'authStateChange': 1,\n\t    'authenticate': 1,\n\t    'deauthenticate': 1,\n\t    'removeAuthToken': 1,\n\t    'subscribeRequest': 1\n\t  };\n\t\n\t  this.connectAttempts = 0;\n\t\n\t  this._emitBuffer = new LinkedList();\n\t  this.channels = {};\n\t\n\t  this.options = opts;\n\t\n\t  this._cid = 1;\n\t\n\t  this.options.callIdGenerator = function () {\n\t    return self._cid++;\n\t  };\n\t\n\t  if (this.options.autoReconnect) {\n\t    if (this.options.autoReconnectOptions == null) {\n\t      this.options.autoReconnectOptions = {};\n\t    }\n\t\n\t    // Add properties to the this.options.autoReconnectOptions object.\n\t    // We assign the reference to a reconnectOptions variable to avoid repetition.\n\t    var reconnectOptions = this.options.autoReconnectOptions;\n\t    if (reconnectOptions.initialDelay == null) {\n\t      reconnectOptions.initialDelay = 10000;\n\t    }\n\t    if (reconnectOptions.randomness == null) {\n\t      reconnectOptions.randomness = 10000;\n\t    }\n\t    if (reconnectOptions.multiplier == null) {\n\t      reconnectOptions.multiplier = 1.5;\n\t    }\n\t    if (reconnectOptions.maxDelay == null) {\n\t      reconnectOptions.maxDelay = 60000;\n\t    }\n\t  }\n\t\n\t  if (this.options.subscriptionRetryOptions == null) {\n\t    this.options.subscriptionRetryOptions = {};\n\t  }\n\t\n\t  if (this.options.authEngine) {\n\t    this.auth = this.options.authEngine;\n\t  } else {\n\t    this.auth = new AuthEngine();\n\t  }\n\t\n\t  if (this.options.codecEngine) {\n\t    this.codec = this.options.codecEngine;\n\t  } else {\n\t    // Default codec engine\n\t    this.codec = formatter;\n\t  }\n\t\n\t  this.options.path = this.options.path.replace(/\\/$/, '') + '/';\n\t\n\t  this.options.query = opts.query || {};\n\t  if (typeof this.options.query == 'string') {\n\t    this.options.query = querystring.parse(this.options.query);\n\t  }\n\t\n\t  if (this.options.autoConnect) {\n\t    this.connect();\n\t  }\n\t\n\t  this._channelEmitter = new Emitter();\n\t\n\t  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\n\t    this._unloadHandler = function () {\n\t      self.disconnect();\n\t    };\n\t\n\t    global.addEventListener('beforeunload', this._unloadHandler, false);\n\t  }\n\t};\n\t\n\tSCSocket.prototype = Object.create(Emitter.prototype);\n\t\n\tSCSocket.CONNECTING = SCSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\n\tSCSocket.OPEN = SCSocket.prototype.OPEN = SCTransport.prototype.OPEN;\n\tSCSocket.CLOSED = SCSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\n\t\n\tSCSocket.AUTHENTICATED = SCSocket.prototype.AUTHENTICATED = 'authenticated';\n\tSCSocket.UNAUTHENTICATED = SCSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\n\t\n\tSCSocket.PENDING = SCSocket.prototype.PENDING = 'pending';\n\t\n\tSCSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\n\tSCSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\n\t\n\tSCSocket.prototype._privateEventHandlerMap = {\n\t  '#publish': function (data) {\n\t    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n\t    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n\t\n\t    if (isSubscribed) {\n\t      this._channelEmitter.emit(undecoratedChannelName, data.data);\n\t    }\n\t  },\n\t  '#kickOut': function (data) {\n\t    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n\t    var channel = this.channels[undecoratedChannelName];\n\t    if (channel) {\n\t      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\n\t      channel.emit('kickOut', data.message, undecoratedChannelName);\n\t      this._triggerChannelUnsubscribe(channel);\n\t    }\n\t  },\n\t  '#setAuthToken': function (data, response) {\n\t    var self = this;\n\t\n\t    if (data) {\n\t      var triggerAuthenticate = function (err) {\n\t        if (err) {\n\t          // This is a non-fatal error, we don't want to close the connection\n\t          // because of this but we do want to notify the server and throw an error\n\t          // on the client.\n\t          response.error(err);\n\t          self._onSCError(err);\n\t        } else {\n\t          self._changeToAuthenticatedState(data.token);\n\t          response.end();\n\t        }\n\t      };\n\t\n\t      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\n\t    } else {\n\t      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\n\t    }\n\t  },\n\t  '#removeAuthToken': function (data, response) {\n\t    var self = this;\n\t\n\t    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n\t      if (err) {\n\t        // Non-fatal error - Do not close the connection\n\t        response.error(err);\n\t        self._onSCError(err);\n\t      } else {\n\t        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n\t        self._changeToUnauthenticatedStateAndClearTokens();\n\t        response.end();\n\t      }\n\t    });\n\t  },\n\t  '#disconnect': function (data) {\n\t    this.transport.close(data.code, data.data);\n\t  }\n\t};\n\t\n\tSCSocket.prototype.getState = function () {\n\t  return this.state;\n\t};\n\t\n\tSCSocket.prototype.getBytesReceived = function () {\n\t  return this.transport.getBytesReceived();\n\t};\n\t\n\tSCSocket.prototype.deauthenticate = function (callback) {\n\t  var self = this;\n\t\n\t  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n\t    if (err) {\n\t      // Non-fatal error - Do not close the connection\n\t      self._onSCError(err);\n\t    } else {\n\t      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n\t      if (self.state != self.CLOSED) {\n\t        self.emit('#removeAuthToken');\n\t      }\n\t      self._changeToUnauthenticatedStateAndClearTokens();\n\t    }\n\t    callback && callback(err);\n\t  });\n\t};\n\t\n\tSCSocket.prototype.connect = SCSocket.prototype.open = function () {\n\t  var self = this;\n\t\n\t  if (this.state == this.CLOSED) {\n\t    this.pendingReconnect = false;\n\t    this.pendingReconnectTimeout = null;\n\t    clearTimeout(this._reconnectTimeoutRef);\n\t\n\t    this.state = this.CONNECTING;\n\t    Emitter.prototype.emit.call(this, 'connecting');\n\t\n\t    if (this.transport) {\n\t      this.transport.off();\n\t    }\n\t\n\t    this.transport = new SCTransport(this.auth, this.codec, this.options);\n\t\n\t    this.transport.on('open', function (status) {\n\t      self.state = self.OPEN;\n\t      self._onSCOpen(status);\n\t    });\n\t\n\t    this.transport.on('error', function (err) {\n\t      self._onSCError(err);\n\t    });\n\t\n\t    this.transport.on('close', function (code, data) {\n\t      self.state = self.CLOSED;\n\t      self._onSCClose(code, data);\n\t    });\n\t\n\t    this.transport.on('openAbort', function (code, data) {\n\t      self.state = self.CLOSED;\n\t      self._onSCClose(code, data, true);\n\t    });\n\t\n\t    this.transport.on('event', function (event, data, res) {\n\t      self._onSCEvent(event, data, res);\n\t    });\n\t  }\n\t};\n\t\n\tSCSocket.prototype.reconnect = function () {\n\t  this.disconnect();\n\t  this.connect();\n\t};\n\t\n\tSCSocket.prototype.disconnect = function (code, data) {\n\t  code = code || 1000;\n\t\n\t  if (typeof code != 'number') {\n\t    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n\t  }\n\t\n\t  if (this.state == this.OPEN || this.state == this.CONNECTING) {\n\t    this.transport.close(code, data);\n\t  } else {\n\t    this.pendingReconnect = false;\n\t    this.pendingReconnectTimeout = null;\n\t    clearTimeout(this._reconnectTimeoutRef);\n\t  }\n\t};\n\t\n\tSCSocket.prototype.destroy = function () {\n\t  if (this._unloadHandler) {\n\t    global.removeEventListener('beforeunload', this._unloadHandler, false);\n\t  }\n\t  this.disconnect();\n\t};\n\t\n\tSCSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n\t  if (this.authState != this.UNAUTHENTICATED) {\n\t    var oldState = this.authState;\n\t    this.authState = this.UNAUTHENTICATED;\n\t    this.signedAuthToken = null;\n\t    this.authToken = null;\n\t\n\t    var stateChangeData = {\n\t      oldState: oldState,\n\t      newState: this.authState\n\t    };\n\t    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n\t    if (oldState == this.AUTHENTICATED) {\n\t      Emitter.prototype.emit.call(this, 'deauthenticate');\n\t    }\n\t    Emitter.prototype.emit.call(this, 'authTokenChange', this.signedAuthToken);\n\t  }\n\t};\n\t\n\tSCSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n\t  this.signedAuthToken = signedAuthToken;\n\t  this.authToken = this._extractAuthTokenData(signedAuthToken);\n\t\n\t  if (this.authState != this.AUTHENTICATED) {\n\t    var oldState = this.authState;\n\t    this.authState = this.AUTHENTICATED;\n\t    var stateChangeData = {\n\t      oldState: oldState,\n\t      newState: this.authState,\n\t      signedAuthToken: signedAuthToken,\n\t      authToken: this.authToken\n\t    };\n\t    if (!this.preparingPendingSubscriptions) {\n\t      this.processPendingSubscriptions();\n\t    }\n\t\n\t    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n\t    Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\n\t  }\n\t  Emitter.prototype.emit.call(this, 'authTokenChange', signedAuthToken);\n\t};\n\t\n\tSCSocket.prototype.decodeBase64 = function (encodedString) {\n\t  var decodedString;\n\t  if (typeof Buffer == 'undefined') {\n\t    if (global.atob) {\n\t      decodedString = global.atob(encodedString);\n\t    } else {\n\t      decodedString = base64.decode(encodedString);\n\t    }\n\t  } else {\n\t    var buffer = new Buffer(encodedString, 'base64');\n\t    decodedString = buffer.toString('utf8');\n\t  }\n\t  return decodedString;\n\t};\n\t\n\tSCSocket.prototype.encodeBase64 = function (decodedString) {\n\t  var encodedString;\n\t  if (typeof Buffer == 'undefined') {\n\t    if (global.btoa) {\n\t      encodedString = global.btoa(decodedString);\n\t    } else {\n\t      encodedString = base64.encode(decodedString);\n\t    }\n\t  } else {\n\t    var buffer = new Buffer(decodedString, 'utf8');\n\t    encodedString = buffer.toString('base64');\n\t  }\n\t  return encodedString;\n\t};\n\t\n\tSCSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n\t  var tokenParts = (signedAuthToken || '').split('.');\n\t  var encodedTokenData = tokenParts[1];\n\t  if (encodedTokenData != null) {\n\t    var tokenData = encodedTokenData;\n\t    try {\n\t      tokenData = this.decodeBase64(tokenData);\n\t      return JSON.parse(tokenData);\n\t    } catch (e) {\n\t      return tokenData;\n\t    }\n\t  }\n\t  return null;\n\t};\n\t\n\tSCSocket.prototype.getAuthToken = function () {\n\t  return this.authToken;\n\t};\n\t\n\tSCSocket.prototype.getSignedAuthToken = function () {\n\t  return this.signedAuthToken;\n\t};\n\t\n\t// Perform client-initiated authentication by providing an encrypted token string.\n\tSCSocket.prototype.authenticate = function (signedAuthToken, callback) {\n\t  var self = this;\n\t\n\t  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\n\t\n\t    if (authStatus && authStatus.isAuthenticated != null) {\n\t      // If authStatus is correctly formatted (has an isAuthenticated property),\n\t      // then we will rehydrate the authError.\n\t      if (authStatus.authError) {\n\t        authStatus.authError = scErrors.hydrateError(authStatus.authError);\n\t      }\n\t    } else {\n\t      // Some errors like BadConnectionError and TimeoutError will not pass a valid\n\t      // authStatus object to the current function, so we need to create it ourselves.\n\t      authStatus = {\n\t        isAuthenticated: self.authState,\n\t        authError: null\n\t      };\n\t    }\n\t    if (err) {\n\t      if (err.name != 'BadConnectionError' && err.name != 'TimeoutError') {\n\t        // In case of a bad/closed connection or a timeout, we maintain the last\n\t        // known auth state since those errors don't mean that the token is invalid.\n\t\n\t        self._changeToUnauthenticatedStateAndClearTokens();\n\t      }\n\t      callback && callback(err, authStatus);\n\t    } else {\n\t      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\n\t        if (err) {\n\t          self._onSCError(err);\n\t        }\n\t        if (authStatus.isAuthenticated) {\n\t          self._changeToAuthenticatedState(signedAuthToken);\n\t        } else {\n\t          self._changeToUnauthenticatedStateAndClearTokens();\n\t        }\n\t        callback && callback(err, authStatus);\n\t      });\n\t    }\n\t  });\n\t};\n\t\n\tSCSocket.prototype._tryReconnect = function (initialDelay) {\n\t  var self = this;\n\t\n\t  var exponent = this.connectAttempts++;\n\t  var reconnectOptions = this.options.autoReconnectOptions;\n\t  var timeout;\n\t\n\t  if (initialDelay == null || exponent > 0) {\n\t    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n\t\n\t    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n\t  } else {\n\t    timeout = initialDelay;\n\t  }\n\t\n\t  if (timeout > reconnectOptions.maxDelay) {\n\t    timeout = reconnectOptions.maxDelay;\n\t  }\n\t\n\t  clearTimeout(this._reconnectTimeoutRef);\n\t\n\t  this.pendingReconnect = true;\n\t  this.pendingReconnectTimeout = timeout;\n\t  this._reconnectTimeoutRef = setTimeout(function () {\n\t    self.connect();\n\t  }, timeout);\n\t};\n\t\n\tSCSocket.prototype._onSCOpen = function (status) {\n\t  var self = this;\n\t\n\t  this.preparingPendingSubscriptions = true;\n\t\n\t  if (status) {\n\t    this.id = status.id;\n\t    this.pingTimeout = status.pingTimeout;\n\t    this.transport.pingTimeout = this.pingTimeout;\n\t    if (status.isAuthenticated) {\n\t      this._changeToAuthenticatedState(status.authToken);\n\t    } else {\n\t      this._changeToUnauthenticatedStateAndClearTokens();\n\t    }\n\t  } else {\n\t    // This can happen if auth.loadToken (in sctransport.js) fails with\n\t    // an error - This means that the signedAuthToken cannot be loaded by\n\t    // the auth engine and therefore, we need to unauthenticate the socket.\n\t    this._changeToUnauthenticatedStateAndClearTokens();\n\t  }\n\t\n\t  this.connectAttempts = 0;\n\t\n\t  if (this.options.autoSubscribeOnConnect) {\n\t    this.processPendingSubscriptions();\n\t  }\n\t\n\t  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n\t  // won't break anything.\n\t  Emitter.prototype.emit.call(this, 'connect', status, function () {\n\t    self.processPendingSubscriptions();\n\t  });\n\t\n\t  this._flushEmitBuffer();\n\t};\n\t\n\tSCSocket.prototype._onSCError = function (err) {\n\t  var self = this;\n\t\n\t  // Throw error in different stack frame so that error handling\n\t  // cannot interfere with a reconnect action.\n\t  setTimeout(function () {\n\t    if (self.listeners('error').length < 1) {\n\t      throw err;\n\t    } else {\n\t      Emitter.prototype.emit.call(self, 'error', err);\n\t    }\n\t  }, 0);\n\t};\n\t\n\tSCSocket.prototype._suspendSubscriptions = function () {\n\t  var channel, newState;\n\t  for (var channelName in this.channels) {\n\t    if (this.channels.hasOwnProperty(channelName)) {\n\t      channel = this.channels[channelName];\n\t      if (channel.state == channel.SUBSCRIBED ||\n\t        channel.state == channel.PENDING) {\n\t\n\t        newState = channel.PENDING;\n\t      } else {\n\t        newState = channel.UNSUBSCRIBED;\n\t      }\n\t\n\t      this._triggerChannelUnsubscribe(channel, newState);\n\t    }\n\t  }\n\t};\n\t\n\tSCSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n\t  var currentNode = this._emitBuffer.head;\n\t  var nextNode;\n\t\n\t  while (currentNode) {\n\t    nextNode = currentNode.next;\n\t    var eventObject = currentNode.data;\n\t    clearTimeout(eventObject.timeout);\n\t    delete eventObject.timeout;\n\t    currentNode.detach();\n\t    currentNode = nextNode;\n\t\n\t    var callback = eventObject.callback;\n\t    if (callback) {\n\t      delete eventObject.callback;\n\t      var errorMessage = \"Event '\" + eventObject.event +\n\t        \"' was aborted due to a bad connection\";\n\t      var error = new BadConnectionError(errorMessage, failureType);\n\t      callback.call(eventObject, error, eventObject);\n\t    }\n\t  }\n\t};\n\t\n\tSCSocket.prototype._onSCClose = function (code, data, openAbort) {\n\t  var self = this;\n\t\n\t  this.id = null;\n\t\n\t  if (this.transport) {\n\t    this.transport.off();\n\t  }\n\t  this.pendingReconnect = false;\n\t  this.pendingReconnectTimeout = null;\n\t  clearTimeout(this._reconnectTimeoutRef);\n\t\n\t  this._suspendSubscriptions();\n\t  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\t\n\t  // Try to reconnect\n\t  // on server ping timeout (4000)\n\t  // or on client pong timeout (4001)\n\t  // or on close without status (1005)\n\t  // or on handshake failure (4003)\n\t  // or on socket hung up (1006)\n\t  if (this.options.autoReconnect) {\n\t    if (code == 4000 || code == 4001 || code == 1005) {\n\t      // If there is a ping or pong timeout or socket closes without\n\t      // status, don't wait before trying to reconnect - These could happen\n\t      // if the client wakes up after a period of inactivity and in this case we\n\t      // want to re-establish the connection as soon as possible.\n\t      this._tryReconnect(0);\n\t\n\t      // Codes 4500 and above will be treated as permanent disconnects.\n\t      // Socket will not try to auto-reconnect.\n\t    } else if (code != 1000 && code < 4500) {\n\t      this._tryReconnect();\n\t    }\n\t  }\n\t\n\t  if (openAbort) {\n\t    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\n\t  } else {\n\t    Emitter.prototype.emit.call(self, 'disconnect', code, data);\n\t  }\n\t\n\t  if (!SCSocket.ignoreStatuses[code]) {\n\t    var failureMessage;\n\t    if (data) {\n\t      failureMessage = 'Socket connection failed: ' + data;\n\t    } else {\n\t      failureMessage = 'Socket connection failed for unknown reasons';\n\t    }\n\t    var err = new SocketProtocolError(SCSocket.errorStatuses[code] || failureMessage, code);\n\t    this._onSCError(err);\n\t  }\n\t};\n\t\n\tSCSocket.prototype._onSCEvent = function (event, data, res) {\n\t  var handler = this._privateEventHandlerMap[event];\n\t  if (handler) {\n\t    handler.call(this, data, res);\n\t  } else {\n\t    Emitter.prototype.emit.call(this, event, data, function () {\n\t      res && res.callback.apply(res, arguments);\n\t    });\n\t  }\n\t};\n\t\n\tSCSocket.prototype.decode = function (message) {\n\t  return this.transport.decode(message);\n\t};\n\t\n\tSCSocket.prototype.encode = function (object) {\n\t  return this.transport.encode(object);\n\t};\n\t\n\tSCSocket.prototype._flushEmitBuffer = function () {\n\t  var currentNode = this._emitBuffer.head;\n\t  var nextNode;\n\t\n\t  while (currentNode) {\n\t    nextNode = currentNode.next;\n\t    var eventObject = currentNode.data;\n\t    currentNode.detach();\n\t    this.transport.emitObject(eventObject);\n\t    currentNode = nextNode;\n\t  }\n\t};\n\t\n\tSCSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n\t  if (eventNode) {\n\t    eventNode.detach();\n\t  }\n\t  delete eventObject.timeout;\n\t\n\t  var callback = eventObject.callback;\n\t  if (callback) {\n\t    delete eventObject.callback;\n\t    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n\t    callback.call(eventObject, error, eventObject);\n\t  }\n\t};\n\t\n\tSCSocket.prototype._emit = function (event, data, callback) {\n\t  var self = this;\n\t\n\t  if (this.state == this.CLOSED) {\n\t    this.connect();\n\t  }\n\t  var eventObject = {\n\t    event: event,\n\t    callback: callback\n\t  };\n\t\n\t  var eventNode = new LinkedList.Item();\n\t\n\t  if (this.options.cloneData) {\n\t    eventObject.data = clone(data);\n\t  } else {\n\t    eventObject.data = data;\n\t  }\n\t  eventNode.data = eventObject;\n\t\n\t  eventObject.timeout = setTimeout(function () {\n\t    self._handleEventAckTimeout(eventObject, eventNode);\n\t  }, this.ackTimeout);\n\t\n\t  this._emitBuffer.append(eventNode);\n\t\n\t  if (this.state == this.OPEN) {\n\t    this._flushEmitBuffer();\n\t  }\n\t};\n\t\n\tSCSocket.prototype.send = function (data) {\n\t  this.transport.send(data);\n\t};\n\t\n\tSCSocket.prototype.emit = function (event, data, callback) {\n\t  if (this._localEvents[event] == null) {\n\t    this._emit(event, data, callback);\n\t  } else {\n\t    Emitter.prototype.emit.call(this, event, data);\n\t  }\n\t};\n\t\n\tSCSocket.prototype.publish = function (channelName, data, callback) {\n\t  var pubData = {\n\t    channel: this._decorateChannelName(channelName),\n\t    data: data\n\t  };\n\t  this.emit('#publish', pubData, callback);\n\t};\n\t\n\tSCSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n\t  var channelName = channel.name;\n\t\n\t  if (channel.state != channel.SUBSCRIBED) {\n\t    var oldState = channel.state;\n\t    channel.state = channel.SUBSCRIBED;\n\t\n\t    var stateChangeData = {\n\t      channel: channelName,\n\t      oldState: oldState,\n\t      newState: channel.state,\n\t      subscriptionOptions: subscriptionOptions\n\t    };\n\t    channel.emit('subscribeStateChange', stateChangeData);\n\t    channel.emit('subscribe', channelName, subscriptionOptions);\n\t    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n\t    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\n\t  }\n\t};\n\t\n\tSCSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n\t  var channelName = channel.name;\n\t  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\t\n\t  if (channel.state != channel.UNSUBSCRIBED && meetsAuthRequirements) {\n\t    channel.state = channel.UNSUBSCRIBED;\n\t\n\t    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\n\t    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\n\t  }\n\t};\n\t\n\t// Cancel any pending subscribe callback\n\tSCSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n\t  if (channel._pendingSubscriptionCid != null) {\n\t    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n\t    delete channel._pendingSubscriptionCid;\n\t  }\n\t};\n\t\n\tSCSocket.prototype._decorateChannelName = function (channelName) {\n\t  if (this.channelPrefix) {\n\t    channelName = this.channelPrefix + channelName;\n\t  }\n\t  return channelName;\n\t};\n\t\n\tSCSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n\t  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) == 0) {\n\t    return decoratedChannelName.replace(this.channelPrefix, '');\n\t  }\n\t  return decoratedChannelName;\n\t};\n\t\n\tSCSocket.prototype._trySubscribe = function (channel) {\n\t  var self = this;\n\t\n\t  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\t\n\t  // We can only ever have one pending subscribe action at any given time on a channel\n\t  if (this.state == this.OPEN && !this.preparingPendingSubscriptions &&\n\t    channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n\t\n\t    var options = {\n\t      noTimeout: true\n\t    };\n\t\n\t    var subscriptionOptions = {\n\t      channel: this._decorateChannelName(channel.name)\n\t    };\n\t    if (channel.waitForAuth) {\n\t      options.waitForAuth = true;\n\t      subscriptionOptions.waitForAuth = options.waitForAuth;\n\t    }\n\t    if (channel.data) {\n\t      subscriptionOptions.data = channel.data;\n\t    }\n\t    if (channel.batch) {\n\t      options.batch = true;\n\t      subscriptionOptions.batch = true;\n\t    }\n\t\n\t    channel._pendingSubscriptionCid = this.transport.emit(\n\t      '#subscribe', subscriptionOptions, options,\n\t      function (err) {\n\t        delete channel._pendingSubscriptionCid;\n\t        if (err) {\n\t          self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n\t        } else {\n\t          self._triggerChannelSubscribe(channel, subscriptionOptions);\n\t        }\n\t      }\n\t    );\n\t    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\n\t  }\n\t};\n\t\n\tSCSocket.prototype.subscribe = function (channelName, options) {\n\t  var channel = this.channels[channelName];\n\t\n\t  if (!channel) {\n\t    channel = new SCChannel(channelName, this, options);\n\t    this.channels[channelName] = channel;\n\t  } else if (options) {\n\t    channel.setOptions(options);\n\t  }\n\t\n\t  if (channel.state == channel.UNSUBSCRIBED) {\n\t    channel.state = channel.PENDING;\n\t    this._trySubscribe(channel);\n\t  }\n\t\n\t  return channel;\n\t};\n\t\n\tSCSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\n\t  var channelName = channel.name;\n\t  var oldState = channel.state;\n\t\n\t  if (newState) {\n\t    channel.state = newState;\n\t  } else {\n\t    channel.state = channel.UNSUBSCRIBED;\n\t  }\n\t  this._cancelPendingSubscribeCallback(channel);\n\t\n\t  if (oldState == channel.SUBSCRIBED) {\n\t    var stateChangeData = {\n\t      channel: channelName,\n\t      oldState: oldState,\n\t      newState: channel.state\n\t    };\n\t    channel.emit('subscribeStateChange', stateChangeData);\n\t    channel.emit('unsubscribe', channelName);\n\t    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n\t    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\n\t  }\n\t};\n\t\n\tSCSocket.prototype._tryUnsubscribe = function (channel) {\n\t  var self = this;\n\t\n\t  if (this.state == this.OPEN) {\n\t    var options = {\n\t      noTimeout: true\n\t    };\n\t    if (channel.batch) {\n\t      options.batch = true;\n\t    }\n\t    // If there is a pending subscribe action, cancel the callback\n\t    this._cancelPendingSubscribeCallback(channel);\n\t\n\t    // This operation cannot fail because the TCP protocol guarantees delivery\n\t    // so long as the connection remains open. If the connection closes,\n\t    // the server will automatically unsubscribe the socket and thus complete\n\t    // the operation on the server side.\n\t    var decoratedChannelName = this._decorateChannelName(channel.name);\n\t    this.transport.emit('#unsubscribe', decoratedChannelName, options);\n\t  }\n\t};\n\t\n\tSCSocket.prototype.unsubscribe = function (channelName) {\n\t\n\t  var channel = this.channels[channelName];\n\t\n\t  if (channel) {\n\t    if (channel.state != channel.UNSUBSCRIBED) {\n\t\n\t      this._triggerChannelUnsubscribe(channel);\n\t      this._tryUnsubscribe(channel);\n\t    }\n\t  }\n\t};\n\t\n\tSCSocket.prototype.channel = function (channelName, options) {\n\t  var currentChannel = this.channels[channelName];\n\t\n\t  if (!currentChannel) {\n\t    currentChannel = new SCChannel(channelName, this, options);\n\t    this.channels[channelName] = currentChannel;\n\t  }\n\t  return currentChannel;\n\t};\n\t\n\tSCSocket.prototype.destroyChannel = function (channelName) {\n\t  var channel = this.channels[channelName];\n\t  channel.unwatch();\n\t  channel.unsubscribe();\n\t  delete this.channels[channelName];\n\t};\n\t\n\tSCSocket.prototype.subscriptions = function (includePending) {\n\t  var subs = [];\n\t  var channel, includeChannel;\n\t  for (var channelName in this.channels) {\n\t    if (this.channels.hasOwnProperty(channelName)) {\n\t      channel = this.channels[channelName];\n\t\n\t      if (includePending) {\n\t        includeChannel = channel && (channel.state == channel.SUBSCRIBED ||\n\t          channel.state == channel.PENDING);\n\t      } else {\n\t        includeChannel = channel && channel.state == channel.SUBSCRIBED;\n\t      }\n\t\n\t      if (includeChannel) {\n\t        subs.push(channelName);\n\t      }\n\t    }\n\t  }\n\t  return subs;\n\t};\n\t\n\tSCSocket.prototype.isSubscribed = function (channelName, includePending) {\n\t  var channel = this.channels[channelName];\n\t  if (includePending) {\n\t    return !!channel && (channel.state == channel.SUBSCRIBED ||\n\t      channel.state == channel.PENDING);\n\t  }\n\t  return !!channel && channel.state == channel.SUBSCRIBED;\n\t};\n\t\n\tSCSocket.prototype.processPendingSubscriptions = function () {\n\t  var self = this;\n\t\n\t  this.preparingPendingSubscriptions = false;\n\t\n\t  var pendingChannels = [];\n\t\n\t  for (var i in this.channels) {\n\t    if (this.channels.hasOwnProperty(i)) {\n\t      var channel = this.channels[i];\n\t      if (channel.state == channel.PENDING) {\n\t        pendingChannels.push(channel);\n\t      }\n\t    }\n\t  }\n\t\n\t  pendingChannels.sort(function (a, b) {\n\t    var ap = a.priority || 0;\n\t    var bp = b.priority || 0;\n\t    if (ap > bp) {\n\t      return -1;\n\t    }\n\t    if (ap < bp) {\n\t      return 1;\n\t    }\n\t    return 0;\n\t  });\n\t\n\t  pendingChannels.forEach(function (channel) {\n\t    self._trySubscribe(channel);\n\t  });\n\t};\n\t\n\tSCSocket.prototype.watch = function (channelName, handler) {\n\t  if (typeof handler != 'function') {\n\t    throw new InvalidArgumentsError('No handler function was provided');\n\t  }\n\t  this._channelEmitter.on(channelName, handler);\n\t};\n\t\n\tSCSocket.prototype.unwatch = function (channelName, handler) {\n\t  if (handler) {\n\t    this._channelEmitter.removeListener(channelName, handler);\n\t  } else {\n\t    this._channelEmitter.removeAllListeners(channelName);\n\t  }\n\t};\n\t\n\tSCSocket.prototype.watchers = function (channelName) {\n\t  return this._channelEmitter.listeners(channelName);\n\t};\n\t\n\tmodule.exports = SCSocket;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(4)\n\tvar ieee754 = __webpack_require__(5)\n\tvar isArray = __webpack_require__(6)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t/**\r\n\t * Expose `Emitter`.\r\n\t */\r\n\t\r\n\tif (true) {\r\n\t  module.exports = Emitter;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Initialize a new `Emitter`.\r\n\t *\r\n\t * @api public\r\n\t */\r\n\t\r\n\tfunction Emitter(obj) {\r\n\t  if (obj) return mixin(obj);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Mixin the emitter properties.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @return {Object}\r\n\t * @api private\r\n\t */\r\n\t\r\n\tfunction mixin(obj) {\r\n\t  for (var key in Emitter.prototype) {\r\n\t    obj[key] = Emitter.prototype[key];\r\n\t  }\r\n\t  return obj;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Listen on the given `event` with `fn`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.on =\r\n\tEmitter.prototype.addEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n\t    .push(fn);\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds an `event` listener that will be invoked a single\r\n\t * time then automatically removed.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.once = function(event, fn){\r\n\t  function on() {\r\n\t    this.off(event, on);\r\n\t    fn.apply(this, arguments);\r\n\t  }\r\n\t\r\n\t  on.fn = fn;\r\n\t  this.on(event, on);\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Remove the given callback for `event` or all\r\n\t * registered callbacks.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.off =\r\n\tEmitter.prototype.removeListener =\r\n\tEmitter.prototype.removeAllListeners =\r\n\tEmitter.prototype.removeEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t\r\n\t  // all\r\n\t  if (0 == arguments.length) {\r\n\t    this._callbacks = {};\r\n\t    return this;\r\n\t  }\r\n\t\r\n\t  // specific event\r\n\t  var callbacks = this._callbacks['$' + event];\r\n\t  if (!callbacks) return this;\r\n\t\r\n\t  // remove all handlers\r\n\t  if (1 == arguments.length) {\r\n\t    delete this._callbacks['$' + event];\r\n\t    return this;\r\n\t  }\r\n\t\r\n\t  // remove specific handler\r\n\t  var cb;\r\n\t  for (var i = 0; i < callbacks.length; i++) {\r\n\t    cb = callbacks[i];\r\n\t    if (cb === fn || cb.fn === fn) {\r\n\t      callbacks.splice(i, 1);\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Emit `event` with the given args.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Mixed} ...\r\n\t * @return {Emitter}\r\n\t */\r\n\t\r\n\tEmitter.prototype.emit = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  var args = [].slice.call(arguments, 1)\r\n\t    , callbacks = this._callbacks['$' + event];\r\n\t\r\n\t  if (callbacks) {\r\n\t    callbacks = callbacks.slice(0);\r\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n\t      callbacks[i].apply(this, args);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Return array of callbacks for `event`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Array}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.listeners = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  return this._callbacks['$' + event] || [];\r\n\t};\r\n\t\r\n\t/**\r\n\t * Check if this emitter has `event` handlers.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.hasListeners = function(event){\r\n\t  return !! this.listeners(event).length;\r\n\t};\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Emitter = __webpack_require__(7);\n\t\n\tvar SCChannel = function (name, client, options) {\n\t  var self = this;\n\t\n\t  Emitter.call(this);\n\t\n\t  this.PENDING = 'pending';\n\t  this.SUBSCRIBED = 'subscribed';\n\t  this.UNSUBSCRIBED = 'unsubscribed';\n\t\n\t  this.name = name;\n\t  this.state = this.UNSUBSCRIBED;\n\t  this.client = client;\n\t\n\t  this.options = options || {};\n\t  this.setOptions(this.options);\n\t};\n\t\n\tSCChannel.prototype = Object.create(Emitter.prototype);\n\t\n\tSCChannel.prototype.setOptions = function (options) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  this.waitForAuth = options.waitForAuth || false;\n\t  this.batch = options.batch || false;\n\t\n\t  if (options.data !== undefined) {\n\t    this.data = options.data;\n\t  }\n\t};\n\t\n\tSCChannel.prototype.getState = function () {\n\t  return this.state;\n\t};\n\t\n\tSCChannel.prototype.subscribe = function (options) {\n\t  this.client.subscribe(this.name, options);\n\t};\n\t\n\tSCChannel.prototype.unsubscribe = function () {\n\t  this.client.unsubscribe(this.name);\n\t};\n\t\n\tSCChannel.prototype.isSubscribed = function (includePending) {\n\t  return this.client.isSubscribed(this.name, includePending);\n\t};\n\t\n\tSCChannel.prototype.publish = function (data, callback) {\n\t  this.client.publish(this.name, data, callback);\n\t};\n\t\n\tSCChannel.prototype.watch = function (handler) {\n\t  this.client.watch(this.name, handler);\n\t};\n\t\n\tSCChannel.prototype.unwatch = function (handler) {\n\t  this.client.unwatch(this.name, handler);\n\t};\n\t\n\tSCChannel.prototype.watchers = function () {\n\t  return this.client.watchers(this.name);\n\t};\n\t\n\tSCChannel.prototype.destroy = function () {\n\t  this.client.destroyChannel(this.name);\n\t};\n\t\n\tmodule.exports.SCChannel = SCChannel;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar scErrors = __webpack_require__(10);\n\tvar InvalidActionError = scErrors.InvalidActionError;\n\t\n\tvar Response = function (socket, id) {\n\t  this.socket = socket;\n\t  this.id = id;\n\t  this.sent = false;\n\t};\n\t\n\tResponse.prototype._respond = function (responseData) {\n\t  if (this.sent) {\n\t    throw new InvalidActionError('Response ' + this.id + ' has already been sent');\n\t  } else {\n\t    this.sent = true;\n\t    this.socket.send(this.socket.encode(responseData));\n\t  }\n\t};\n\t\n\tResponse.prototype.end = function (data) {\n\t  if (this.id) {\n\t    var responseData = {\n\t      rid: this.id\n\t    };\n\t    if (data !== undefined) {\n\t      responseData.data = data;\n\t    }\n\t    this._respond(responseData);\n\t  }\n\t};\n\t\n\tResponse.prototype.error = function (error, data) {\n\t  if (this.id) {\n\t    var err = scErrors.dehydrateError(error);\n\t\n\t    var responseData = {\n\t      rid: this.id,\n\t      error: err\n\t    };\n\t    if (data !== undefined) {\n\t      responseData.data = data;\n\t    }\n\t\n\t    this._respond(responseData);\n\t  }\n\t};\n\t\n\tResponse.prototype.callback = function (error, data) {\n\t  if (error) {\n\t    this.error(error, data);\n\t  } else {\n\t    this.end(data);\n\t  }\n\t};\n\t\n\tmodule.exports.Response = Response;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar decycle = __webpack_require__(11);\r\n\t\r\n\tvar isStrict = (function () { return !this; })();\r\n\t\r\n\tfunction AuthTokenExpiredError(message, expiry) {\r\n\t  this.name = 'AuthTokenExpiredError';\r\n\t  this.message = message;\r\n\t  this.expiry = expiry;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenExpiredError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction AuthTokenInvalidError(message) {\r\n\t  this.name = 'AuthTokenInvalidError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenInvalidError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction AuthTokenNotBeforeError(message, date) {\r\n\t  this.name = 'AuthTokenNotBeforeError';\r\n\t  this.message = message;\r\n\t  this.date = date;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\t// For any other auth token error.\r\n\tfunction AuthTokenError(message) {\r\n\t  this.name = 'AuthTokenError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction SilentMiddlewareBlockedError(message, type) {\r\n\t  this.name = 'SilentMiddlewareBlockedError';\r\n\t  this.message = message;\r\n\t  this.type = type;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction InvalidActionError(message) {\r\n\t  this.name = 'InvalidActionError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidActionError.prototype = Object.create(Error.prototype);\r\n\t\r\n\tfunction InvalidArgumentsError(message) {\r\n\t  this.name = 'InvalidArgumentsError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidArgumentsError.prototype = Object.create(Error.prototype);\r\n\t\r\n\tfunction InvalidOptionsError(message) {\r\n\t  this.name = 'InvalidOptionsError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidOptionsError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction InvalidMessageError(message) {\r\n\t  this.name = 'InvalidMessageError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidMessageError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction SocketProtocolError(message, code) {\r\n\t  this.name = 'SocketProtocolError';\r\n\t  this.message = message;\r\n\t  this.code = code;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tSocketProtocolError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction ServerProtocolError(message) {\r\n\t  this.name = 'ServerProtocolError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tServerProtocolError.prototype = Object.create(Error.prototype);\r\n\t\r\n\tfunction HTTPServerError(message) {\r\n\t  this.name = 'HTTPServerError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tHTTPServerError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction ResourceLimitError(message) {\r\n\t  this.name = 'ResourceLimitError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tResourceLimitError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction TimeoutError(message) {\r\n\t  this.name = 'TimeoutError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tTimeoutError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction BadConnectionError(message, type) {\r\n\t  this.name = 'BadConnectionError';\r\n\t  this.message = message;\r\n\t  this.type = type;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tBadConnectionError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction BrokerError(message) {\r\n\t  this.name = 'BrokerError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tBrokerError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction ProcessExitError(message, code) {\r\n\t  this.name = 'ProcessExitError';\r\n\t  this.message = message;\r\n\t  this.code = code;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tProcessExitError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction UnknownError(message) {\r\n\t  this.name = 'UnknownError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tUnknownError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\t// Expose all error types\r\n\t\r\n\tmodule.exports = {\r\n\t  AuthTokenExpiredError: AuthTokenExpiredError,\r\n\t  AuthTokenInvalidError: AuthTokenInvalidError,\r\n\t  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\r\n\t  AuthTokenError: AuthTokenError,\r\n\t  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\r\n\t  InvalidActionError: InvalidActionError,\r\n\t  InvalidArgumentsError: InvalidArgumentsError,\r\n\t  InvalidOptionsError: InvalidOptionsError,\r\n\t  InvalidMessageError: InvalidMessageError,\r\n\t  SocketProtocolError: SocketProtocolError,\r\n\t  ServerProtocolError: ServerProtocolError,\r\n\t  HTTPServerError: HTTPServerError,\r\n\t  ResourceLimitError: ResourceLimitError,\r\n\t  TimeoutError: TimeoutError,\r\n\t  BadConnectionError: BadConnectionError,\r\n\t  BrokerError: BrokerError,\r\n\t  ProcessExitError: ProcessExitError,\r\n\t  UnknownError: UnknownError\r\n\t};\r\n\t\r\n\tmodule.exports.socketProtocolErrorStatuses = {\r\n\t  1001: 'Socket was disconnected',\r\n\t  1002: 'A WebSocket protocol error was encountered',\r\n\t  1003: 'Server terminated socket because it received invalid data',\r\n\t  1005: 'Socket closed without status code',\r\n\t  1006: 'Socket hung up',\r\n\t  1007: 'Message format was incorrect',\r\n\t  1008: 'Encountered a policy violation',\r\n\t  1009: 'Message was too big to process',\r\n\t  1010: 'Client ended the connection because the server did not comply with extension requirements',\r\n\t  1011: 'Server encountered an unexpected fatal condition',\r\n\t  4000: 'Server ping timed out',\r\n\t  4001: 'Client pong timed out',\r\n\t  4002: 'Server failed to sign auth token',\r\n\t  4003: 'Failed to complete handshake',\r\n\t  4004: 'Client failed to save auth token',\r\n\t  4005: 'Did not receive #handshake from client before timeout',\r\n\t  4006: 'Failed to bind socket to message broker',\r\n\t  4007: 'Client connection establishment timed out'\r\n\t};\r\n\t\r\n\tmodule.exports.socketProtocolIgnoreStatuses = {\r\n\t  1000: 'Socket closed normally',\r\n\t  1001: 'Socket hung up'\r\n\t};\r\n\t\r\n\t// Properties related to error domains cannot be serialized.\r\n\tvar unserializableErrorProperties = {\r\n\t  domain: 1,\r\n\t  domainEmitter: 1,\r\n\t  domainThrown: 1\r\n\t};\r\n\t\r\n\tmodule.exports.dehydrateError = function (error, includeStackTrace) {\r\n\t  var dehydratedError;\r\n\t\r\n\t  if (error && typeof error == 'object') {\r\n\t    dehydratedError = {\r\n\t      message: error.message\r\n\t    };\r\n\t    if (includeStackTrace) {\r\n\t      dehydratedError.stack = error.stack;\r\n\t    }\r\n\t    for (var i in error) {\r\n\t      if (!unserializableErrorProperties[i]) {\r\n\t        dehydratedError[i] = error[i];\r\n\t      }\r\n\t    }\r\n\t  } else if (typeof error == 'function') {\r\n\t    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\r\n\t  } else {\r\n\t    dehydratedError = error;\r\n\t  }\r\n\t\r\n\t  return decycle(dehydratedError);\r\n\t};\r\n\t\r\n\tmodule.exports.hydrateError = function (error) {\r\n\t  var hydratedError = null;\r\n\t  if (error != null) {\r\n\t    if (typeof error == 'object') {\r\n\t      hydratedError = new Error(error.message);\r\n\t      for (var i in error) {\r\n\t        if (error.hasOwnProperty(i)) {\r\n\t          hydratedError[i] = error[i];\r\n\t        }\r\n\t      }\r\n\t    } else {\r\n\t      hydratedError = error;\r\n\t    }\r\n\t  }\r\n\t  return hydratedError;\r\n\t};\r\n\t\r\n\tmodule.exports.decycle = decycle;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t// Based on https://github.com/dscape/cycle/blob/master/cycle.js\r\n\t\r\n\tmodule.exports = function decycle(object) {\r\n\t// Make a deep copy of an object or array, assuring that there is at most\r\n\t// one instance of each object or array in the resulting structure. The\r\n\t// duplicate references (which might be forming cycles) are replaced with\r\n\t// an object of the form\r\n\t//      {$ref: PATH}\r\n\t// where the PATH is a JSONPath string that locates the first occurance.\r\n\t// So,\r\n\t//      var a = [];\r\n\t//      a[0] = a;\r\n\t//      return JSON.stringify(JSON.decycle(a));\r\n\t// produces the string '[{\"$ref\":\"$\"}]'.\r\n\t\r\n\t// JSONPath is used to locate the unique object. $ indicates the top level of\r\n\t// the object or array. [NUMBER] or [STRING] indicates a child member or\r\n\t// property.\r\n\t\r\n\t    var objects = [],   // Keep a reference to each unique object or array\r\n\t        paths = [];     // Keep the path to each unique object or array\r\n\t\r\n\t    return (function derez(value, path) {\r\n\t\r\n\t// The derez recurses through the object, producing the deep copy.\r\n\t\r\n\t        var i,          // The loop counter\r\n\t            name,       // Property name\r\n\t            nu;         // The new object or array\r\n\t\r\n\t// typeof null === 'object', so go on if this value is really an object but not\r\n\t// one of the weird builtin objects.\r\n\t\r\n\t        if (typeof value === 'object' && value !== null &&\r\n\t                !(value instanceof Boolean) &&\r\n\t                !(value instanceof Date)    &&\r\n\t                !(value instanceof Number)  &&\r\n\t                !(value instanceof RegExp)  &&\r\n\t                !(value instanceof String)) {\r\n\t\r\n\t// If the value is an object or array, look to see if we have already\r\n\t// encountered it. If so, return a $ref/path object. This is a hard way,\r\n\t// linear search that will get slower as the number of unique objects grows.\r\n\t\r\n\t            for (i = 0; i < objects.length; i += 1) {\r\n\t                if (objects[i] === value) {\r\n\t                    return {$ref: paths[i]};\r\n\t                }\r\n\t            }\r\n\t\r\n\t// Otherwise, accumulate the unique value and its path.\r\n\t\r\n\t            objects.push(value);\r\n\t            paths.push(path);\r\n\t\r\n\t// If it is an array, replicate the array.\r\n\t\r\n\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\r\n\t                nu = [];\r\n\t                for (i = 0; i < value.length; i += 1) {\r\n\t                    nu[i] = derez(value[i], path + '[' + i + ']');\r\n\t                }\r\n\t            } else {\r\n\t\r\n\t// If it is an object, replicate the object.\r\n\t\r\n\t                nu = {};\r\n\t                for (name in value) {\r\n\t                    if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n\t                        nu[name] = derez(value[name],\r\n\t                            path + '[' + JSON.stringify(name) + ']');\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return nu;\r\n\t        }\r\n\t        return value;\r\n\t    }(object, '$'));\r\n\t};\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var AuthEngine = function () {\n\t  this._internalStorage = {};\n\t  this.isLocalStorageEnabled = this._checkLocalStorageEnabled();\n\t};\n\t\n\tAuthEngine.prototype._checkLocalStorageEnabled = function () {\n\t  var err;\n\t  try {\n\t    // Some browsers will throw an error here if localStorage is disabled.\n\t    global.localStorage;\n\t\n\t    // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n\t    // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.\n\t    global.localStorage.setItem('__scLocalStorageTest', 1);\n\t    global.localStorage.removeItem('__scLocalStorageTest');\n\t  } catch (e) {\n\t    err = e;\n\t  }\n\t  return !err;\n\t};\n\t\n\tAuthEngine.prototype.saveToken = function (name, token, options, callback) {\n\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t    global.localStorage.setItem(name, token);\n\t  } else {\n\t    this._internalStorage[name] = token;\n\t  }\n\t  callback && callback(null, token);\n\t};\n\t\n\tAuthEngine.prototype.removeToken = function (name, callback) {\n\t  var token;\n\t\n\t  this.loadToken(name, function (err, authToken) {\n\t    token = authToken;\n\t  });\n\t\n\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t    global.localStorage.removeItem(name);\n\t  } else {\n\t    delete this._internalStorage[name];\n\t  }\n\t\n\t  callback && callback(null, token);\n\t};\n\t\n\tAuthEngine.prototype.loadToken = function (name, callback) {\n\t  var token;\n\t\n\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t    token = global.localStorage.getItem(name);\n\t  } else {\n\t    token = this._internalStorage[name] || null;\n\t  }\n\t  callback(null, token);\n\t};\n\t\n\tmodule.exports.AuthEngine = AuthEngine;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t\n\tvar arrayBufferToBase64 = function (arraybuffer) {\n\t  var bytes = new Uint8Array(arraybuffer);\n\t  var len = bytes.length;\n\t  var base64 = '';\n\t\n\t  for (var i = 0; i < len; i += 3) {\n\t    base64 += base64Chars[bytes[i] >> 2];\n\t    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t    base64 += base64Chars[bytes[i + 2] & 63];\n\t  }\n\t\n\t  if ((len % 3) === 2) {\n\t    base64 = base64.substring(0, base64.length - 1) + '=';\n\t  } else if (len % 3 === 1) {\n\t    base64 = base64.substring(0, base64.length - 2) + '==';\n\t  }\n\t\n\t  return base64;\n\t};\n\t\n\tvar binaryToBase64Replacer = function (key, value) {\n\t  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n\t    return {\n\t      base64: true,\n\t      data: arrayBufferToBase64(value)\n\t    };\n\t  } else if (global.Buffer) {\n\t    if (value instanceof global.Buffer){\n\t      return {\n\t        base64: true,\n\t        data: value.toString('base64')\n\t      };\n\t    }\n\t    // Some versions of Node.js convert Buffers to Objects before they are passed to\n\t    // the replacer function - Because of this, we need to rehydrate Buffers\n\t    // before we can convert them to base64 strings.\n\t    if (value && value.type == 'Buffer' && value.data instanceof Array) {\n\t      var rehydratedBuffer;\n\t      if (global.Buffer.from) {\n\t        rehydratedBuffer = global.Buffer.from(value.data);\n\t      } else {\n\t        rehydratedBuffer = new global.Buffer(value.data);\n\t      }\n\t      return {\n\t        base64: true,\n\t        data: rehydratedBuffer.toString('base64')\n\t      };\n\t    }\n\t  }\n\t  return value;\n\t};\n\t\n\t// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n\t// See encode function below for more details.\n\tmodule.exports.decode = function (input) {\n\t  if (input == null) {\n\t   return null;\n\t  }\n\t  // Leave ping or pong message as is\n\t  if (input == '#1' || input == '#2') {\n\t    return input;\n\t  }\n\t  var message = input.toString();\n\t\n\t  try {\n\t    return JSON.parse(message);\n\t  } catch (err) {}\n\t  return message;\n\t};\n\t\n\t\n\t// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n\t// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n\t// If you want to create your own custom codec, you can encode the object into any format\n\t// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n\t// function is able to rehydrate that object back into its original JavaScript Object format\n\t// (which adheres to the SC protocol).\n\t// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n\t// for details about the SC protocol.\n\tmodule.exports.encode = function (object) {\n\t  // Leave ping or pong message as is\n\t  if (object == '#1' || object == '#2') {\n\t    return object;\n\t  }\n\t  return JSON.stringify(object, binaryToBase64Replacer);\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var Emitter = __webpack_require__(7);\n\tvar Response = __webpack_require__(9).Response;\n\tvar querystring = __webpack_require__(15);\n\tvar WebSocket;\n\tvar createWebSocket;\n\t\n\tif (global.WebSocket) {\n\t  WebSocket = global.WebSocket;\n\t  createWebSocket = function (uri, options) {\n\t    return new WebSocket(uri);\n\t  };\n\t} else {\n\t  WebSocket = __webpack_require__(18);\n\t  createWebSocket = function (uri, options) {\n\t    return new WebSocket(uri, null, options);\n\t  };\n\t}\n\t\n\tvar scErrors = __webpack_require__(10);\n\tvar TimeoutError = scErrors.TimeoutError;\n\tvar BadConnectionError = scErrors.BadConnectionError;\n\t\n\t\n\tvar SCTransport = function (authEngine, codecEngine, options) {\n\t  this.state = this.CLOSED;\n\t  this.auth = authEngine;\n\t  this.codec = codecEngine;\n\t  this.options = options;\n\t  this.connectTimeout = options.connectTimeout;\n\t  this.pingTimeout = options.ackTimeout;\n\t  this.callIdGenerator = options.callIdGenerator;\n\t  this.authTokenName = options.authTokenName;\n\t\n\t  this._pingTimeoutTicker = null;\n\t  this._callbackMap = {};\n\t  this._batchSendList = [];\n\t\n\t  this.open();\n\t};\n\t\n\tSCTransport.prototype = Object.create(Emitter.prototype);\n\t\n\tSCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';\n\tSCTransport.OPEN = SCTransport.prototype.OPEN = 'open';\n\tSCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';\n\t\n\tSCTransport.prototype.uri = function () {\n\t  var query = this.options.query || {};\n\t  var schema = this.options.secure ? 'wss' : 'ws';\n\t\n\t  if (this.options.timestampRequests) {\n\t    query[this.options.timestampParam] = (new Date()).getTime();\n\t  }\n\t\n\t  query = querystring.encode(query);\n\t\n\t  if (query.length) {\n\t    query = '?' + query;\n\t  }\n\t\n\t  var host;\n\t  if (this.options.host) {\n\t    host = this.options.host;\n\t  } else {\n\t    var port = '';\n\t\n\t    if (this.options.port && ((schema == 'wss' && this.options.port != 443)\n\t      || (schema == 'ws' && this.options.port != 80))) {\n\t      port = ':' + this.options.port;\n\t    }\n\t    host = this.options.hostname + port;\n\t  }\n\t\n\t  return schema + '://' + host + this.options.path + query;\n\t};\n\t\n\tSCTransport.prototype.open = function () {\n\t  var self = this;\n\t\n\t  this.state = this.CONNECTING;\n\t  var uri = this.uri();\n\t\n\t  var wsSocket = createWebSocket(uri, this.options);\n\t  wsSocket.binaryType = this.options.binaryType;\n\t  this.socket = wsSocket;\n\t\n\t  wsSocket.onopen = function () {\n\t    self._onOpen();\n\t  };\n\t\n\t  wsSocket.onclose = function (event) {\n\t    var code;\n\t    if (event.code == null) {\n\t      // This is to handle an edge case in React Native whereby\n\t      // event.code is undefined when the mobile device is locked.\n\t      // TODO: This is not perfect since this condition could also apply to\n\t      // an abnormal close (no close control frame) which would be a 1006.\n\t      code = 1005;\n\t    } else {\n\t      code = event.code;\n\t    }\n\t    self._onClose(code, event.reason);\n\t  };\n\t\n\t  wsSocket.onmessage = function (message, flags) {\n\t    self._onMessage(message.data);\n\t  };\n\t\n\t  wsSocket.onerror = function (error) {\n\t    // The onclose event will be called automatically after the onerror event\n\t    // if the socket is connected - Otherwise, if it's in the middle of\n\t    // connecting, we want to close it manually with a 1006 - This is necessary\n\t    // to prevent inconsistent behavior when running the client in Node.js\n\t    // vs in a browser.\n\t\n\t    if (self.state === self.CONNECTING) {\n\t      self._onClose(1006);\n\t    }\n\t  };\n\t\n\t  this._connectTimeoutRef = setTimeout(function () {\n\t    self._onClose(4007);\n\t    self.socket.close(4007);\n\t  }, this.connectTimeout);\n\t};\n\t\n\tSCTransport.prototype._onOpen = function () {\n\t  var self = this;\n\t\n\t  clearTimeout(this._connectTimeoutRef);\n\t  this._resetPingTimeout();\n\t\n\t  this._handshake(function (err, status) {\n\t    if (err) {\n\t      self._onError(err);\n\t      self._onClose(4003);\n\t      self.socket.close(4003);\n\t    } else {\n\t      self.state = self.OPEN;\n\t      Emitter.prototype.emit.call(self, 'open', status);\n\t      self._resetPingTimeout();\n\t    }\n\t  });\n\t};\n\t\n\tSCTransport.prototype._handshake = function (callback) {\n\t  var self = this;\n\t  this.auth.loadToken(this.authTokenName, function (err, token) {\n\t    if (err) {\n\t      callback(err);\n\t    } else {\n\t      // Don't wait for this.state to be 'open'.\n\t      // The underlying WebSocket (this.socket) is already open.\n\t      var options = {\n\t        force: true\n\t      };\n\t      self.emit('#handshake', {\n\t        authToken: token\n\t      }, options, function (err, status) {\n\t        if (status) {\n\t          // Add the token which was used as part of authentication attempt\n\t          // to the status object.\n\t          status.authToken = token;\n\t          if (status.authError) {\n\t            status.authError = scErrors.hydrateError(status.authError);\n\t          }\n\t        }\n\t        callback(err, status);\n\t      });\n\t    }\n\t  });\n\t};\n\t\n\tSCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n\t  for (var i in this._callbackMap) {\n\t    if (this._callbackMap.hasOwnProperty(i)) {\n\t      var eventObject = this._callbackMap[i];\n\t      delete this._callbackMap[i];\n\t\n\t      clearTimeout(eventObject.timeout);\n\t      delete eventObject.timeout;\n\t\n\t      var errorMessage = \"Event '\" + eventObject.event +\n\t        \"' was aborted due to a bad connection\";\n\t      var badConnectionError = new BadConnectionError(errorMessage, failureType);\n\t\n\t      var callback = eventObject.callback;\n\t      delete eventObject.callback;\n\t      callback.call(eventObject, badConnectionError, eventObject);\n\t    }\n\t  }\n\t};\n\t\n\tSCTransport.prototype._onClose = function (code, data) {\n\t  delete this.socket.onopen;\n\t  delete this.socket.onclose;\n\t  delete this.socket.onmessage;\n\t  delete this.socket.onerror;\n\t\n\t  clearTimeout(this._connectTimeoutRef);\n\t\n\t  if (this.state == this.OPEN) {\n\t    this.state = this.CLOSED;\n\t    Emitter.prototype.emit.call(this, 'close', code, data);\n\t    this._abortAllPendingEventsDueToBadConnection('disconnect');\n\t\n\t  } else if (this.state == this.CONNECTING) {\n\t    this.state = this.CLOSED;\n\t    Emitter.prototype.emit.call(this, 'openAbort', code, data);\n\t    this._abortAllPendingEventsDueToBadConnection('connectAbort');\n\t  }\n\t};\n\t\n\tSCTransport.prototype._handleEventObject = function (obj, message) {\n\t  if (obj && obj.event != null) {\n\t    var response = new Response(this, obj.cid);\n\t    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);\n\t  } else if (obj && obj.rid != null) {\n\t    var eventObject = this._callbackMap[obj.rid];\n\t    if (eventObject) {\n\t      clearTimeout(eventObject.timeout);\n\t      delete eventObject.timeout;\n\t      delete this._callbackMap[obj.rid];\n\t\n\t      if (eventObject.callback) {\n\t        var rehydratedError = scErrors.hydrateError(obj.error);\n\t        eventObject.callback(rehydratedError, obj.data);\n\t      }\n\t    }\n\t  } else {\n\t    Emitter.prototype.emit.call(this, 'event', 'raw', message);\n\t  }\n\t};\n\t\n\tSCTransport.prototype._onMessage = function (message) {\n\t  Emitter.prototype.emit.call(this, 'event', 'message', message);\n\t\n\t  var obj = this.decode(message);\n\t\n\t  // If ping\n\t  if (obj == '#1') {\n\t    this._resetPingTimeout();\n\t    if (this.socket.readyState == this.socket.OPEN) {\n\t      this.sendObject('#2');\n\t    }\n\t  } else {\n\t    if (Array.isArray(obj)) {\n\t      var len = obj.length;\n\t      for (var i = 0; i < len; i++) {\n\t        this._handleEventObject(obj[i], message);\n\t      }\n\t    } else {\n\t      this._handleEventObject(obj, message);\n\t    }\n\t  }\n\t};\n\t\n\tSCTransport.prototype._onError = function (err) {\n\t  Emitter.prototype.emit.call(this, 'error', err);\n\t};\n\t\n\tSCTransport.prototype._resetPingTimeout = function () {\n\t  var self = this;\n\t\n\t  var now = (new Date()).getTime();\n\t  clearTimeout(this._pingTimeoutTicker);\n\t\n\t  this._pingTimeoutTicker = setTimeout(function () {\n\t    self._onClose(4000);\n\t    self.socket.close(4000);\n\t  }, this.pingTimeout);\n\t};\n\t\n\tSCTransport.prototype.getBytesReceived = function () {\n\t  return this.socket.bytesReceived;\n\t};\n\t\n\tSCTransport.prototype.close = function (code, data) {\n\t  code = code || 1000;\n\t\n\t  if (this.state == this.OPEN) {\n\t    var packet = {\n\t      code: code,\n\t      data: data\n\t    };\n\t    this.emit('#disconnect', packet);\n\t\n\t    this._onClose(code, data);\n\t    this.socket.close(code);\n\t\n\t  } else if (this.state == this.CONNECTING) {\n\t    this._onClose(code, data);\n\t    this.socket.close(code);\n\t  }\n\t};\n\t\n\tSCTransport.prototype.emitObject = function (eventObject, options) {\n\t  var simpleEventObject = {\n\t    event: eventObject.event,\n\t    data: eventObject.data\n\t  };\n\t\n\t  if (eventObject.callback) {\n\t    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();\n\t    this._callbackMap[eventObject.cid] = eventObject;\n\t  }\n\t\n\t  this.sendObject(simpleEventObject, options);\n\t\n\t  return eventObject.cid || null;\n\t};\n\t\n\tSCTransport.prototype._handleEventAckTimeout = function (eventObject) {\n\t\n\t  if (eventObject.cid) {\n\t    delete this._callbackMap[eventObject.cid];\n\t  }\n\t  delete eventObject.timeout;\n\t\n\t  var callback = eventObject.callback;\n\t  if (callback) {\n\t    delete eventObject.callback;\n\t    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n\t    callback.call(eventObject, error, eventObject);\n\t  }\n\t};\n\t\n\t// The last two optional arguments (a and b) can be options and/or callback\n\tSCTransport.prototype.emit = function (event, data, a, b) {\n\t  var self = this;\n\t\n\t  var callback, options;\n\t\n\t  if (b) {\n\t    options = a;\n\t    callback = b;\n\t  } else {\n\t    if (a instanceof Function) {\n\t      options = {};\n\t      callback = a;\n\t    } else {\n\t      options = a;\n\t    }\n\t  }\n\t\n\t  var eventObject = {\n\t    event: event,\n\t    data: data,\n\t    callback: callback\n\t  };\n\t\n\t  if (callback && !options.noTimeout) {\n\t    eventObject.timeout = setTimeout(function () {\n\t      self._handleEventAckTimeout(eventObject);\n\t    }, this.options.ackTimeout);\n\t  }\n\t\n\t  var cid = null;\n\t  if (this.state == this.OPEN || options.force) {\n\t    cid = this.emitObject(eventObject, options);\n\t  }\n\t  return cid;\n\t};\n\t\n\tSCTransport.prototype.cancelPendingResponse = function (cid) {\n\t  delete this._callbackMap[cid];\n\t};\n\t\n\tSCTransport.prototype.decode = function (message) {\n\t  return this.codec.decode(message);\n\t};\n\t\n\tSCTransport.prototype.encode = function (object) {\n\t  return this.codec.encode(object);\n\t};\n\t\n\tSCTransport.prototype.send = function (data) {\n\t  if (this.socket.readyState != this.socket.OPEN) {\n\t    this._onClose(1005);\n\t  } else {\n\t    this.socket.send(data);\n\t  }\n\t};\n\t\n\tSCTransport.prototype.serializeObject = function (object) {\n\t  var str, formatError;\n\t  try {\n\t    str = this.encode(object);\n\t  } catch (err) {\n\t    formatError = err;\n\t    this._onError(formatError);\n\t  }\n\t  if (!formatError) {\n\t    return str;\n\t  }\n\t  return null;\n\t};\n\t\n\tSCTransport.prototype.sendObjectBatch = function (object) {\n\t  var self = this;\n\t\n\t  this._batchSendList.push(object);\n\t  if (this._batchTimeout) {\n\t    return;\n\t  }\n\t\n\t  this._batchTimeout = setTimeout(function () {\n\t    delete self._batchTimeout;\n\t    if (self._batchSendList.length) {\n\t      var str = self.serializeObject(self._batchSendList);\n\t      if (str != null) {\n\t        self.send(str);\n\t      }\n\t      self._batchSendList = [];\n\t    }\n\t  }, this.options.pubSubBatchDuration || 0);\n\t};\n\t\n\tSCTransport.prototype.sendObjectSingle = function (object) {\n\t  var str = this.serializeObject(object);\n\t  if (str != null) {\n\t    this.send(str);\n\t  }\n\t};\n\t\n\tSCTransport.prototype.sendObject = function (object, options) {\n\t  if (options && options.batch) {\n\t    this.sendObjectBatch(object);\n\t  } else {\n\t    this.sendObjectSingle(object);\n\t  }\n\t};\n\t\n\tmodule.exports.SCTransport = SCTransport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.decode = exports.parse = __webpack_require__(16);\n\texports.encode = exports.stringify = __webpack_require__(17);\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t'use strict';\n\t\n\t// If obj.hasOwnProperty has been overridden, then calling\n\t// obj.hasOwnProperty(prop) will break.\n\t// See: https://github.com/joyent/node/issues/1707\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\t\n\tmodule.exports = function(qs, sep, eq, options) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  var obj = {};\n\t\n\t  if (typeof qs !== 'string' || qs.length === 0) {\n\t    return obj;\n\t  }\n\t\n\t  var regexp = /\\+/g;\n\t  qs = qs.split(sep);\n\t\n\t  var maxKeys = 1000;\n\t  if (options && typeof options.maxKeys === 'number') {\n\t    maxKeys = options.maxKeys;\n\t  }\n\t\n\t  var len = qs.length;\n\t  // maxKeys <= 0 means that we should not limit keys count\n\t  if (maxKeys > 0 && len > maxKeys) {\n\t    len = maxKeys;\n\t  }\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    var x = qs[i].replace(regexp, '%20'),\n\t        idx = x.indexOf(eq),\n\t        kstr, vstr, k, v;\n\t\n\t    if (idx >= 0) {\n\t      kstr = x.substr(0, idx);\n\t      vstr = x.substr(idx + 1);\n\t    } else {\n\t      kstr = x;\n\t      vstr = '';\n\t    }\n\t\n\t    k = decodeURIComponent(kstr);\n\t    v = decodeURIComponent(vstr);\n\t\n\t    if (!hasOwnProperty(obj, k)) {\n\t      obj[k] = v;\n\t    } else if (Array.isArray(obj[k])) {\n\t      obj[k].push(v);\n\t    } else {\n\t      obj[k] = [obj[k], v];\n\t    }\n\t  }\n\t\n\t  return obj;\n\t};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t'use strict';\n\t\n\tvar stringifyPrimitive = function(v) {\n\t  switch (typeof v) {\n\t    case 'string':\n\t      return v;\n\t\n\t    case 'boolean':\n\t      return v ? 'true' : 'false';\n\t\n\t    case 'number':\n\t      return isFinite(v) ? v : '';\n\t\n\t    default:\n\t      return '';\n\t  }\n\t};\n\t\n\tmodule.exports = function(obj, sep, eq, name) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  if (obj === null) {\n\t    obj = undefined;\n\t  }\n\t\n\t  if (typeof obj === 'object') {\n\t    return Object.keys(obj).map(function(k) {\n\t      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\t      if (Array.isArray(obj[k])) {\n\t        return obj[k].map(function(v) {\n\t          return ks + encodeURIComponent(stringifyPrimitive(v));\n\t        }).join(sep);\n\t      } else {\n\t        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n\t      }\n\t    }).join(sep);\n\t\n\t  }\n\t\n\t  if (!name) return '';\n\t  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n\t         encodeURIComponent(stringifyPrimitive(obj));\n\t};\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\tvar global;\n\tif (typeof WorkerGlobalScope !== 'undefined') {\n\t  global = self;\n\t} else {\n\t  global = typeof window != 'undefined' && window || (function() { return this; })();\n\t}\n\t\n\tvar WebSocket = global.WebSocket || global.MozWebSocket;\n\t\n\t/**\n\t * WebSocket constructor.\n\t *\n\t * The third `opts` options object gets ignored in web browsers, since it's\n\t * non-standard, and throws a TypeError if passed to the constructor.\n\t * See: https://github.com/einaros/ws/issues/227\n\t *\n\t * @param {String} uri\n\t * @param {Array} protocols (optional)\n\t * @param {Object} opts (optional)\n\t * @api public\n\t */\n\t\n\tfunction ws(uri, protocols, opts) {\n\t  var instance;\n\t  if (protocols) {\n\t    instance = new WebSocket(uri, protocols);\n\t  } else {\n\t    instance = new WebSocket(uri);\n\t  }\n\t  return instance;\n\t}\n\t\n\tif (WebSocket) ws.prototype = WebSocket.prototype;\n\t\n\tmodule.exports = WebSocket ? ws : null;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(20);\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Constants.\n\t */\n\t\n\tvar errorMessage;\n\t\n\terrorMessage = 'An argument without append, prepend, ' +\n\t    'or detach methods was given to `List';\n\t\n\t/**\n\t * Creates a new List: A linked list is a bit like an Array, but\n\t * knows nothing about how many items are in it, and knows only about its\n\t * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n\t * &c.) knows which item comes before or after it (its more like the\n\t * implementation of the DOM in JavaScript).\n\t * @global\n\t * @private\n\t * @constructor\n\t * @class Represents an instance of List.\n\t */\n\t\n\tfunction List(/*items...*/) {\n\t    if (arguments.length) {\n\t        return List.from(arguments);\n\t    }\n\t}\n\t\n\tvar ListPrototype;\n\t\n\tListPrototype = List.prototype;\n\t\n\t/**\n\t * Creates a new list from the arguments (each a list item) passed in.\n\t * @name List.of\n\t * @param {...ListItem} [items] - Zero or more items to attach.\n\t * @returns {list} - A new instance of List.\n\t */\n\t\n\tList.of = function (/*items...*/) {\n\t    return List.from.call(this, arguments);\n\t};\n\t\n\t/**\n\t * Creates a new list from the given array-like object (each a list item)\n\t * passed in.\n\t * @name List.from\n\t * @param {ListItem[]} [items] - The items to append.\n\t * @returns {list} - A new instance of List.\n\t */\n\tList.from = function (items) {\n\t    var list = new this(), length, iterator, item;\n\t\n\t    if (items && (length = items.length)) {\n\t        iterator = -1;\n\t\n\t        while (++iterator < length) {\n\t            item = items[iterator];\n\t\n\t            if (item !== null && item !== undefined) {\n\t                list.append(item);\n\t            }\n\t        }\n\t    }\n\t\n\t    return list;\n\t};\n\t\n\t/**\n\t * List#head\n\t * Default to `null`.\n\t */\n\tListPrototype.head = null;\n\t\n\t/**\n\t * List#tail\n\t * Default to `null`.\n\t */\n\tListPrototype.tail = null;\n\t\n\t/**\n\t * Returns the list's items as an array. This does *not* detach the items.\n\t * @name List#toArray\n\t * @returns {ListItem[]} - An array of (still attached) ListItems.\n\t */\n\tListPrototype.toArray = function () {\n\t    var item = this.head,\n\t        result = [];\n\t\n\t    while (item) {\n\t        result.push(item);\n\t        item = item.next;\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\t/**\n\t * Prepends the given item to the list: Item will be the new first item\n\t * (`head`).\n\t * @name List#prepend\n\t * @param {ListItem} item - The item to prepend.\n\t * @returns {ListItem} - An instance of ListItem (the given item).\n\t */\n\tListPrototype.prepend = function (item) {\n\t    if (!item) {\n\t        return false;\n\t    }\n\t\n\t    if (!item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + '#prepend`.');\n\t    }\n\t\n\t    var self, head;\n\t\n\t    // Cache self.\n\t    self = this;\n\t\n\t    // If self has a first item, defer prepend to the first items prepend\n\t    // method, and return the result.\n\t    head = self.head;\n\t\n\t    if (head) {\n\t        return head.prepend(item);\n\t    }\n\t\n\t    // ...otherwise, there is no `head` (or `tail`) item yet.\n\t\n\t    // Detach the prependee.\n\t    item.detach();\n\t\n\t    // Set the prependees parent list to reference self.\n\t    item.list = self;\n\t\n\t    // Set self's first item to the prependee, and return the item.\n\t    self.head = item;\n\t\n\t    return item;\n\t};\n\t\n\t/**\n\t * Appends the given item to the list: Item will be the new last item (`tail`)\n\t * if the list had a first item, and its first item (`head`) otherwise.\n\t * @name List#append\n\t * @param {ListItem} item - The item to append.\n\t * @returns {ListItem} - An instance of ListItem (the given item).\n\t */\n\t\n\tListPrototype.append = function (item) {\n\t    if (!item) {\n\t        return false;\n\t    }\n\t\n\t    if (!item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + '#append`.');\n\t    }\n\t\n\t    var self, head, tail;\n\t\n\t    // Cache self.\n\t    self = this;\n\t\n\t    // If self has a last item, defer appending to the last items append\n\t    // method, and return the result.\n\t    tail = self.tail;\n\t\n\t    if (tail) {\n\t        return tail.append(item);\n\t    }\n\t\n\t    // If self has a first item, defer appending to the first items append\n\t    // method, and return the result.\n\t    head = self.head;\n\t\n\t    if (head) {\n\t        return head.append(item);\n\t    }\n\t\n\t    // ...otherwise, there is no `tail` or `head` item yet.\n\t\n\t    // Detach the appendee.\n\t    item.detach();\n\t\n\t    // Set the appendees parent list to reference self.\n\t    item.list = self;\n\t\n\t    // Set self's first item to the appendee, and return the item.\n\t    self.head = item;\n\t\n\t    return item;\n\t};\n\t\n\t/**\n\t * Creates a new ListItem: A linked list item is a bit like DOM node:\n\t * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n\t * and the item after it (`next`).\n\t * @global\n\t * @private\n\t * @constructor\n\t * @class Represents an instance of ListItem.\n\t */\n\t\n\tfunction ListItem() {}\n\t\n\tList.Item = ListItem;\n\t\n\tvar ListItemPrototype = ListItem.prototype;\n\t\n\tListItemPrototype.next = null;\n\t\n\tListItemPrototype.prev = null;\n\t\n\tListItemPrototype.list = null;\n\t\n\t/**\n\t * Detaches the item operated on from its parent list.\n\t * @name ListItem#detach\n\t * @returns {ListItem} - The item operated on.\n\t */\n\tListItemPrototype.detach = function () {\n\t    // Cache self, the parent list, and the previous and next items.\n\t    var self = this,\n\t        list = self.list,\n\t        prev = self.prev,\n\t        next = self.next;\n\t\n\t    // If the item is already detached, return self.\n\t    if (!list) {\n\t        return self;\n\t    }\n\t\n\t    // If self is the last item in the parent list, link the lists last item\n\t    // to the previous item.\n\t    if (list.tail === self) {\n\t        list.tail = prev;\n\t    }\n\t\n\t    // If self is the first item in the parent list, link the lists first item\n\t    // to the next item.\n\t    if (list.head === self) {\n\t        list.head = next;\n\t    }\n\t\n\t    // If both the last and first items in the parent list are the same,\n\t    // remove the link to the last item.\n\t    if (list.tail === list.head) {\n\t        list.tail = null;\n\t    }\n\t\n\t    // If a previous item exists, link its next item to selfs next item.\n\t    if (prev) {\n\t        prev.next = next;\n\t    }\n\t\n\t    // If a next item exists, link its previous item to selfs previous item.\n\t    if (next) {\n\t        next.prev = prev;\n\t    }\n\t\n\t    // Remove links from self to both the next and previous items, and to the\n\t    // parent list.\n\t    self.prev = self.next = self.list = null;\n\t\n\t    // Return self.\n\t    return self;\n\t};\n\t\n\t/**\n\t * Prepends the given item *before* the item operated on.\n\t * @name ListItem#prepend\n\t * @param {ListItem} item - The item to prepend.\n\t * @returns {ListItem} - The item operated on, or false when that item is not\n\t * attached.\n\t */\n\tListItemPrototype.prepend = function (item) {\n\t    if (!item || !item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + 'Item#prepend`.');\n\t    }\n\t\n\t    // Cache self, the parent list, and the previous item.\n\t    var self = this,\n\t        list = self.list,\n\t        prev = self.prev;\n\t\n\t    // If self is detached, return false.\n\t    if (!list) {\n\t        return false;\n\t    }\n\t\n\t    // Detach the prependee.\n\t    item.detach();\n\t\n\t    // If self has a previous item...\n\t    if (prev) {\n\t        // ...link the prependees previous item, to selfs previous item.\n\t        item.prev = prev;\n\t\n\t        // ...link the previous items next item, to self.\n\t        prev.next = item;\n\t    }\n\t\n\t    // Set the prependees next item to self.\n\t    item.next = self;\n\t\n\t    // Set the prependees parent list to selfs parent list.\n\t    item.list = list;\n\t\n\t    // Set the previous item of self to the prependee.\n\t    self.prev = item;\n\t\n\t    // If self is the first item in the parent list, link the lists first item\n\t    // to the prependee.\n\t    if (self === list.head) {\n\t        list.head = item;\n\t    }\n\t\n\t    // If the the parent list has no last item, link the lists last item to\n\t    // self.\n\t    if (!list.tail) {\n\t        list.tail = self;\n\t    }\n\t\n\t    // Return the prependee.\n\t    return item;\n\t};\n\t\n\t/**\n\t * Appends the given item *after* the item operated on.\n\t * @name ListItem#append\n\t * @param {ListItem} item - The item to append.\n\t * @returns {ListItem} - The item operated on, or false when that item is not\n\t * attached.\n\t */\n\tListItemPrototype.append = function (item) {\n\t    // If item is falsey, return false.\n\t    if (!item || !item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + 'Item#append`.');\n\t    }\n\t\n\t    // Cache self, the parent list, and the next item.\n\t    var self = this,\n\t        list = self.list,\n\t        next = self.next;\n\t\n\t    // If self is detached, return false.\n\t    if (!list) {\n\t        return false;\n\t    }\n\t\n\t    // Detach the appendee.\n\t    item.detach();\n\t\n\t    // If self has a next item...\n\t    if (next) {\n\t        // ...link the appendees next item, to selfs next item.\n\t        item.next = next;\n\t\n\t        // ...link the next items previous item, to the appendee.\n\t        next.prev = item;\n\t    }\n\t\n\t    // Set the appendees previous item to self.\n\t    item.prev = self;\n\t\n\t    // Set the appendees parent list to selfs parent list.\n\t    item.list = list;\n\t\n\t    // Set the next item of self to the appendee.\n\t    self.next = item;\n\t\n\t    // If the the parent list has no last item or if self is the parent lists\n\t    // last item, link the lists last item to the appendee.\n\t    if (self === list.tail || !list.tail) {\n\t        list.tail = item;\n\t    }\n\t\n\t    // Return the appendee.\n\t    return item;\n\t};\n\t\n\t/**\n\t * Expose `List`.\n\t */\n\t\n\tmodule.exports = List;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */\n\t;(function(root) {\n\t\n\t\t// Detect free variables `exports`.\n\t\tvar freeExports = typeof exports == 'object' && exports;\n\t\n\t\t// Detect free variable `module`.\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\tmodule.exports == freeExports && module;\n\t\n\t\t// Detect free variable `global`, from Node.js or Browserified code, and use\n\t\t// it as `root`.\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar InvalidCharacterError = function(message) {\n\t\t\tthis.message = message;\n\t\t};\n\t\tInvalidCharacterError.prototype = new Error;\n\t\tInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\t\n\t\tvar error = function(message) {\n\t\t\t// Note: the error messages used throughout this file match those used by\n\t\t\t// the native `atob`/`btoa` implementation in Chromium.\n\t\t\tthrow new InvalidCharacterError(message);\n\t\t};\n\t\n\t\tvar TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t// http://whatwg.org/html/common-microsyntaxes.html#space-character\n\t\tvar REGEX_SPACE_CHARACTERS = /[\\t\\n\\f\\r ]/g;\n\t\n\t\t// `decode` is designed to be fully compatible with `atob` as described in the\n\t\t// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob\n\t\t// The optimized base64-decoding algorithm used is based on @atks excellent\n\t\t// implementation. https://gist.github.com/atk/1020396\n\t\tvar decode = function(input) {\n\t\t\tinput = String(input)\n\t\t\t\t.replace(REGEX_SPACE_CHARACTERS, '');\n\t\t\tvar length = input.length;\n\t\t\tif (length % 4 == 0) {\n\t\t\t\tinput = input.replace(/==?$/, '');\n\t\t\t\tlength = input.length;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tlength % 4 == 1 ||\n\t\t\t\t// http://whatwg.org/C#alphanumeric-ascii-characters\n\t\t\t\t/[^+a-zA-Z0-9/]/.test(input)\n\t\t\t) {\n\t\t\t\terror(\n\t\t\t\t\t'Invalid character: the string to be decoded is not correctly encoded.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tvar bitCounter = 0;\n\t\t\tvar bitStorage;\n\t\t\tvar buffer;\n\t\t\tvar output = '';\n\t\t\tvar position = -1;\n\t\t\twhile (++position < length) {\n\t\t\t\tbuffer = TABLE.indexOf(input.charAt(position));\n\t\t\t\tbitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;\n\t\t\t\t// Unless this is the first of a group of 4 characters\n\t\t\t\tif (bitCounter++ % 4) {\n\t\t\t\t\t// convert the first 8 bits to a single ASCII character.\n\t\t\t\t\toutput += String.fromCharCode(\n\t\t\t\t\t\t0xFF & bitStorage >> (-2 * bitCounter & 6)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t};\n\t\n\t\t// `encode` is designed to be fully compatible with `btoa` as described in the\n\t\t// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa\n\t\tvar encode = function(input) {\n\t\t\tinput = String(input);\n\t\t\tif (/[^\\0-\\xFF]/.test(input)) {\n\t\t\t\t// Note: no need to special-case astral symbols here, as surrogates are\n\t\t\t\t// matched, and the input is supposed to only contain ASCII anyway.\n\t\t\t\terror(\n\t\t\t\t\t'The string to be encoded contains characters outside of the ' +\n\t\t\t\t\t'Latin1 range.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tvar padding = input.length % 3;\n\t\t\tvar output = '';\n\t\t\tvar position = -1;\n\t\t\tvar a;\n\t\t\tvar b;\n\t\t\tvar c;\n\t\t\tvar d;\n\t\t\tvar buffer;\n\t\t\t// Make sure any padding is handled outside of the loop.\n\t\t\tvar length = input.length - padding;\n\t\n\t\t\twhile (++position < length) {\n\t\t\t\t// Read three bytes, i.e. 24 bits.\n\t\t\t\ta = input.charCodeAt(position) << 16;\n\t\t\t\tb = input.charCodeAt(++position) << 8;\n\t\t\t\tc = input.charCodeAt(++position);\n\t\t\t\tbuffer = a + b + c;\n\t\t\t\t// Turn the 24 bits into four chunks of 6 bits each, and append the\n\t\t\t\t// matching character for each of them to the output.\n\t\t\t\toutput += (\n\t\t\t\t\tTABLE.charAt(buffer >> 18 & 0x3F) +\n\t\t\t\t\tTABLE.charAt(buffer >> 12 & 0x3F) +\n\t\t\t\t\tTABLE.charAt(buffer >> 6 & 0x3F) +\n\t\t\t\t\tTABLE.charAt(buffer & 0x3F)\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tif (padding == 2) {\n\t\t\t\ta = input.charCodeAt(position) << 8;\n\t\t\t\tb = input.charCodeAt(++position);\n\t\t\t\tbuffer = a + b;\n\t\t\t\toutput += (\n\t\t\t\t\tTABLE.charAt(buffer >> 10) +\n\t\t\t\t\tTABLE.charAt((buffer >> 4) & 0x3F) +\n\t\t\t\t\tTABLE.charAt((buffer << 2) & 0x3F) +\n\t\t\t\t\t'='\n\t\t\t\t);\n\t\t\t} else if (padding == 1) {\n\t\t\t\tbuffer = input.charCodeAt(position);\n\t\t\t\toutput += (\n\t\t\t\t\tTABLE.charAt(buffer >> 2) +\n\t\t\t\t\tTABLE.charAt((buffer << 4) & 0x3F) +\n\t\t\t\t\t'=='\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t};\n\t\n\t\tvar base64 = {\n\t\t\t'encode': encode,\n\t\t\t'decode': decode,\n\t\t\t'version': '0.1.0'\n\t\t};\n\t\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn base64;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = base64;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tfor (var key in base64) {\n\t\t\t\t\tbase64.hasOwnProperty(key) && (freeExports[key] = base64[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.base64 = base64;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)(module), (function() { return this; }())))\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {\n\t'use strict';\n\t\n\tfunction _instanceof(obj, type) {\n\t  return type != null && obj instanceof type;\n\t}\n\t\n\tvar nativeMap;\n\ttry {\n\t  nativeMap = Map;\n\t} catch(_) {\n\t  // maybe a reference error because no `Map`. Give it a dummy value that no\n\t  // value will ever be an instanceof.\n\t  nativeMap = function() {};\n\t}\n\t\n\tvar nativeSet;\n\ttry {\n\t  nativeSet = Set;\n\t} catch(_) {\n\t  nativeSet = function() {};\n\t}\n\t\n\tvar nativePromise;\n\ttry {\n\t  nativePromise = Promise;\n\t} catch(_) {\n\t  nativePromise = function() {};\n\t}\n\t\n\t/**\n\t * Clones (copies) an Object using deep copying.\n\t *\n\t * This function supports circular references by default, but if you are certain\n\t * there are no circular references in your object, you can save some CPU time\n\t * by calling clone(obj, false).\n\t *\n\t * Caution: if `circular` is false and `parent` contains circular references,\n\t * your program may enter an infinite loop and crash.\n\t *\n\t * @param `parent` - the object to be cloned\n\t * @param `circular` - set to true if the object to be cloned may contain\n\t *    circular references. (optional - true by default)\n\t * @param `depth` - set to a number if the object is only to be cloned to\n\t *    a particular depth. (optional - defaults to Infinity)\n\t * @param `prototype` - sets the prototype to be used when cloning an object.\n\t *    (optional - defaults to parent prototype).\n\t * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n\t *    should be cloned as well. Non-enumerable properties on the prototype\n\t *    chain will be ignored. (optional - false by default)\n\t*/\n\tfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n\t  if (typeof circular === 'object') {\n\t    depth = circular.depth;\n\t    prototype = circular.prototype;\n\t    includeNonEnumerable = circular.includeNonEnumerable;\n\t    circular = circular.circular;\n\t  }\n\t  // maintain two arrays for circular references, where corresponding parents\n\t  // and children have the same index\n\t  var allParents = [];\n\t  var allChildren = [];\n\t\n\t  var useBuffer = typeof Buffer != 'undefined';\n\t\n\t  if (typeof circular == 'undefined')\n\t    circular = true;\n\t\n\t  if (typeof depth == 'undefined')\n\t    depth = Infinity;\n\t\n\t  // recurse this function so we don't reset allParents and allChildren\n\t  function _clone(parent, depth) {\n\t    // cloning null always returns null\n\t    if (parent === null)\n\t      return null;\n\t\n\t    if (depth === 0)\n\t      return parent;\n\t\n\t    var child;\n\t    var proto;\n\t    if (typeof parent != 'object') {\n\t      return parent;\n\t    }\n\t\n\t    if (_instanceof(parent, nativeMap)) {\n\t      child = new nativeMap();\n\t    } else if (_instanceof(parent, nativeSet)) {\n\t      child = new nativeSet();\n\t    } else if (_instanceof(parent, nativePromise)) {\n\t      child = new nativePromise(function (resolve, reject) {\n\t        parent.then(function(value) {\n\t          resolve(_clone(value, depth - 1));\n\t        }, function(err) {\n\t          reject(_clone(err, depth - 1));\n\t        });\n\t      });\n\t    } else if (clone.__isArray(parent)) {\n\t      child = [];\n\t    } else if (clone.__isRegExp(parent)) {\n\t      child = new RegExp(parent.source, __getRegExpFlags(parent));\n\t      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n\t    } else if (clone.__isDate(parent)) {\n\t      child = new Date(parent.getTime());\n\t    } else if (useBuffer && Buffer.isBuffer(parent)) {\n\t      child = new Buffer(parent.length);\n\t      parent.copy(child);\n\t      return child;\n\t    } else if (_instanceof(parent, Error)) {\n\t      child = Object.create(parent);\n\t    } else {\n\t      if (typeof prototype == 'undefined') {\n\t        proto = Object.getPrototypeOf(parent);\n\t        child = Object.create(proto);\n\t      }\n\t      else {\n\t        child = Object.create(prototype);\n\t        proto = prototype;\n\t      }\n\t    }\n\t\n\t    if (circular) {\n\t      var index = allParents.indexOf(parent);\n\t\n\t      if (index != -1) {\n\t        return allChildren[index];\n\t      }\n\t      allParents.push(parent);\n\t      allChildren.push(child);\n\t    }\n\t\n\t    if (_instanceof(parent, nativeMap)) {\n\t      parent.forEach(function(value, key) {\n\t        var keyChild = _clone(key, depth - 1);\n\t        var valueChild = _clone(value, depth - 1);\n\t        child.set(keyChild, valueChild);\n\t      });\n\t    }\n\t    if (_instanceof(parent, nativeSet)) {\n\t      parent.forEach(function(value) {\n\t        var entryChild = _clone(value, depth - 1);\n\t        child.add(entryChild);\n\t      });\n\t    }\n\t\n\t    for (var i in parent) {\n\t      var attrs;\n\t      if (proto) {\n\t        attrs = Object.getOwnPropertyDescriptor(proto, i);\n\t      }\n\t\n\t      if (attrs && attrs.set == null) {\n\t        continue;\n\t      }\n\t      child[i] = _clone(parent[i], depth - 1);\n\t    }\n\t\n\t    if (Object.getOwnPropertySymbols) {\n\t      var symbols = Object.getOwnPropertySymbols(parent);\n\t      for (var i = 0; i < symbols.length; i++) {\n\t        // Don't need to worry about cloning a symbol because it is a primitive,\n\t        // like a number or string.\n\t        var symbol = symbols[i];\n\t        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n\t        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n\t          continue;\n\t        }\n\t        child[symbol] = _clone(parent[symbol], depth - 1);\n\t        if (!descriptor.enumerable) {\n\t          Object.defineProperty(child, symbol, {\n\t            enumerable: false\n\t          });\n\t        }\n\t      }\n\t    }\n\t\n\t    if (includeNonEnumerable) {\n\t      var allPropertyNames = Object.getOwnPropertyNames(parent);\n\t      for (var i = 0; i < allPropertyNames.length; i++) {\n\t        var propertyName = allPropertyNames[i];\n\t        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n\t        if (descriptor && descriptor.enumerable) {\n\t          continue;\n\t        }\n\t        child[propertyName] = _clone(parent[propertyName], depth - 1);\n\t        Object.defineProperty(child, propertyName, {\n\t          enumerable: false\n\t        });\n\t      }\n\t    }\n\t\n\t    return child;\n\t  }\n\t\n\t  return _clone(parent, depth);\n\t}\n\t\n\t/**\n\t * Simple flat clone using prototype, accepts only objects, usefull for property\n\t * override on FLAT configuration object (no nested props).\n\t *\n\t * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n\t * works.\n\t */\n\tclone.clonePrototype = function clonePrototype(parent) {\n\t  if (parent === null)\n\t    return null;\n\t\n\t  var c = function () {};\n\t  c.prototype = parent;\n\t  return new c();\n\t};\n\t\n\t// private utility functions\n\t\n\tfunction __objToStr(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\tclone.__objToStr = __objToStr;\n\t\n\tfunction __isDate(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n\t}\n\tclone.__isDate = __isDate;\n\t\n\tfunction __isArray(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n\t}\n\tclone.__isArray = __isArray;\n\t\n\tfunction __isRegExp(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n\t}\n\tclone.__isRegExp = __isRegExp;\n\t\n\tfunction __getRegExpFlags(re) {\n\t  var flags = '';\n\t  if (re.global) flags += 'g';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.multiline) flags += 'm';\n\t  return flags;\n\t}\n\tclone.__getRegExpFlags = __getRegExpFlags;\n\t\n\treturn clone;\n\t})();\n\t\n\tif (typeof module === 'object' && module.exports) {\n\t  module.exports = clone;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var SCSocket = __webpack_require__(2);\n\tvar scErrors = __webpack_require__(10);\n\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\t\n\tvar _connections = {};\n\t\n\tfunction getMultiplexId(options) {\n\t  var protocolPrefix = options.secure ? 'https://' : 'http://';\n\t  var queryString = '';\n\t  if (options.query) {\n\t    if (typeof options.query == 'string') {\n\t      queryString = options.query;\n\t    } else {\n\t      var queryArray = [];\n\t      var queryMap = options.query;\n\t      for (var key in queryMap) {\n\t        if (queryMap.hasOwnProperty(key)) {\n\t          queryArray.push(key + '=' + queryMap[key]);\n\t        }\n\t      }\n\t      if (queryArray.length) {\n\t        queryString = '?' + queryArray.join('&');\n\t      }\n\t    }\n\t  }\n\t  var host;\n\t  if (options.host) {\n\t    host = options.host;\n\t  } else {\n\t    host = options.hostname + ':' + options.port;\n\t  }\n\t  return protocolPrefix + host + options.path + queryString;\n\t}\n\t\n\tfunction isUrlSecure() {\n\t  return global.location && location.protocol == 'https:';\n\t}\n\t\n\tfunction getPort(options, isSecureDefault) {\n\t  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n\t  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n\t}\n\t\n\tfunction connect(options) {\n\t  var self = this;\n\t\n\t  options = options || {};\n\t\n\t  if (options.host && options.port) {\n\t    throw new InvalidArgumentsError('The host option should already include the' +\n\t      ' port number in the format hostname:port - Because of this, the host and port options' +\n\t      ' cannot be specified together; use the hostname option instead');\n\t  }\n\t\n\t  var isSecureDefault = isUrlSecure();\n\t\n\t  var opts = {\n\t    port: getPort(options, isSecureDefault),\n\t    hostname: global.location && location.hostname,\n\t    path: '/socketcluster/',\n\t    secure: isSecureDefault,\n\t    autoConnect: true,\n\t    autoReconnect: true,\n\t    autoSubscribeOnConnect: true,\n\t    connectTimeout: 20000,\n\t    ackTimeout: 10000,\n\t    timestampRequests: false,\n\t    timestampParam: 't',\n\t    authEngine: null,\n\t    authTokenName: 'socketCluster.authToken',\n\t    binaryType: 'arraybuffer',\n\t    multiplex: true,\n\t    pubSubBatchDuration: null,\n\t    cloneData: false\n\t  };\n\t  for (var i in options) {\n\t    if (options.hasOwnProperty(i)) {\n\t      opts[i] = options[i];\n\t    }\n\t  }\n\t  var multiplexId = getMultiplexId(opts);\n\t  if (opts.multiplex === false) {\n\t    return new SCSocket(opts);\n\t  }\n\t  if (_connections[multiplexId]) {\n\t    _connections[multiplexId].connect();\n\t  } else {\n\t    _connections[multiplexId] = new SCSocket(opts);\n\t  }\n\t  return _connections[multiplexId];\n\t}\n\t\n\tfunction destroy(options) {\n\t  var self = this;\n\t\n\t  options = options || {};\n\t  var isSecureDefault = isUrlSecure();\n\t\n\t  var opts = {\n\t    port: getPort(options, isSecureDefault),\n\t    hostname: global.location && location.hostname,\n\t    path: '/socketcluster/',\n\t    secure: isSecureDefault\n\t  };\n\t  for (var i in options) {\n\t    if (options.hasOwnProperty(i)) {\n\t      opts[i] = options[i];\n\t    }\n\t  }\n\t  var multiplexId = getMultiplexId(opts);\n\t  var socket = _connections[multiplexId];\n\t  if (socket) {\n\t    socket.destroy();\n\t  }\n\t  delete _connections[multiplexId];\n\t}\n\t\n\tmodule.exports = {\n\t  connect: connect,\n\t  destroy: destroy,\n\t  connections: _connections\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// neolab-socket-client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3819740d35250a8bc260","'use strict';\n\nimport 'socketcluster-client';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","var SCSocket = require('./lib/scsocket');\nvar SCSocketCreator = require('./lib/scsocketcreator');\n\nmodule.exports.SCSocketCreator = SCSocketCreator;\nmodule.exports.SCSocket = SCSocket;\n\nmodule.exports.Emitter = require('component-emitter');\n\nmodule.exports.connect = function (options) {\n  return SCSocketCreator.connect(options);\n};\n\nmodule.exports.destroy = function (options) {\n  return SCSocketCreator.destroy(options);\n};\n\nmodule.exports.connections = SCSocketCreator.connections;\n\nmodule.exports.version = '8.0.1';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/index.js\n// module id = 1\n// module chunks = 0 1","var Emitter = require('component-emitter');\nvar SCChannel = require('sc-channel').SCChannel;\nvar Response = require('./response').Response;\nvar AuthEngine = require('./auth').AuthEngine;\nvar formatter = require('sc-formatter');\nvar SCTransport = require('./sctransport').SCTransport;\nvar querystring = require('querystring');\nvar LinkedList = require('linked-list');\nvar base64 = require('base-64');\nvar clone = require('clone');\n\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar InvalidMessageError = scErrors.InvalidMessageError;\nvar SocketProtocolError = scErrors.SocketProtocolError;\nvar TimeoutError = scErrors.TimeoutError;\nvar BadConnectionError = scErrors.BadConnectionError;\n\nvar isBrowser = typeof window != 'undefined';\n\n\nvar SCSocket = function (opts) {\n  var self = this;\n\n  Emitter.call(this);\n\n  this.id = null;\n  this.state = this.CLOSED;\n  this.authState = this.UNAUTHENTICATED;\n  this.signedAuthToken = null;\n  this.authToken = null;\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  this.preparingPendingSubscriptions = false;\n\n  this.connectTimeout = opts.connectTimeout;\n  this.ackTimeout = opts.ackTimeout;\n  this.channelPrefix = opts.channelPrefix || null;\n  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\n  this.authTokenName = opts.authTokenName;\n\n  // pingTimeout will be ackTimeout at the start, but it will\n  // be updated with values provided by the 'connect' event\n  this.pingTimeout = this.ackTimeout;\n\n  var maxTimeout = Math.pow(2, 31) - 1;\n\n  var verifyDuration = function (propertyName) {\n    if (self[propertyName] > maxTimeout) {\n      throw new InvalidArgumentsError('The ' + propertyName +\n        ' value provided exceeded the maximum amount allowed');\n    }\n  };\n\n  verifyDuration('connectTimeout');\n  verifyDuration('ackTimeout');\n  verifyDuration('pingTimeout');\n\n  this._localEvents = {\n    'connect': 1,\n    'connectAbort': 1,\n    'disconnect': 1,\n    'message': 1,\n    'error': 1,\n    'raw': 1,\n    'fail': 1,\n    'kickOut': 1,\n    'subscribe': 1,\n    'unsubscribe': 1,\n    'subscribeStateChange': 1,\n    'authStateChange': 1,\n    'authenticate': 1,\n    'deauthenticate': 1,\n    'removeAuthToken': 1,\n    'subscribeRequest': 1\n  };\n\n  this.connectAttempts = 0;\n\n  this._emitBuffer = new LinkedList();\n  this.channels = {};\n\n  this.options = opts;\n\n  this._cid = 1;\n\n  this.options.callIdGenerator = function () {\n    return self._cid++;\n  };\n\n  if (this.options.autoReconnect) {\n    if (this.options.autoReconnectOptions == null) {\n      this.options.autoReconnectOptions = {};\n    }\n\n    // Add properties to the this.options.autoReconnectOptions object.\n    // We assign the reference to a reconnectOptions variable to avoid repetition.\n    var reconnectOptions = this.options.autoReconnectOptions;\n    if (reconnectOptions.initialDelay == null) {\n      reconnectOptions.initialDelay = 10000;\n    }\n    if (reconnectOptions.randomness == null) {\n      reconnectOptions.randomness = 10000;\n    }\n    if (reconnectOptions.multiplier == null) {\n      reconnectOptions.multiplier = 1.5;\n    }\n    if (reconnectOptions.maxDelay == null) {\n      reconnectOptions.maxDelay = 60000;\n    }\n  }\n\n  if (this.options.subscriptionRetryOptions == null) {\n    this.options.subscriptionRetryOptions = {};\n  }\n\n  if (this.options.authEngine) {\n    this.auth = this.options.authEngine;\n  } else {\n    this.auth = new AuthEngine();\n  }\n\n  if (this.options.codecEngine) {\n    this.codec = this.options.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n\n  this.options.path = this.options.path.replace(/\\/$/, '') + '/';\n\n  this.options.query = opts.query || {};\n  if (typeof this.options.query == 'string') {\n    this.options.query = querystring.parse(this.options.query);\n  }\n\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n\n  this._channelEmitter = new Emitter();\n\n  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\n    this._unloadHandler = function () {\n      self.disconnect();\n    };\n\n    global.addEventListener('beforeunload', this._unloadHandler, false);\n  }\n};\n\nSCSocket.prototype = Object.create(Emitter.prototype);\n\nSCSocket.CONNECTING = SCSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\nSCSocket.OPEN = SCSocket.prototype.OPEN = SCTransport.prototype.OPEN;\nSCSocket.CLOSED = SCSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\n\nSCSocket.AUTHENTICATED = SCSocket.prototype.AUTHENTICATED = 'authenticated';\nSCSocket.UNAUTHENTICATED = SCSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\n\nSCSocket.PENDING = SCSocket.prototype.PENDING = 'pending';\n\nSCSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\nSCSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\n\nSCSocket.prototype._privateEventHandlerMap = {\n  '#publish': function (data) {\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n\n    if (isSubscribed) {\n      this._channelEmitter.emit(undecoratedChannelName, data.data);\n    }\n  },\n  '#kickOut': function (data) {\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n    var channel = this.channels[undecoratedChannelName];\n    if (channel) {\n      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\n      channel.emit('kickOut', data.message, undecoratedChannelName);\n      this._triggerChannelUnsubscribe(channel);\n    }\n  },\n  '#setAuthToken': function (data, response) {\n    var self = this;\n\n    if (data) {\n      var triggerAuthenticate = function (err) {\n        if (err) {\n          // This is a non-fatal error, we don't want to close the connection\n          // because of this but we do want to notify the server and throw an error\n          // on the client.\n          response.error(err);\n          self._onSCError(err);\n        } else {\n          self._changeToAuthenticatedState(data.token);\n          response.end();\n        }\n      };\n\n      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\n    } else {\n      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\n    }\n  },\n  '#removeAuthToken': function (data, response) {\n    var self = this;\n\n    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n      if (err) {\n        // Non-fatal error - Do not close the connection\n        response.error(err);\n        self._onSCError(err);\n      } else {\n        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n        self._changeToUnauthenticatedStateAndClearTokens();\n        response.end();\n      }\n    });\n  },\n  '#disconnect': function (data) {\n    this.transport.close(data.code, data.data);\n  }\n};\n\nSCSocket.prototype.getState = function () {\n  return this.state;\n};\n\nSCSocket.prototype.getBytesReceived = function () {\n  return this.transport.getBytesReceived();\n};\n\nSCSocket.prototype.deauthenticate = function (callback) {\n  var self = this;\n\n  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n    if (err) {\n      // Non-fatal error - Do not close the connection\n      self._onSCError(err);\n    } else {\n      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n      if (self.state != self.CLOSED) {\n        self.emit('#removeAuthToken');\n      }\n      self._changeToUnauthenticatedStateAndClearTokens();\n    }\n    callback && callback(err);\n  });\n};\n\nSCSocket.prototype.connect = SCSocket.prototype.open = function () {\n  var self = this;\n\n  if (this.state == this.CLOSED) {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n\n    this.state = this.CONNECTING;\n    Emitter.prototype.emit.call(this, 'connecting');\n\n    if (this.transport) {\n      this.transport.off();\n    }\n\n    this.transport = new SCTransport(this.auth, this.codec, this.options);\n\n    this.transport.on('open', function (status) {\n      self.state = self.OPEN;\n      self._onSCOpen(status);\n    });\n\n    this.transport.on('error', function (err) {\n      self._onSCError(err);\n    });\n\n    this.transport.on('close', function (code, data) {\n      self.state = self.CLOSED;\n      self._onSCClose(code, data);\n    });\n\n    this.transport.on('openAbort', function (code, data) {\n      self.state = self.CLOSED;\n      self._onSCClose(code, data, true);\n    });\n\n    this.transport.on('event', function (event, data, res) {\n      self._onSCEvent(event, data, res);\n    });\n  }\n};\n\nSCSocket.prototype.reconnect = function () {\n  this.disconnect();\n  this.connect();\n};\n\nSCSocket.prototype.disconnect = function (code, data) {\n  code = code || 1000;\n\n  if (typeof code != 'number') {\n    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n  }\n\n  if (this.state == this.OPEN || this.state == this.CONNECTING) {\n    this.transport.close(code, data);\n  } else {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n  }\n};\n\nSCSocket.prototype.destroy = function () {\n  if (this._unloadHandler) {\n    global.removeEventListener('beforeunload', this._unloadHandler, false);\n  }\n  this.disconnect();\n};\n\nSCSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n  if (this.authState != this.UNAUTHENTICATED) {\n    var oldState = this.authState;\n    this.authState = this.UNAUTHENTICATED;\n    this.signedAuthToken = null;\n    this.authToken = null;\n\n    var stateChangeData = {\n      oldState: oldState,\n      newState: this.authState\n    };\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n    if (oldState == this.AUTHENTICATED) {\n      Emitter.prototype.emit.call(this, 'deauthenticate');\n    }\n    Emitter.prototype.emit.call(this, 'authTokenChange', this.signedAuthToken);\n  }\n};\n\nSCSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n  this.signedAuthToken = signedAuthToken;\n  this.authToken = this._extractAuthTokenData(signedAuthToken);\n\n  if (this.authState != this.AUTHENTICATED) {\n    var oldState = this.authState;\n    this.authState = this.AUTHENTICATED;\n    var stateChangeData = {\n      oldState: oldState,\n      newState: this.authState,\n      signedAuthToken: signedAuthToken,\n      authToken: this.authToken\n    };\n    if (!this.preparingPendingSubscriptions) {\n      this.processPendingSubscriptions();\n    }\n\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\n  }\n  Emitter.prototype.emit.call(this, 'authTokenChange', signedAuthToken);\n};\n\nSCSocket.prototype.decodeBase64 = function (encodedString) {\n  var decodedString;\n  if (typeof Buffer == 'undefined') {\n    if (global.atob) {\n      decodedString = global.atob(encodedString);\n    } else {\n      decodedString = base64.decode(encodedString);\n    }\n  } else {\n    var buffer = new Buffer(encodedString, 'base64');\n    decodedString = buffer.toString('utf8');\n  }\n  return decodedString;\n};\n\nSCSocket.prototype.encodeBase64 = function (decodedString) {\n  var encodedString;\n  if (typeof Buffer == 'undefined') {\n    if (global.btoa) {\n      encodedString = global.btoa(decodedString);\n    } else {\n      encodedString = base64.encode(decodedString);\n    }\n  } else {\n    var buffer = new Buffer(decodedString, 'utf8');\n    encodedString = buffer.toString('base64');\n  }\n  return encodedString;\n};\n\nSCSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n  var tokenParts = (signedAuthToken || '').split('.');\n  var encodedTokenData = tokenParts[1];\n  if (encodedTokenData != null) {\n    var tokenData = encodedTokenData;\n    try {\n      tokenData = this.decodeBase64(tokenData);\n      return JSON.parse(tokenData);\n    } catch (e) {\n      return tokenData;\n    }\n  }\n  return null;\n};\n\nSCSocket.prototype.getAuthToken = function () {\n  return this.authToken;\n};\n\nSCSocket.prototype.getSignedAuthToken = function () {\n  return this.signedAuthToken;\n};\n\n// Perform client-initiated authentication by providing an encrypted token string.\nSCSocket.prototype.authenticate = function (signedAuthToken, callback) {\n  var self = this;\n\n  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\n\n    if (authStatus && authStatus.isAuthenticated != null) {\n      // If authStatus is correctly formatted (has an isAuthenticated property),\n      // then we will rehydrate the authError.\n      if (authStatus.authError) {\n        authStatus.authError = scErrors.hydrateError(authStatus.authError);\n      }\n    } else {\n      // Some errors like BadConnectionError and TimeoutError will not pass a valid\n      // authStatus object to the current function, so we need to create it ourselves.\n      authStatus = {\n        isAuthenticated: self.authState,\n        authError: null\n      };\n    }\n    if (err) {\n      if (err.name != 'BadConnectionError' && err.name != 'TimeoutError') {\n        // In case of a bad/closed connection or a timeout, we maintain the last\n        // known auth state since those errors don't mean that the token is invalid.\n\n        self._changeToUnauthenticatedStateAndClearTokens();\n      }\n      callback && callback(err, authStatus);\n    } else {\n      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\n        if (err) {\n          self._onSCError(err);\n        }\n        if (authStatus.isAuthenticated) {\n          self._changeToAuthenticatedState(signedAuthToken);\n        } else {\n          self._changeToUnauthenticatedStateAndClearTokens();\n        }\n        callback && callback(err, authStatus);\n      });\n    }\n  });\n};\n\nSCSocket.prototype._tryReconnect = function (initialDelay) {\n  var self = this;\n\n  var exponent = this.connectAttempts++;\n  var reconnectOptions = this.options.autoReconnectOptions;\n  var timeout;\n\n  if (initialDelay == null || exponent > 0) {\n    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n\n    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n  } else {\n    timeout = initialDelay;\n  }\n\n  if (timeout > reconnectOptions.maxDelay) {\n    timeout = reconnectOptions.maxDelay;\n  }\n\n  clearTimeout(this._reconnectTimeoutRef);\n\n  this.pendingReconnect = true;\n  this.pendingReconnectTimeout = timeout;\n  this._reconnectTimeoutRef = setTimeout(function () {\n    self.connect();\n  }, timeout);\n};\n\nSCSocket.prototype._onSCOpen = function (status) {\n  var self = this;\n\n  this.preparingPendingSubscriptions = true;\n\n  if (status) {\n    this.id = status.id;\n    this.pingTimeout = status.pingTimeout;\n    this.transport.pingTimeout = this.pingTimeout;\n    if (status.isAuthenticated) {\n      this._changeToAuthenticatedState(status.authToken);\n    } else {\n      this._changeToUnauthenticatedStateAndClearTokens();\n    }\n  } else {\n    // This can happen if auth.loadToken (in sctransport.js) fails with\n    // an error - This means that the signedAuthToken cannot be loaded by\n    // the auth engine and therefore, we need to unauthenticate the socket.\n    this._changeToUnauthenticatedStateAndClearTokens();\n  }\n\n  this.connectAttempts = 0;\n\n  if (this.options.autoSubscribeOnConnect) {\n    this.processPendingSubscriptions();\n  }\n\n  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n  // won't break anything.\n  Emitter.prototype.emit.call(this, 'connect', status, function () {\n    self.processPendingSubscriptions();\n  });\n\n  this._flushEmitBuffer();\n};\n\nSCSocket.prototype._onSCError = function (err) {\n  var self = this;\n\n  // Throw error in different stack frame so that error handling\n  // cannot interfere with a reconnect action.\n  setTimeout(function () {\n    if (self.listeners('error').length < 1) {\n      throw err;\n    } else {\n      Emitter.prototype.emit.call(self, 'error', err);\n    }\n  }, 0);\n};\n\nSCSocket.prototype._suspendSubscriptions = function () {\n  var channel, newState;\n  for (var channelName in this.channels) {\n    if (this.channels.hasOwnProperty(channelName)) {\n      channel = this.channels[channelName];\n      if (channel.state == channel.SUBSCRIBED ||\n        channel.state == channel.PENDING) {\n\n        newState = channel.PENDING;\n      } else {\n        newState = channel.UNSUBSCRIBED;\n      }\n\n      this._triggerChannelUnsubscribe(channel, newState);\n    }\n  }\n};\n\nSCSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n  var currentNode = this._emitBuffer.head;\n  var nextNode;\n\n  while (currentNode) {\n    nextNode = currentNode.next;\n    var eventObject = currentNode.data;\n    clearTimeout(eventObject.timeout);\n    delete eventObject.timeout;\n    currentNode.detach();\n    currentNode = nextNode;\n\n    var callback = eventObject.callback;\n    if (callback) {\n      delete eventObject.callback;\n      var errorMessage = \"Event '\" + eventObject.event +\n        \"' was aborted due to a bad connection\";\n      var error = new BadConnectionError(errorMessage, failureType);\n      callback.call(eventObject, error, eventObject);\n    }\n  }\n};\n\nSCSocket.prototype._onSCClose = function (code, data, openAbort) {\n  var self = this;\n\n  this.id = null;\n\n  if (this.transport) {\n    this.transport.off();\n  }\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  clearTimeout(this._reconnectTimeoutRef);\n\n  this._suspendSubscriptions();\n  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\n  // Try to reconnect\n  // on server ping timeout (4000)\n  // or on client pong timeout (4001)\n  // or on close without status (1005)\n  // or on handshake failure (4003)\n  // or on socket hung up (1006)\n  if (this.options.autoReconnect) {\n    if (code == 4000 || code == 4001 || code == 1005) {\n      // If there is a ping or pong timeout or socket closes without\n      // status, don't wait before trying to reconnect - These could happen\n      // if the client wakes up after a period of inactivity and in this case we\n      // want to re-establish the connection as soon as possible.\n      this._tryReconnect(0);\n\n      // Codes 4500 and above will be treated as permanent disconnects.\n      // Socket will not try to auto-reconnect.\n    } else if (code != 1000 && code < 4500) {\n      this._tryReconnect();\n    }\n  }\n\n  if (openAbort) {\n    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\n  } else {\n    Emitter.prototype.emit.call(self, 'disconnect', code, data);\n  }\n\n  if (!SCSocket.ignoreStatuses[code]) {\n    var failureMessage;\n    if (data) {\n      failureMessage = 'Socket connection failed: ' + data;\n    } else {\n      failureMessage = 'Socket connection failed for unknown reasons';\n    }\n    var err = new SocketProtocolError(SCSocket.errorStatuses[code] || failureMessage, code);\n    this._onSCError(err);\n  }\n};\n\nSCSocket.prototype._onSCEvent = function (event, data, res) {\n  var handler = this._privateEventHandlerMap[event];\n  if (handler) {\n    handler.call(this, data, res);\n  } else {\n    Emitter.prototype.emit.call(this, event, data, function () {\n      res && res.callback.apply(res, arguments);\n    });\n  }\n};\n\nSCSocket.prototype.decode = function (message) {\n  return this.transport.decode(message);\n};\n\nSCSocket.prototype.encode = function (object) {\n  return this.transport.encode(object);\n};\n\nSCSocket.prototype._flushEmitBuffer = function () {\n  var currentNode = this._emitBuffer.head;\n  var nextNode;\n\n  while (currentNode) {\n    nextNode = currentNode.next;\n    var eventObject = currentNode.data;\n    currentNode.detach();\n    this.transport.emitObject(eventObject);\n    currentNode = nextNode;\n  }\n};\n\nSCSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n  if (eventNode) {\n    eventNode.detach();\n  }\n  delete eventObject.timeout;\n\n  var callback = eventObject.callback;\n  if (callback) {\n    delete eventObject.callback;\n    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n    callback.call(eventObject, error, eventObject);\n  }\n};\n\nSCSocket.prototype._emit = function (event, data, callback) {\n  var self = this;\n\n  if (this.state == this.CLOSED) {\n    this.connect();\n  }\n  var eventObject = {\n    event: event,\n    callback: callback\n  };\n\n  var eventNode = new LinkedList.Item();\n\n  if (this.options.cloneData) {\n    eventObject.data = clone(data);\n  } else {\n    eventObject.data = data;\n  }\n  eventNode.data = eventObject;\n\n  eventObject.timeout = setTimeout(function () {\n    self._handleEventAckTimeout(eventObject, eventNode);\n  }, this.ackTimeout);\n\n  this._emitBuffer.append(eventNode);\n\n  if (this.state == this.OPEN) {\n    this._flushEmitBuffer();\n  }\n};\n\nSCSocket.prototype.send = function (data) {\n  this.transport.send(data);\n};\n\nSCSocket.prototype.emit = function (event, data, callback) {\n  if (this._localEvents[event] == null) {\n    this._emit(event, data, callback);\n  } else {\n    Emitter.prototype.emit.call(this, event, data);\n  }\n};\n\nSCSocket.prototype.publish = function (channelName, data, callback) {\n  var pubData = {\n    channel: this._decorateChannelName(channelName),\n    data: data\n  };\n  this.emit('#publish', pubData, callback);\n};\n\nSCSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n  var channelName = channel.name;\n\n  if (channel.state != channel.SUBSCRIBED) {\n    var oldState = channel.state;\n    channel.state = channel.SUBSCRIBED;\n\n    var stateChangeData = {\n      channel: channelName,\n      oldState: oldState,\n      newState: channel.state,\n      subscriptionOptions: subscriptionOptions\n    };\n    channel.emit('subscribeStateChange', stateChangeData);\n    channel.emit('subscribe', channelName, subscriptionOptions);\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\n  }\n};\n\nSCSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n  var channelName = channel.name;\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\n  if (channel.state != channel.UNSUBSCRIBED && meetsAuthRequirements) {\n    channel.state = channel.UNSUBSCRIBED;\n\n    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\n    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\n  }\n};\n\n// Cancel any pending subscribe callback\nSCSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n  if (channel._pendingSubscriptionCid != null) {\n    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n    delete channel._pendingSubscriptionCid;\n  }\n};\n\nSCSocket.prototype._decorateChannelName = function (channelName) {\n  if (this.channelPrefix) {\n    channelName = this.channelPrefix + channelName;\n  }\n  return channelName;\n};\n\nSCSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) == 0) {\n    return decoratedChannelName.replace(this.channelPrefix, '');\n  }\n  return decoratedChannelName;\n};\n\nSCSocket.prototype._trySubscribe = function (channel) {\n  var self = this;\n\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\n  // We can only ever have one pending subscribe action at any given time on a channel\n  if (this.state == this.OPEN && !this.preparingPendingSubscriptions &&\n    channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n\n    var options = {\n      noTimeout: true\n    };\n\n    var subscriptionOptions = {\n      channel: this._decorateChannelName(channel.name)\n    };\n    if (channel.waitForAuth) {\n      options.waitForAuth = true;\n      subscriptionOptions.waitForAuth = options.waitForAuth;\n    }\n    if (channel.data) {\n      subscriptionOptions.data = channel.data;\n    }\n    if (channel.batch) {\n      options.batch = true;\n      subscriptionOptions.batch = true;\n    }\n\n    channel._pendingSubscriptionCid = this.transport.emit(\n      '#subscribe', subscriptionOptions, options,\n      function (err) {\n        delete channel._pendingSubscriptionCid;\n        if (err) {\n          self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n        } else {\n          self._triggerChannelSubscribe(channel, subscriptionOptions);\n        }\n      }\n    );\n    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\n  }\n};\n\nSCSocket.prototype.subscribe = function (channelName, options) {\n  var channel = this.channels[channelName];\n\n  if (!channel) {\n    channel = new SCChannel(channelName, this, options);\n    this.channels[channelName] = channel;\n  } else if (options) {\n    channel.setOptions(options);\n  }\n\n  if (channel.state == channel.UNSUBSCRIBED) {\n    channel.state = channel.PENDING;\n    this._trySubscribe(channel);\n  }\n\n  return channel;\n};\n\nSCSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\n  var channelName = channel.name;\n  var oldState = channel.state;\n\n  if (newState) {\n    channel.state = newState;\n  } else {\n    channel.state = channel.UNSUBSCRIBED;\n  }\n  this._cancelPendingSubscribeCallback(channel);\n\n  if (oldState == channel.SUBSCRIBED) {\n    var stateChangeData = {\n      channel: channelName,\n      oldState: oldState,\n      newState: channel.state\n    };\n    channel.emit('subscribeStateChange', stateChangeData);\n    channel.emit('unsubscribe', channelName);\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\n  }\n};\n\nSCSocket.prototype._tryUnsubscribe = function (channel) {\n  var self = this;\n\n  if (this.state == this.OPEN) {\n    var options = {\n      noTimeout: true\n    };\n    if (channel.batch) {\n      options.batch = true;\n    }\n    // If there is a pending subscribe action, cancel the callback\n    this._cancelPendingSubscribeCallback(channel);\n\n    // This operation cannot fail because the TCP protocol guarantees delivery\n    // so long as the connection remains open. If the connection closes,\n    // the server will automatically unsubscribe the socket and thus complete\n    // the operation on the server side.\n    var decoratedChannelName = this._decorateChannelName(channel.name);\n    this.transport.emit('#unsubscribe', decoratedChannelName, options);\n  }\n};\n\nSCSocket.prototype.unsubscribe = function (channelName) {\n\n  var channel = this.channels[channelName];\n\n  if (channel) {\n    if (channel.state != channel.UNSUBSCRIBED) {\n\n      this._triggerChannelUnsubscribe(channel);\n      this._tryUnsubscribe(channel);\n    }\n  }\n};\n\nSCSocket.prototype.channel = function (channelName, options) {\n  var currentChannel = this.channels[channelName];\n\n  if (!currentChannel) {\n    currentChannel = new SCChannel(channelName, this, options);\n    this.channels[channelName] = currentChannel;\n  }\n  return currentChannel;\n};\n\nSCSocket.prototype.destroyChannel = function (channelName) {\n  var channel = this.channels[channelName];\n  channel.unwatch();\n  channel.unsubscribe();\n  delete this.channels[channelName];\n};\n\nSCSocket.prototype.subscriptions = function (includePending) {\n  var subs = [];\n  var channel, includeChannel;\n  for (var channelName in this.channels) {\n    if (this.channels.hasOwnProperty(channelName)) {\n      channel = this.channels[channelName];\n\n      if (includePending) {\n        includeChannel = channel && (channel.state == channel.SUBSCRIBED ||\n          channel.state == channel.PENDING);\n      } else {\n        includeChannel = channel && channel.state == channel.SUBSCRIBED;\n      }\n\n      if (includeChannel) {\n        subs.push(channelName);\n      }\n    }\n  }\n  return subs;\n};\n\nSCSocket.prototype.isSubscribed = function (channelName, includePending) {\n  var channel = this.channels[channelName];\n  if (includePending) {\n    return !!channel && (channel.state == channel.SUBSCRIBED ||\n      channel.state == channel.PENDING);\n  }\n  return !!channel && channel.state == channel.SUBSCRIBED;\n};\n\nSCSocket.prototype.processPendingSubscriptions = function () {\n  var self = this;\n\n  this.preparingPendingSubscriptions = false;\n\n  var pendingChannels = [];\n\n  for (var i in this.channels) {\n    if (this.channels.hasOwnProperty(i)) {\n      var channel = this.channels[i];\n      if (channel.state == channel.PENDING) {\n        pendingChannels.push(channel);\n      }\n    }\n  }\n\n  pendingChannels.sort(function (a, b) {\n    var ap = a.priority || 0;\n    var bp = b.priority || 0;\n    if (ap > bp) {\n      return -1;\n    }\n    if (ap < bp) {\n      return 1;\n    }\n    return 0;\n  });\n\n  pendingChannels.forEach(function (channel) {\n    self._trySubscribe(channel);\n  });\n};\n\nSCSocket.prototype.watch = function (channelName, handler) {\n  if (typeof handler != 'function') {\n    throw new InvalidArgumentsError('No handler function was provided');\n  }\n  this._channelEmitter.on(channelName, handler);\n};\n\nSCSocket.prototype.unwatch = function (channelName, handler) {\n  if (handler) {\n    this._channelEmitter.removeListener(channelName, handler);\n  } else {\n    this._channelEmitter.removeAllListeners(channelName);\n  }\n};\n\nSCSocket.prototype.watchers = function (channelName) {\n  return this._channelEmitter.listeners(channelName);\n};\n\nmodule.exports = SCSocket;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/scsocket.js\n// module id = 2\n// module chunks = 0 1","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 3\n// module chunks = 0 1","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 4\n// module chunks = 0 1","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 5\n// module chunks = 0 1","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 6\n// module chunks = 0 1","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/component-emitter/index.js\n// module id = 7\n// module chunks = 0 1","var Emitter = require('component-emitter');\n\nvar SCChannel = function (name, client, options) {\n  var self = this;\n\n  Emitter.call(this);\n\n  this.PENDING = 'pending';\n  this.SUBSCRIBED = 'subscribed';\n  this.UNSUBSCRIBED = 'unsubscribed';\n\n  this.name = name;\n  this.state = this.UNSUBSCRIBED;\n  this.client = client;\n\n  this.options = options || {};\n  this.setOptions(this.options);\n};\n\nSCChannel.prototype = Object.create(Emitter.prototype);\n\nSCChannel.prototype.setOptions = function (options) {\n  if (!options) {\n    options = {};\n  }\n  this.waitForAuth = options.waitForAuth || false;\n  this.batch = options.batch || false;\n\n  if (options.data !== undefined) {\n    this.data = options.data;\n  }\n};\n\nSCChannel.prototype.getState = function () {\n  return this.state;\n};\n\nSCChannel.prototype.subscribe = function (options) {\n  this.client.subscribe(this.name, options);\n};\n\nSCChannel.prototype.unsubscribe = function () {\n  this.client.unsubscribe(this.name);\n};\n\nSCChannel.prototype.isSubscribed = function (includePending) {\n  return this.client.isSubscribed(this.name, includePending);\n};\n\nSCChannel.prototype.publish = function (data, callback) {\n  this.client.publish(this.name, data, callback);\n};\n\nSCChannel.prototype.watch = function (handler) {\n  this.client.watch(this.name, handler);\n};\n\nSCChannel.prototype.unwatch = function (handler) {\n  this.client.unwatch(this.name, handler);\n};\n\nSCChannel.prototype.watchers = function () {\n  return this.client.watchers(this.name);\n};\n\nSCChannel.prototype.destroy = function () {\n  this.client.destroyChannel(this.name);\n};\n\nmodule.exports.SCChannel = SCChannel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sc-channel/index.js\n// module id = 8\n// module chunks = 0 1","var scErrors = require('sc-errors');\nvar InvalidActionError = scErrors.InvalidActionError;\n\nvar Response = function (socket, id) {\n  this.socket = socket;\n  this.id = id;\n  this.sent = false;\n};\n\nResponse.prototype._respond = function (responseData) {\n  if (this.sent) {\n    throw new InvalidActionError('Response ' + this.id + ' has already been sent');\n  } else {\n    this.sent = true;\n    this.socket.send(this.socket.encode(responseData));\n  }\n};\n\nResponse.prototype.end = function (data) {\n  if (this.id) {\n    var responseData = {\n      rid: this.id\n    };\n    if (data !== undefined) {\n      responseData.data = data;\n    }\n    this._respond(responseData);\n  }\n};\n\nResponse.prototype.error = function (error, data) {\n  if (this.id) {\n    var err = scErrors.dehydrateError(error);\n\n    var responseData = {\n      rid: this.id,\n      error: err\n    };\n    if (data !== undefined) {\n      responseData.data = data;\n    }\n\n    this._respond(responseData);\n  }\n};\n\nResponse.prototype.callback = function (error, data) {\n  if (error) {\n    this.error(error, data);\n  } else {\n    this.end(data);\n  }\n};\n\nmodule.exports.Response = Response;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/response.js\n// module id = 9\n// module chunks = 0 1","var decycle = require('./decycle');\r\n\r\nvar isStrict = (function () { return !this; })();\r\n\r\nfunction AuthTokenExpiredError(message, expiry) {\r\n  this.name = 'AuthTokenExpiredError';\r\n  this.message = message;\r\n  this.expiry = expiry;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenExpiredError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction AuthTokenInvalidError(message) {\r\n  this.name = 'AuthTokenInvalidError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenInvalidError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction AuthTokenNotBeforeError(message, date) {\r\n  this.name = 'AuthTokenNotBeforeError';\r\n  this.message = message;\r\n  this.date = date;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\r\n\r\n\r\n// For any other auth token error.\r\nfunction AuthTokenError(message) {\r\n  this.name = 'AuthTokenError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction SilentMiddlewareBlockedError(message, type) {\r\n  this.name = 'SilentMiddlewareBlockedError';\r\n  this.message = message;\r\n  this.type = type;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction InvalidActionError(message) {\r\n  this.name = 'InvalidActionError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidActionError.prototype = Object.create(Error.prototype);\r\n\r\nfunction InvalidArgumentsError(message) {\r\n  this.name = 'InvalidArgumentsError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidArgumentsError.prototype = Object.create(Error.prototype);\r\n\r\nfunction InvalidOptionsError(message) {\r\n  this.name = 'InvalidOptionsError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidOptionsError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction InvalidMessageError(message) {\r\n  this.name = 'InvalidMessageError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidMessageError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction SocketProtocolError(message, code) {\r\n  this.name = 'SocketProtocolError';\r\n  this.message = message;\r\n  this.code = code;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nSocketProtocolError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction ServerProtocolError(message) {\r\n  this.name = 'ServerProtocolError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nServerProtocolError.prototype = Object.create(Error.prototype);\r\n\r\nfunction HTTPServerError(message) {\r\n  this.name = 'HTTPServerError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nHTTPServerError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction ResourceLimitError(message) {\r\n  this.name = 'ResourceLimitError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nResourceLimitError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction TimeoutError(message) {\r\n  this.name = 'TimeoutError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nTimeoutError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction BadConnectionError(message, type) {\r\n  this.name = 'BadConnectionError';\r\n  this.message = message;\r\n  this.type = type;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nBadConnectionError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction BrokerError(message) {\r\n  this.name = 'BrokerError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nBrokerError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction ProcessExitError(message, code) {\r\n  this.name = 'ProcessExitError';\r\n  this.message = message;\r\n  this.code = code;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nProcessExitError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction UnknownError(message) {\r\n  this.name = 'UnknownError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nUnknownError.prototype = Object.create(Error.prototype);\r\n\r\n\r\n// Expose all error types\r\n\r\nmodule.exports = {\r\n  AuthTokenExpiredError: AuthTokenExpiredError,\r\n  AuthTokenInvalidError: AuthTokenInvalidError,\r\n  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\r\n  AuthTokenError: AuthTokenError,\r\n  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\r\n  InvalidActionError: InvalidActionError,\r\n  InvalidArgumentsError: InvalidArgumentsError,\r\n  InvalidOptionsError: InvalidOptionsError,\r\n  InvalidMessageError: InvalidMessageError,\r\n  SocketProtocolError: SocketProtocolError,\r\n  ServerProtocolError: ServerProtocolError,\r\n  HTTPServerError: HTTPServerError,\r\n  ResourceLimitError: ResourceLimitError,\r\n  TimeoutError: TimeoutError,\r\n  BadConnectionError: BadConnectionError,\r\n  BrokerError: BrokerError,\r\n  ProcessExitError: ProcessExitError,\r\n  UnknownError: UnknownError\r\n};\r\n\r\nmodule.exports.socketProtocolErrorStatuses = {\r\n  1001: 'Socket was disconnected',\r\n  1002: 'A WebSocket protocol error was encountered',\r\n  1003: 'Server terminated socket because it received invalid data',\r\n  1005: 'Socket closed without status code',\r\n  1006: 'Socket hung up',\r\n  1007: 'Message format was incorrect',\r\n  1008: 'Encountered a policy violation',\r\n  1009: 'Message was too big to process',\r\n  1010: 'Client ended the connection because the server did not comply with extension requirements',\r\n  1011: 'Server encountered an unexpected fatal condition',\r\n  4000: 'Server ping timed out',\r\n  4001: 'Client pong timed out',\r\n  4002: 'Server failed to sign auth token',\r\n  4003: 'Failed to complete handshake',\r\n  4004: 'Client failed to save auth token',\r\n  4005: 'Did not receive #handshake from client before timeout',\r\n  4006: 'Failed to bind socket to message broker',\r\n  4007: 'Client connection establishment timed out'\r\n};\r\n\r\nmodule.exports.socketProtocolIgnoreStatuses = {\r\n  1000: 'Socket closed normally',\r\n  1001: 'Socket hung up'\r\n};\r\n\r\n// Properties related to error domains cannot be serialized.\r\nvar unserializableErrorProperties = {\r\n  domain: 1,\r\n  domainEmitter: 1,\r\n  domainThrown: 1\r\n};\r\n\r\nmodule.exports.dehydrateError = function (error, includeStackTrace) {\r\n  var dehydratedError;\r\n\r\n  if (error && typeof error == 'object') {\r\n    dehydratedError = {\r\n      message: error.message\r\n    };\r\n    if (includeStackTrace) {\r\n      dehydratedError.stack = error.stack;\r\n    }\r\n    for (var i in error) {\r\n      if (!unserializableErrorProperties[i]) {\r\n        dehydratedError[i] = error[i];\r\n      }\r\n    }\r\n  } else if (typeof error == 'function') {\r\n    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\r\n  } else {\r\n    dehydratedError = error;\r\n  }\r\n\r\n  return decycle(dehydratedError);\r\n};\r\n\r\nmodule.exports.hydrateError = function (error) {\r\n  var hydratedError = null;\r\n  if (error != null) {\r\n    if (typeof error == 'object') {\r\n      hydratedError = new Error(error.message);\r\n      for (var i in error) {\r\n        if (error.hasOwnProperty(i)) {\r\n          hydratedError[i] = error[i];\r\n        }\r\n      }\r\n    } else {\r\n      hydratedError = error;\r\n    }\r\n  }\r\n  return hydratedError;\r\n};\r\n\r\nmodule.exports.decycle = decycle;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sc-errors/index.js\n// module id = 10\n// module chunks = 0 1","// Based on https://github.com/dscape/cycle/blob/master/cycle.js\r\n\r\nmodule.exports = function decycle(object) {\r\n// Make a deep copy of an object or array, assuring that there is at most\r\n// one instance of each object or array in the resulting structure. The\r\n// duplicate references (which might be forming cycles) are replaced with\r\n// an object of the form\r\n//      {$ref: PATH}\r\n// where the PATH is a JSONPath string that locates the first occurance.\r\n// So,\r\n//      var a = [];\r\n//      a[0] = a;\r\n//      return JSON.stringify(JSON.decycle(a));\r\n// produces the string '[{\"$ref\":\"$\"}]'.\r\n\r\n// JSONPath is used to locate the unique object. $ indicates the top level of\r\n// the object or array. [NUMBER] or [STRING] indicates a child member or\r\n// property.\r\n\r\n    var objects = [],   // Keep a reference to each unique object or array\r\n        paths = [];     // Keep the path to each unique object or array\r\n\r\n    return (function derez(value, path) {\r\n\r\n// The derez recurses through the object, producing the deep copy.\r\n\r\n        var i,          // The loop counter\r\n            name,       // Property name\r\n            nu;         // The new object or array\r\n\r\n// typeof null === 'object', so go on if this value is really an object but not\r\n// one of the weird builtin objects.\r\n\r\n        if (typeof value === 'object' && value !== null &&\r\n                !(value instanceof Boolean) &&\r\n                !(value instanceof Date)    &&\r\n                !(value instanceof Number)  &&\r\n                !(value instanceof RegExp)  &&\r\n                !(value instanceof String)) {\r\n\r\n// If the value is an object or array, look to see if we have already\r\n// encountered it. If so, return a $ref/path object. This is a hard way,\r\n// linear search that will get slower as the number of unique objects grows.\r\n\r\n            for (i = 0; i < objects.length; i += 1) {\r\n                if (objects[i] === value) {\r\n                    return {$ref: paths[i]};\r\n                }\r\n            }\r\n\r\n// Otherwise, accumulate the unique value and its path.\r\n\r\n            objects.push(value);\r\n            paths.push(path);\r\n\r\n// If it is an array, replicate the array.\r\n\r\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\r\n                nu = [];\r\n                for (i = 0; i < value.length; i += 1) {\r\n                    nu[i] = derez(value[i], path + '[' + i + ']');\r\n                }\r\n            } else {\r\n\r\n// If it is an object, replicate the object.\r\n\r\n                nu = {};\r\n                for (name in value) {\r\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n                        nu[name] = derez(value[name],\r\n                            path + '[' + JSON.stringify(name) + ']');\r\n                    }\r\n                }\r\n            }\r\n            return nu;\r\n        }\r\n        return value;\r\n    }(object, '$'));\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sc-errors/decycle.js\n// module id = 11\n// module chunks = 0 1","var AuthEngine = function () {\n  this._internalStorage = {};\n  this.isLocalStorageEnabled = this._checkLocalStorageEnabled();\n};\n\nAuthEngine.prototype._checkLocalStorageEnabled = function () {\n  var err;\n  try {\n    // Some browsers will throw an error here if localStorage is disabled.\n    global.localStorage;\n\n    // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n    // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.\n    global.localStorage.setItem('__scLocalStorageTest', 1);\n    global.localStorage.removeItem('__scLocalStorageTest');\n  } catch (e) {\n    err = e;\n  }\n  return !err;\n};\n\nAuthEngine.prototype.saveToken = function (name, token, options, callback) {\n  if (this.isLocalStorageEnabled && global.localStorage) {\n    global.localStorage.setItem(name, token);\n  } else {\n    this._internalStorage[name] = token;\n  }\n  callback && callback(null, token);\n};\n\nAuthEngine.prototype.removeToken = function (name, callback) {\n  var token;\n\n  this.loadToken(name, function (err, authToken) {\n    token = authToken;\n  });\n\n  if (this.isLocalStorageEnabled && global.localStorage) {\n    global.localStorage.removeItem(name);\n  } else {\n    delete this._internalStorage[name];\n  }\n\n  callback && callback(null, token);\n};\n\nAuthEngine.prototype.loadToken = function (name, callback) {\n  var token;\n\n  if (this.isLocalStorageEnabled && global.localStorage) {\n    token = global.localStorage.getItem(name);\n  } else {\n    token = this._internalStorage[name] || null;\n  }\n  callback(null, token);\n};\n\nmodule.exports.AuthEngine = AuthEngine;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/auth.js\n// module id = 12\n// module chunks = 0 1","var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvar arrayBufferToBase64 = function (arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n\n  if ((len % 3) === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nvar binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer){\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    }\n    // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n    if (value && value.type == 'Buffer' && value.data instanceof Array) {\n      var rehydratedBuffer;\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n  return value;\n};\n\n// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\nmodule.exports.decode = function (input) {\n  if (input == null) {\n   return null;\n  }\n  // Leave ping or pong message as is\n  if (input == '#1' || input == '#2') {\n    return input;\n  }\n  var message = input.toString();\n\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n  return message;\n};\n\n\n// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\nmodule.exports.encode = function (object) {\n  // Leave ping or pong message as is\n  if (object == '#1' || object == '#2') {\n    return object;\n  }\n  return JSON.stringify(object, binaryToBase64Replacer);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sc-formatter/index.js\n// module id = 13\n// module chunks = 0 1","var Emitter = require('component-emitter');\nvar Response = require('./response').Response;\nvar querystring = require('querystring');\nvar WebSocket;\nvar createWebSocket;\n\nif (global.WebSocket) {\n  WebSocket = global.WebSocket;\n  createWebSocket = function (uri, options) {\n    return new WebSocket(uri);\n  };\n} else {\n  WebSocket = require('ws');\n  createWebSocket = function (uri, options) {\n    return new WebSocket(uri, null, options);\n  };\n}\n\nvar scErrors = require('sc-errors');\nvar TimeoutError = scErrors.TimeoutError;\nvar BadConnectionError = scErrors.BadConnectionError;\n\n\nvar SCTransport = function (authEngine, codecEngine, options) {\n  this.state = this.CLOSED;\n  this.auth = authEngine;\n  this.codec = codecEngine;\n  this.options = options;\n  this.connectTimeout = options.connectTimeout;\n  this.pingTimeout = options.ackTimeout;\n  this.callIdGenerator = options.callIdGenerator;\n  this.authTokenName = options.authTokenName;\n\n  this._pingTimeoutTicker = null;\n  this._callbackMap = {};\n  this._batchSendList = [];\n\n  this.open();\n};\n\nSCTransport.prototype = Object.create(Emitter.prototype);\n\nSCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';\nSCTransport.OPEN = SCTransport.prototype.OPEN = 'open';\nSCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';\n\nSCTransport.prototype.uri = function () {\n  var query = this.options.query || {};\n  var schema = this.options.secure ? 'wss' : 'ws';\n\n  if (this.options.timestampRequests) {\n    query[this.options.timestampParam] = (new Date()).getTime();\n  }\n\n  query = querystring.encode(query);\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var host;\n  if (this.options.host) {\n    host = this.options.host;\n  } else {\n    var port = '';\n\n    if (this.options.port && ((schema == 'wss' && this.options.port != 443)\n      || (schema == 'ws' && this.options.port != 80))) {\n      port = ':' + this.options.port;\n    }\n    host = this.options.hostname + port;\n  }\n\n  return schema + '://' + host + this.options.path + query;\n};\n\nSCTransport.prototype.open = function () {\n  var self = this;\n\n  this.state = this.CONNECTING;\n  var uri = this.uri();\n\n  var wsSocket = createWebSocket(uri, this.options);\n  wsSocket.binaryType = this.options.binaryType;\n  this.socket = wsSocket;\n\n  wsSocket.onopen = function () {\n    self._onOpen();\n  };\n\n  wsSocket.onclose = function (event) {\n    var code;\n    if (event.code == null) {\n      // This is to handle an edge case in React Native whereby\n      // event.code is undefined when the mobile device is locked.\n      // TODO: This is not perfect since this condition could also apply to\n      // an abnormal close (no close control frame) which would be a 1006.\n      code = 1005;\n    } else {\n      code = event.code;\n    }\n    self._onClose(code, event.reason);\n  };\n\n  wsSocket.onmessage = function (message, flags) {\n    self._onMessage(message.data);\n  };\n\n  wsSocket.onerror = function (error) {\n    // The onclose event will be called automatically after the onerror event\n    // if the socket is connected - Otherwise, if it's in the middle of\n    // connecting, we want to close it manually with a 1006 - This is necessary\n    // to prevent inconsistent behavior when running the client in Node.js\n    // vs in a browser.\n\n    if (self.state === self.CONNECTING) {\n      self._onClose(1006);\n    }\n  };\n\n  this._connectTimeoutRef = setTimeout(function () {\n    self._onClose(4007);\n    self.socket.close(4007);\n  }, this.connectTimeout);\n};\n\nSCTransport.prototype._onOpen = function () {\n  var self = this;\n\n  clearTimeout(this._connectTimeoutRef);\n  this._resetPingTimeout();\n\n  this._handshake(function (err, status) {\n    if (err) {\n      self._onError(err);\n      self._onClose(4003);\n      self.socket.close(4003);\n    } else {\n      self.state = self.OPEN;\n      Emitter.prototype.emit.call(self, 'open', status);\n      self._resetPingTimeout();\n    }\n  });\n};\n\nSCTransport.prototype._handshake = function (callback) {\n  var self = this;\n  this.auth.loadToken(this.authTokenName, function (err, token) {\n    if (err) {\n      callback(err);\n    } else {\n      // Don't wait for this.state to be 'open'.\n      // The underlying WebSocket (this.socket) is already open.\n      var options = {\n        force: true\n      };\n      self.emit('#handshake', {\n        authToken: token\n      }, options, function (err, status) {\n        if (status) {\n          // Add the token which was used as part of authentication attempt\n          // to the status object.\n          status.authToken = token;\n          if (status.authError) {\n            status.authError = scErrors.hydrateError(status.authError);\n          }\n        }\n        callback(err, status);\n      });\n    }\n  });\n};\n\nSCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n  for (var i in this._callbackMap) {\n    if (this._callbackMap.hasOwnProperty(i)) {\n      var eventObject = this._callbackMap[i];\n      delete this._callbackMap[i];\n\n      clearTimeout(eventObject.timeout);\n      delete eventObject.timeout;\n\n      var errorMessage = \"Event '\" + eventObject.event +\n        \"' was aborted due to a bad connection\";\n      var badConnectionError = new BadConnectionError(errorMessage, failureType);\n\n      var callback = eventObject.callback;\n      delete eventObject.callback;\n      callback.call(eventObject, badConnectionError, eventObject);\n    }\n  }\n};\n\nSCTransport.prototype._onClose = function (code, data) {\n  delete this.socket.onopen;\n  delete this.socket.onclose;\n  delete this.socket.onmessage;\n  delete this.socket.onerror;\n\n  clearTimeout(this._connectTimeoutRef);\n\n  if (this.state == this.OPEN) {\n    this.state = this.CLOSED;\n    Emitter.prototype.emit.call(this, 'close', code, data);\n    this._abortAllPendingEventsDueToBadConnection('disconnect');\n\n  } else if (this.state == this.CONNECTING) {\n    this.state = this.CLOSED;\n    Emitter.prototype.emit.call(this, 'openAbort', code, data);\n    this._abortAllPendingEventsDueToBadConnection('connectAbort');\n  }\n};\n\nSCTransport.prototype._handleEventObject = function (obj, message) {\n  if (obj && obj.event != null) {\n    var response = new Response(this, obj.cid);\n    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);\n  } else if (obj && obj.rid != null) {\n    var eventObject = this._callbackMap[obj.rid];\n    if (eventObject) {\n      clearTimeout(eventObject.timeout);\n      delete eventObject.timeout;\n      delete this._callbackMap[obj.rid];\n\n      if (eventObject.callback) {\n        var rehydratedError = scErrors.hydrateError(obj.error);\n        eventObject.callback(rehydratedError, obj.data);\n      }\n    }\n  } else {\n    Emitter.prototype.emit.call(this, 'event', 'raw', message);\n  }\n};\n\nSCTransport.prototype._onMessage = function (message) {\n  Emitter.prototype.emit.call(this, 'event', 'message', message);\n\n  var obj = this.decode(message);\n\n  // If ping\n  if (obj == '#1') {\n    this._resetPingTimeout();\n    if (this.socket.readyState == this.socket.OPEN) {\n      this.sendObject('#2');\n    }\n  } else {\n    if (Array.isArray(obj)) {\n      var len = obj.length;\n      for (var i = 0; i < len; i++) {\n        this._handleEventObject(obj[i], message);\n      }\n    } else {\n      this._handleEventObject(obj, message);\n    }\n  }\n};\n\nSCTransport.prototype._onError = function (err) {\n  Emitter.prototype.emit.call(this, 'error', err);\n};\n\nSCTransport.prototype._resetPingTimeout = function () {\n  var self = this;\n\n  var now = (new Date()).getTime();\n  clearTimeout(this._pingTimeoutTicker);\n\n  this._pingTimeoutTicker = setTimeout(function () {\n    self._onClose(4000);\n    self.socket.close(4000);\n  }, this.pingTimeout);\n};\n\nSCTransport.prototype.getBytesReceived = function () {\n  return this.socket.bytesReceived;\n};\n\nSCTransport.prototype.close = function (code, data) {\n  code = code || 1000;\n\n  if (this.state == this.OPEN) {\n    var packet = {\n      code: code,\n      data: data\n    };\n    this.emit('#disconnect', packet);\n\n    this._onClose(code, data);\n    this.socket.close(code);\n\n  } else if (this.state == this.CONNECTING) {\n    this._onClose(code, data);\n    this.socket.close(code);\n  }\n};\n\nSCTransport.prototype.emitObject = function (eventObject, options) {\n  var simpleEventObject = {\n    event: eventObject.event,\n    data: eventObject.data\n  };\n\n  if (eventObject.callback) {\n    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();\n    this._callbackMap[eventObject.cid] = eventObject;\n  }\n\n  this.sendObject(simpleEventObject, options);\n\n  return eventObject.cid || null;\n};\n\nSCTransport.prototype._handleEventAckTimeout = function (eventObject) {\n\n  if (eventObject.cid) {\n    delete this._callbackMap[eventObject.cid];\n  }\n  delete eventObject.timeout;\n\n  var callback = eventObject.callback;\n  if (callback) {\n    delete eventObject.callback;\n    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n    callback.call(eventObject, error, eventObject);\n  }\n};\n\n// The last two optional arguments (a and b) can be options and/or callback\nSCTransport.prototype.emit = function (event, data, a, b) {\n  var self = this;\n\n  var callback, options;\n\n  if (b) {\n    options = a;\n    callback = b;\n  } else {\n    if (a instanceof Function) {\n      options = {};\n      callback = a;\n    } else {\n      options = a;\n    }\n  }\n\n  var eventObject = {\n    event: event,\n    data: data,\n    callback: callback\n  };\n\n  if (callback && !options.noTimeout) {\n    eventObject.timeout = setTimeout(function () {\n      self._handleEventAckTimeout(eventObject);\n    }, this.options.ackTimeout);\n  }\n\n  var cid = null;\n  if (this.state == this.OPEN || options.force) {\n    cid = this.emitObject(eventObject, options);\n  }\n  return cid;\n};\n\nSCTransport.prototype.cancelPendingResponse = function (cid) {\n  delete this._callbackMap[cid];\n};\n\nSCTransport.prototype.decode = function (message) {\n  return this.codec.decode(message);\n};\n\nSCTransport.prototype.encode = function (object) {\n  return this.codec.encode(object);\n};\n\nSCTransport.prototype.send = function (data) {\n  if (this.socket.readyState != this.socket.OPEN) {\n    this._onClose(1005);\n  } else {\n    this.socket.send(data);\n  }\n};\n\nSCTransport.prototype.serializeObject = function (object) {\n  var str, formatError;\n  try {\n    str = this.encode(object);\n  } catch (err) {\n    formatError = err;\n    this._onError(formatError);\n  }\n  if (!formatError) {\n    return str;\n  }\n  return null;\n};\n\nSCTransport.prototype.sendObjectBatch = function (object) {\n  var self = this;\n\n  this._batchSendList.push(object);\n  if (this._batchTimeout) {\n    return;\n  }\n\n  this._batchTimeout = setTimeout(function () {\n    delete self._batchTimeout;\n    if (self._batchSendList.length) {\n      var str = self.serializeObject(self._batchSendList);\n      if (str != null) {\n        self.send(str);\n      }\n      self._batchSendList = [];\n    }\n  }, this.options.pubSubBatchDuration || 0);\n};\n\nSCTransport.prototype.sendObjectSingle = function (object) {\n  var str = this.serializeObject(object);\n  if (str != null) {\n    this.send(str);\n  }\n};\n\nSCTransport.prototype.sendObject = function (object, options) {\n  if (options && options.batch) {\n    this.sendObjectBatch(object);\n  } else {\n    this.sendObjectSingle(object);\n  }\n};\n\nmodule.exports.SCTransport = SCTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/sctransport.js\n// module id = 14\n// module chunks = 0 1","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystring/index.js\n// module id = 15\n// module chunks = 0 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystring/decode.js\n// module id = 16\n// module chunks = 0 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystring/encode.js\n// module id = 17\n// module chunks = 0 1","var global;\nif (typeof WorkerGlobalScope !== 'undefined') {\n  global = self;\n} else {\n  global = typeof window != 'undefined' && window || (function() { return this; })();\n}\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object} opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n\nmodule.exports = WebSocket ? ws : null;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/ws-browser.js\n// module id = 18\n// module chunks = 0 1","'use strict';\n\nmodule.exports = require('./_source/linked-list.js');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/linked-list/index.js\n// module id = 19\n// module chunks = 0 1","'use strict';\n\n/**\n * Constants.\n */\n\nvar errorMessage;\n\nerrorMessage = 'An argument without append, prepend, ' +\n    'or detach methods was given to `List';\n\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List(/*items...*/) {\n    if (arguments.length) {\n        return List.from(arguments);\n    }\n}\n\nvar ListPrototype;\n\nListPrototype = List.prototype;\n\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function (/*items...*/) {\n    return List.from.call(this, arguments);\n};\n\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\nList.from = function (items) {\n    var list = new this(), length, iterator, item;\n\n    if (items && (length = items.length)) {\n        iterator = -1;\n\n        while (++iterator < length) {\n            item = items[iterator];\n\n            if (item !== null && item !== undefined) {\n                list.append(item);\n            }\n        }\n    }\n\n    return list;\n};\n\n/**\n * List#head\n * Default to `null`.\n */\nListPrototype.head = null;\n\n/**\n * List#tail\n * Default to `null`.\n */\nListPrototype.tail = null;\n\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\nListPrototype.toArray = function () {\n    var item = this.head,\n        result = [];\n\n    while (item) {\n        result.push(item);\n        item = item.next;\n    }\n\n    return result;\n};\n\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\nListPrototype.prepend = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#prepend`.');\n    }\n\n    var self, head;\n\n    // Cache self.\n    self = this;\n\n    // If self has a first item, defer prepend to the first items prepend\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.prepend(item);\n    }\n\n    // ...otherwise, there is no `head` (or `tail`) item yet.\n\n    // Detach the prependee.\n    item.detach();\n\n    // Set the prependees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the prependee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\nListPrototype.append = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#append`.');\n    }\n\n    var self, head, tail;\n\n    // Cache self.\n    self = this;\n\n    // If self has a last item, defer appending to the last items append\n    // method, and return the result.\n    tail = self.tail;\n\n    if (tail) {\n        return tail.append(item);\n    }\n\n    // If self has a first item, defer appending to the first items append\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.append(item);\n    }\n\n    // ...otherwise, there is no `tail` or `head` item yet.\n\n    // Detach the appendee.\n    item.detach();\n\n    // Set the appendees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the appendee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\nfunction ListItem() {}\n\nList.Item = ListItem;\n\nvar ListItemPrototype = ListItem.prototype;\n\nListItemPrototype.next = null;\n\nListItemPrototype.prev = null;\n\nListItemPrototype.list = null;\n\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\nListItemPrototype.detach = function () {\n    // Cache self, the parent list, and the previous and next items.\n    var self = this,\n        list = self.list,\n        prev = self.prev,\n        next = self.next;\n\n    // If the item is already detached, return self.\n    if (!list) {\n        return self;\n    }\n\n    // If self is the last item in the parent list, link the lists last item\n    // to the previous item.\n    if (list.tail === self) {\n        list.tail = prev;\n    }\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the next item.\n    if (list.head === self) {\n        list.head = next;\n    }\n\n    // If both the last and first items in the parent list are the same,\n    // remove the link to the last item.\n    if (list.tail === list.head) {\n        list.tail = null;\n    }\n\n    // If a previous item exists, link its next item to selfs next item.\n    if (prev) {\n        prev.next = next;\n    }\n\n    // If a next item exists, link its previous item to selfs previous item.\n    if (next) {\n        next.prev = prev;\n    }\n\n    // Remove links from self to both the next and previous items, and to the\n    // parent list.\n    self.prev = self.next = self.list = null;\n\n    // Return self.\n    return self;\n};\n\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.prepend = function (item) {\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#prepend`.');\n    }\n\n    // Cache self, the parent list, and the previous item.\n    var self = this,\n        list = self.list,\n        prev = self.prev;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the prependee.\n    item.detach();\n\n    // If self has a previous item...\n    if (prev) {\n        // ...link the prependees previous item, to selfs previous item.\n        item.prev = prev;\n\n        // ...link the previous items next item, to self.\n        prev.next = item;\n    }\n\n    // Set the prependees next item to self.\n    item.next = self;\n\n    // Set the prependees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the previous item of self to the prependee.\n    self.prev = item;\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the prependee.\n    if (self === list.head) {\n        list.head = item;\n    }\n\n    // If the the parent list has no last item, link the lists last item to\n    // self.\n    if (!list.tail) {\n        list.tail = self;\n    }\n\n    // Return the prependee.\n    return item;\n};\n\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.append = function (item) {\n    // If item is falsey, return false.\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#append`.');\n    }\n\n    // Cache self, the parent list, and the next item.\n    var self = this,\n        list = self.list,\n        next = self.next;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the appendee.\n    item.detach();\n\n    // If self has a next item...\n    if (next) {\n        // ...link the appendees next item, to selfs next item.\n        item.next = next;\n\n        // ...link the next items previous item, to the appendee.\n        next.prev = item;\n    }\n\n    // Set the appendees previous item to self.\n    item.prev = self;\n\n    // Set the appendees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the next item of self to the appendee.\n    self.next = item;\n\n    // If the the parent list has no last item or if self is the parent lists\n    // last item, link the lists last item to the appendee.\n    if (self === list.tail || !list.tail) {\n        list.tail = item;\n    }\n\n    // Return the appendee.\n    return item;\n};\n\n/**\n * Expose `List`.\n */\n\nmodule.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/linked-list/_source/linked-list.js\n// module id = 20\n// module chunks = 0 1","/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code, and use\n\t// it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar InvalidCharacterError = function(message) {\n\t\tthis.message = message;\n\t};\n\tInvalidCharacterError.prototype = new Error;\n\tInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\tvar error = function(message) {\n\t\t// Note: the error messages used throughout this file match those used by\n\t\t// the native `atob`/`btoa` implementation in Chromium.\n\t\tthrow new InvalidCharacterError(message);\n\t};\n\n\tvar TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t// http://whatwg.org/html/common-microsyntaxes.html#space-character\n\tvar REGEX_SPACE_CHARACTERS = /[\\t\\n\\f\\r ]/g;\n\n\t// `decode` is designed to be fully compatible with `atob` as described in the\n\t// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob\n\t// The optimized base64-decoding algorithm used is based on @atks excellent\n\t// implementation. https://gist.github.com/atk/1020396\n\tvar decode = function(input) {\n\t\tinput = String(input)\n\t\t\t.replace(REGEX_SPACE_CHARACTERS, '');\n\t\tvar length = input.length;\n\t\tif (length % 4 == 0) {\n\t\t\tinput = input.replace(/==?$/, '');\n\t\t\tlength = input.length;\n\t\t}\n\t\tif (\n\t\t\tlength % 4 == 1 ||\n\t\t\t// http://whatwg.org/C#alphanumeric-ascii-characters\n\t\t\t/[^+a-zA-Z0-9/]/.test(input)\n\t\t) {\n\t\t\terror(\n\t\t\t\t'Invalid character: the string to be decoded is not correctly encoded.'\n\t\t\t);\n\t\t}\n\t\tvar bitCounter = 0;\n\t\tvar bitStorage;\n\t\tvar buffer;\n\t\tvar output = '';\n\t\tvar position = -1;\n\t\twhile (++position < length) {\n\t\t\tbuffer = TABLE.indexOf(input.charAt(position));\n\t\t\tbitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;\n\t\t\t// Unless this is the first of a group of 4 characters\n\t\t\tif (bitCounter++ % 4) {\n\t\t\t\t// convert the first 8 bits to a single ASCII character.\n\t\t\t\toutput += String.fromCharCode(\n\t\t\t\t\t0xFF & bitStorage >> (-2 * bitCounter & 6)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\n\t// `encode` is designed to be fully compatible with `btoa` as described in the\n\t// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa\n\tvar encode = function(input) {\n\t\tinput = String(input);\n\t\tif (/[^\\0-\\xFF]/.test(input)) {\n\t\t\t// Note: no need to special-case astral symbols here, as surrogates are\n\t\t\t// matched, and the input is supposed to only contain ASCII anyway.\n\t\t\terror(\n\t\t\t\t'The string to be encoded contains characters outside of the ' +\n\t\t\t\t'Latin1 range.'\n\t\t\t);\n\t\t}\n\t\tvar padding = input.length % 3;\n\t\tvar output = '';\n\t\tvar position = -1;\n\t\tvar a;\n\t\tvar b;\n\t\tvar c;\n\t\tvar d;\n\t\tvar buffer;\n\t\t// Make sure any padding is handled outside of the loop.\n\t\tvar length = input.length - padding;\n\n\t\twhile (++position < length) {\n\t\t\t// Read three bytes, i.e. 24 bits.\n\t\t\ta = input.charCodeAt(position) << 16;\n\t\t\tb = input.charCodeAt(++position) << 8;\n\t\t\tc = input.charCodeAt(++position);\n\t\t\tbuffer = a + b + c;\n\t\t\t// Turn the 24 bits into four chunks of 6 bits each, and append the\n\t\t\t// matching character for each of them to the output.\n\t\t\toutput += (\n\t\t\t\tTABLE.charAt(buffer >> 18 & 0x3F) +\n\t\t\t\tTABLE.charAt(buffer >> 12 & 0x3F) +\n\t\t\t\tTABLE.charAt(buffer >> 6 & 0x3F) +\n\t\t\t\tTABLE.charAt(buffer & 0x3F)\n\t\t\t);\n\t\t}\n\n\t\tif (padding == 2) {\n\t\t\ta = input.charCodeAt(position) << 8;\n\t\t\tb = input.charCodeAt(++position);\n\t\t\tbuffer = a + b;\n\t\t\toutput += (\n\t\t\t\tTABLE.charAt(buffer >> 10) +\n\t\t\t\tTABLE.charAt((buffer >> 4) & 0x3F) +\n\t\t\t\tTABLE.charAt((buffer << 2) & 0x3F) +\n\t\t\t\t'='\n\t\t\t);\n\t\t} else if (padding == 1) {\n\t\t\tbuffer = input.charCodeAt(position);\n\t\t\toutput += (\n\t\t\t\tTABLE.charAt(buffer >> 2) +\n\t\t\t\tTABLE.charAt((buffer << 4) & 0x3F) +\n\t\t\t\t'=='\n\t\t\t);\n\t\t}\n\n\t\treturn output;\n\t};\n\n\tvar base64 = {\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'version': '0.1.0'\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn base64;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = base64;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in base64) {\n\t\t\t\tbase64.hasOwnProperty(key) && (freeExports[key] = base64[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.base64 = base64;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base-64/base64.js\n// module id = 21\n// module chunks = 0 1","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 22\n// module chunks = 0 1","var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/clone/clone.js\n// module id = 23\n// module chunks = 0 1","var SCSocket = require('./scsocket');\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\nvar _connections = {};\n\nfunction getMultiplexId(options) {\n  var protocolPrefix = options.secure ? 'https://' : 'http://';\n  var queryString = '';\n  if (options.query) {\n    if (typeof options.query == 'string') {\n      queryString = options.query;\n    } else {\n      var queryArray = [];\n      var queryMap = options.query;\n      for (var key in queryMap) {\n        if (queryMap.hasOwnProperty(key)) {\n          queryArray.push(key + '=' + queryMap[key]);\n        }\n      }\n      if (queryArray.length) {\n        queryString = '?' + queryArray.join('&');\n      }\n    }\n  }\n  var host;\n  if (options.host) {\n    host = options.host;\n  } else {\n    host = options.hostname + ':' + options.port;\n  }\n  return protocolPrefix + host + options.path + queryString;\n}\n\nfunction isUrlSecure() {\n  return global.location && location.protocol == 'https:';\n}\n\nfunction getPort(options, isSecureDefault) {\n  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n}\n\nfunction connect(options) {\n  var self = this;\n\n  options = options || {};\n\n  if (options.host && options.port) {\n    throw new InvalidArgumentsError('The host option should already include the' +\n      ' port number in the format hostname:port - Because of this, the host and port options' +\n      ' cannot be specified together; use the hostname option instead');\n  }\n\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname,\n    path: '/socketcluster/',\n    secure: isSecureDefault,\n    autoConnect: true,\n    autoReconnect: true,\n    autoSubscribeOnConnect: true,\n    connectTimeout: 20000,\n    ackTimeout: 10000,\n    timestampRequests: false,\n    timestampParam: 't',\n    authEngine: null,\n    authTokenName: 'socketCluster.authToken',\n    binaryType: 'arraybuffer',\n    multiplex: true,\n    pubSubBatchDuration: null,\n    cloneData: false\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  var multiplexId = getMultiplexId(opts);\n  if (opts.multiplex === false) {\n    return new SCSocket(opts);\n  }\n  if (_connections[multiplexId]) {\n    _connections[multiplexId].connect();\n  } else {\n    _connections[multiplexId] = new SCSocket(opts);\n  }\n  return _connections[multiplexId];\n}\n\nfunction destroy(options) {\n  var self = this;\n\n  options = options || {};\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname,\n    path: '/socketcluster/',\n    secure: isSecureDefault\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  var multiplexId = getMultiplexId(opts);\n  var socket = _connections[multiplexId];\n  if (socket) {\n    socket.destroy();\n  }\n  delete _connections[multiplexId];\n}\n\nmodule.exports = {\n  connect: connect,\n  destroy: destroy,\n  connections: _connections\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/scsocketcreator.js\n// module id = 24\n// module chunks = 0 1"],"sourceRoot":""}