{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///neolab-socket-client.min.js","webpack:///webpack/bootstrap b6c7667c42326289d0e5?2ac1","webpack:///./src/index.js?9552","webpack:///./src/neolab.socket.js?c67e","webpack:///./~/socketcluster-client/index.js?568c","webpack:///./~/socketcluster-client/lib/scsocket.js?3c51","webpack:///./~/buffer/index.js?1a55","webpack:///./~/base64-js/index.js?2add","webpack:///./~/ieee754/index.js?70fe","webpack:///./~/isarray/index.js?eabc","webpack:///./~/socketcluster-client/lib/scsocketcreator.js?2e61","webpack:///./~/sc-errors/index.js?205a","webpack:///./~/sc-errors/decycle.js?a5b8","webpack:///./~/component-emitter/index.js?ea2f"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_neolab","_neolab2","_classCallCheck","instance","Constructor","TypeError","_socketclusterClient","NeoLabSocketClient","Object","defineProperty","value","options","connection","connect","SCSocket","SCSocketCreator","Emitter","destroy","connections","version","Buffer","_createClass","_socket","_socket2","defineProperties","target","props","i","descriptor","length","enumerable","configurable","writable","key","protoProps","staticProps","prototype","socket","SocketConnect","sendEvent","emit","on","status","error","global","SCChannel","AuthEngine","Response","formatter","SCTransport","querystring","LinkedList","base64","clone","scErrors","InvalidArgumentsError","InvalidMessageError","SocketProtocolError","TimeoutError","BadConnectionError","isBrowser","window","opts","maxTimeout","verifyDuration","reconnectOptions","self","state","CLOSED","authState","UNAUTHENTICATED","signedAuthToken","authToken","pendingReconnect","pendingReconnectTimeout","preparingPendingSubscriptions","connectTimeout","ackTimeout","channelPrefix","disconnectOnUnload","authTokenName","pingTimeout","Math","pow","propertyName","_localEvents","connectAbort","disconnect","message","raw","fail","kickOut","subscribe","unsubscribe","subscribeStateChange","authStateChange","authenticate","deauthenticate","removeAuthToken","subscribeRequest","connectAttempts","_emitBuffer","channels","_cid","callIdGenerator","autoReconnect","autoReconnectOptions","initialDelay","randomness","multiplier","maxDelay","subscriptionRetryOptions","authEngine","auth","codecEngine","codec","path","replace","query","parse","autoConnect","_channelEmitter","addEventListener","_unloadHandler","create","CONNECTING","OPEN","AUTHENTICATED","PENDING","ignoreStatuses","socketProtocolIgnoreStatuses","errorStatuses","socketProtocolErrorStatuses","_privateEventHandlerMap","#publish","data","undecoratedChannelName","_undecorateChannelName","channel","isSubscribed","#kickOut","_triggerChannelUnsubscribe","#setAuthToken","response","triggerAuthenticate","err","_onSCError","_changeToAuthenticatedState","token","end","saveToken","#removeAuthToken","removeToken","oldToken","_changeToUnauthenticatedStateAndClearTokens","#disconnect","transport","close","code","getState","getBytesReceived","callback","open","clearTimeout","_reconnectTimeoutRef","off","_onSCOpen","_onSCClose","event","res","_onSCEvent","reconnect","removeEventListener","oldState","stateChangeData","newState","_extractAuthTokenData","processPendingSubscriptions","decodeBase64","encodedString","decodedString","buffer","atob","decode","toString","encodeBase64","btoa","encode","tokenData","tokenParts","split","encodedTokenData","JSON","e","getAuthToken","getSignedAuthToken","authStatus","isAuthenticated","authError","hydrateError","name","_tryReconnect","timeout","initialTimeout","exponent","round","random","setTimeout","autoSubscribeOnConnect","_flushEmitBuffer","listeners","_suspendSubscriptions","channelName","hasOwnProperty","SUBSCRIBED","UNSUBSCRIBED","_abortAllPendingEventsDueToBadConnection","failureType","nextNode","eventObject","errorMessage","currentNode","head","next","detach","openAbort","failureMessage","handler","apply","arguments","object","emitObject","_handleEventAckTimeout","eventNode","_emit","Item","cloneData","append","send","publish","pubData","_decorateChannelName","_triggerChannelSubscribe","subscriptionOptions","_triggerChannelSubscribeFail","meetsAuthRequirements","waitForAuth","_cancelPendingSubscribeCallback","_pendingSubscriptionCid","cancelPendingResponse","decoratedChannelName","indexOf","_trySubscribe","noTimeout","batch","setOptions","_tryUnsubscribe","currentChannel","destroyChannel","unwatch","subscriptions","includePending","includeChannel","subs","push","pendingChannels","sort","a","b","ap","priority","bp","forEach","watch","removeListener","removeAllListeners","watchers","typedArraySupport","arr","Uint8Array","__proto__","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","Error","allocUnsafe","from","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","undefined","checked","string","actual","isEncoding","write","slice","fromArrayLike","array","byteOffset","isBuffer","len","copy","isnan","type","isArray","SlowBuffer","loweredCase","isView","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","bidirectionalIndexOf","val","dir","isNaN","arrayIndexOf","lastIndexOf","read","buf","indexSize","readUInt16BE","foundIndex","found","j","arrLength","valLength","String","hexWrite","offset","remaining","strLen","parsed","Number","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","fromByteArray","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","min","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","INVALID_BASE64_RE","trim","units","leadSurrogate","Infinity","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","poolSize","_augment","Symbol","species","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","pos","swap16","swap32","swap64","equals","inspect","match","join","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","placeHoldersCount","b64","tmp","placeHolders","Arr","l","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","len2","extraBytes","parts","maxChunkLength","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","rt","abs","log","LN2","mixin","fn","_callbacks","once","callbacks","cb","splice","args","hasListeners","client","InvalidActionError","sent","_respond","responseData","rid","dehydrateError","AuthTokenExpiredError","expiry","captureStackTrace","isStrict","callee","stack","AuthTokenInvalidError","AuthTokenNotBeforeError","date","AuthTokenError","SilentMiddlewareBlockedError","InvalidOptionsError","ServerProtocolError","HTTPServerError","ResourceLimitError","BrokerError","ProcessExitError","UnknownError","unserializableErrorProperties","decycle","1001","1002","1003","1005","1006","1007","1008","1009","1010","1011","4000","4001","4002","4003","4004","4005","4006","4007","1000","domain","domainEmitter","domainThrown","includeStackTrace","dehydratedError","hydratedError","objects","paths","derez","nu","Boolean","Date","RegExp","$ref","stringify","_internalStorage","isLocalStorageEnabled","_checkLocalStorageEnabled","localStorage","setItem","removeItem","loadToken","getItem","base64Chars","arrayBufferToBase64","arraybuffer","substring","binaryToBase64Replacer","rehydratedBuffer","input","WebSocket","createWebSocket","uri","_pingTimeoutTicker","_callbackMap","_batchSendList","host","port","schema","secure","timestampRequests","timestampParam","getTime","hostname","wsSocket","binaryType","onopen","_onOpen","onclose","_onClose","reason","onmessage","flags","_onMessage","onerror","_connectTimeoutRef","_resetPingTimeout","_handshake","_onError","force","badConnectionError","_handleEventObject","rehydratedError","cid","readyState","sendObject","bytesReceived","packet","simpleEventObject","Function","serializeObject","formatError","sendObjectBatch","_batchTimeout","pubSubBatchDuration","sendObjectSingle","prop","qs","sep","eq","regexp","maxKeys","idx","kstr","vstr","k","v","decodeURIComponent","stringifyPrimitive","keys","map","ks","encodeURIComponent","ws","protocols","WorkerGlobalScope","MozWebSocket","List","ListItem","ListItemPrototype","ListPrototype","of","items","iterator","item","tail","toArray","result","prepend","prev","__WEBPACK_AMD_DEFINE_RESULT__","InvalidCharacterError","TABLE","REGEX_SPACE_CHARACTERS","freeExports","freeGlobal","bitCounter","bitStorage","position","test","charAt","padding","webpackPolyfill","deprecate","children","_instanceof","parent","circular","depth","includeNonEnumerable","_clone","child","proto","index","attrs","symbols","symbol","allPropertyNames","nativeMap","nativeSet","nativePromise","resolve","reject","then","__isArray","__isRegExp","source","__getRegExpFlags","lastIndex","__isDate","useBuffer","getPrototypeOf","allParents","allChildren","keyChild","valueChild","entryChild","add","getOwnPropertyDescriptor","getOwnPropertySymbols","getOwnPropertyNames","__objToStr","o","re","ignoreCase","multiline","Map","_","Set","Promise","clonePrototype","getMultiplexId","queryArray","queryMap","protocolPrefix","queryString","isUrlSecure","location","protocol","getPort","isSecureDefault","isSecure","multiplexId","multiplex","_connections"],"mappings":"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","file":"neolab-socket-client.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"NeoLabSocketClient\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NeoLabSocketClient\"] = factory();\n\telse\n\t\troot[\"NeoLabSocketClient\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"NeoLabSocketClient\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NeoLabSocketClient\"] = factory();\n\telse\n\t\troot[\"NeoLabSocketClient\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _neolab = __webpack_require__(1);\n\t\n\tvar _neolab2 = _interopRequireDefault(_neolab);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tmodule.exports = _neolab2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _socketclusterClient = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NeoLabSocketClient = function NeoLabSocketClient(options) {\n\t  _classCallCheck(this, NeoLabSocketClient);\n\t\n\t  this.connection = (0, _socketclusterClient.connect)(options);\n\t  return this.connection;\n\t};\n\t\n\texports.default = NeoLabSocketClient;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SCSocket = __webpack_require__(3);\n\tvar SCSocketCreator = __webpack_require__(8);\n\t\n\tmodule.exports.SCSocketCreator = SCSocketCreator;\n\tmodule.exports.SCSocket = SCSocket;\n\t\n\tmodule.exports.Emitter = __webpack_require__(11);\n\t\n\tmodule.exports.connect = function (options) {\n\t  return SCSocketCreator.connect(options);\n\t};\n\t\n\tmodule.exports.destroy = function (options) {\n\t  return SCSocketCreator.destroy(options);\n\t};\n\t\n\tmodule.exports.connections = SCSocketCreator.connections;\n\t\n\tmodule.exports.version = '8.0.1';\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"NeoLabSocketClient\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"NeoLabSocketClient\"] = factory();\n\t\telse\n\t\t\troot[\"NeoLabSocketClient\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar _neolab = __webpack_require__(1);\n\t\n\t\tvar _neolab2 = _interopRequireDefault(_neolab);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\tmodule.exports = _neolab2.default;\n\t\n\t/***/ }),\n\t/* 1 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\n\t\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t\tvar _socket = __webpack_require__(2);\n\t\n\t\tvar _socket2 = _interopRequireDefault(_socket);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t\tvar NeoLabSocketClient = function () {\n\t\t  function NeoLabSocketClient(options) {\n\t\t    _classCallCheck(this, NeoLabSocketClient);\n\t\n\t\t    this.options = options;\n\t\t    this.socket = null;\n\t\t  }\n\t\n\t\t  _createClass(NeoLabSocketClient, [{\n\t\t    key: 'connect',\n\t\t    value: function connect() {\n\t\t      if (!this.socket) {\n\t\t        this.socket = new _socket2.default(this.options).connect;\n\t\t      }\n\t\t      return this.socket;\n\t\t    }\n\t\t  }]);\n\t\n\t\t  return NeoLabSocketClient;\n\t\t}();\n\t\n\t\texports.default = NeoLabSocketClient;\n\t\n\t/***/ }),\n\t/* 2 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\n\t\tvar _socketclusterClient = __webpack_require__(3);\n\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t\tvar SocketConnect = function SocketConnect(options) {\n\t\t  _classCallCheck(this, SocketConnect);\n\t\n\t\t  _socketclusterClient.Emitter.call(this);\n\t\t  var sendEvent = new _socketclusterClient.Emitter();\n\t\t  this.emit = sendEvent;\n\t\t  this.connect = (0, _socketclusterClient.connect)(options);\n\t\n\t\t  this.connect.on('connect', function (status) {\n\t\t    sendEvent.emit('neolab:socket-connected', status);\n\t\t  });\n\t\n\t\t  this.connect.on('connecting', function () {\n\t\t    sendEvent.emit('neolab:socket-connecting');\n\t\t  });\n\t\n\t\t  this.connect.on('authenticate', function () {\n\t\t    sendEvent.emit('neolab:socket-authenticated');\n\t\t  });\n\t\n\t\t  this.connect.on('deauthenticate', function () {\n\t\t    sendEvent.emit('neolab:socket-deauthenticated');\n\t\t  });\n\t\n\t\t  this.connect.on('disconnect', function () {\n\t\t    sendEvent.emit('neolab:socket-disconnected');\n\t\t  });\n\t\n\t\t  this.connect.on('error', function (error) {\n\t\t    sendEvent.emit('neolab:socket-failed', error);\n\t\t  });\n\t\t};\n\t\n\t\texports.default = SocketConnect;\n\t\n\t/***/ }),\n\t/* 3 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\tvar SCSocket = __webpack_require__(4);\n\t\tvar SCSocketCreator = __webpack_require__(26);\n\t\n\t\tmodule.exports.SCSocketCreator = SCSocketCreator;\n\t\tmodule.exports.SCSocket = SCSocket;\n\t\n\t\tmodule.exports.Emitter = __webpack_require__(9);\n\t\n\t\tmodule.exports.connect = function (options) {\n\t\t  return SCSocketCreator.connect(options);\n\t\t};\n\t\n\t\tmodule.exports.destroy = function (options) {\n\t\t  return SCSocketCreator.destroy(options);\n\t\t};\n\t\n\t\tmodule.exports.connections = SCSocketCreator.connections;\n\t\n\t\tmodule.exports.version = '8.0.1';\n\t\n\t\n\t/***/ }),\n\t/* 4 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(global, Buffer) {var Emitter = __webpack_require__(9);\n\t\tvar SCChannel = __webpack_require__(10).SCChannel;\n\t\tvar Response = __webpack_require__(11).Response;\n\t\tvar AuthEngine = __webpack_require__(14).AuthEngine;\n\t\tvar formatter = __webpack_require__(15);\n\t\tvar SCTransport = __webpack_require__(16).SCTransport;\n\t\tvar querystring = __webpack_require__(17);\n\t\tvar LinkedList = __webpack_require__(21);\n\t\tvar base64 = __webpack_require__(23);\n\t\tvar clone = __webpack_require__(25);\n\t\n\t\tvar scErrors = __webpack_require__(12);\n\t\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\t\tvar InvalidMessageError = scErrors.InvalidMessageError;\n\t\tvar SocketProtocolError = scErrors.SocketProtocolError;\n\t\tvar TimeoutError = scErrors.TimeoutError;\n\t\tvar BadConnectionError = scErrors.BadConnectionError;\n\t\n\t\tvar isBrowser = typeof window != 'undefined';\n\t\n\t\n\t\tvar SCSocket = function (opts) {\n\t\t  var self = this;\n\t\n\t\t  Emitter.call(this);\n\t\n\t\t  this.id = null;\n\t\t  this.state = this.CLOSED;\n\t\t  this.authState = this.UNAUTHENTICATED;\n\t\t  this.signedAuthToken = null;\n\t\t  this.authToken = null;\n\t\t  this.pendingReconnect = false;\n\t\t  this.pendingReconnectTimeout = null;\n\t\t  this.preparingPendingSubscriptions = false;\n\t\n\t\t  this.connectTimeout = opts.connectTimeout;\n\t\t  this.ackTimeout = opts.ackTimeout;\n\t\t  this.channelPrefix = opts.channelPrefix || null;\n\t\t  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\n\t\t  this.authTokenName = opts.authTokenName;\n\t\n\t\t  // pingTimeout will be ackTimeout at the start, but it will\n\t\t  // be updated with values provided by the 'connect' event\n\t\t  this.pingTimeout = this.ackTimeout;\n\t\n\t\t  var maxTimeout = Math.pow(2, 31) - 1;\n\t\n\t\t  var verifyDuration = function (propertyName) {\n\t\t    if (self[propertyName] > maxTimeout) {\n\t\t      throw new InvalidArgumentsError('The ' + propertyName +\n\t\t        ' value provided exceeded the maximum amount allowed');\n\t\t    }\n\t\t  };\n\t\n\t\t  verifyDuration('connectTimeout');\n\t\t  verifyDuration('ackTimeout');\n\t\t  verifyDuration('pingTimeout');\n\t\n\t\t  this._localEvents = {\n\t\t    'connect': 1,\n\t\t    'connectAbort': 1,\n\t\t    'disconnect': 1,\n\t\t    'message': 1,\n\t\t    'error': 1,\n\t\t    'raw': 1,\n\t\t    'fail': 1,\n\t\t    'kickOut': 1,\n\t\t    'subscribe': 1,\n\t\t    'unsubscribe': 1,\n\t\t    'subscribeStateChange': 1,\n\t\t    'authStateChange': 1,\n\t\t    'authenticate': 1,\n\t\t    'deauthenticate': 1,\n\t\t    'removeAuthToken': 1,\n\t\t    'subscribeRequest': 1\n\t\t  };\n\t\n\t\t  this.connectAttempts = 0;\n\t\n\t\t  this._emitBuffer = new LinkedList();\n\t\t  this.channels = {};\n\t\n\t\t  this.options = opts;\n\t\n\t\t  this._cid = 1;\n\t\n\t\t  this.options.callIdGenerator = function () {\n\t\t    return self._cid++;\n\t\t  };\n\t\n\t\t  if (this.options.autoReconnect) {\n\t\t    if (this.options.autoReconnectOptions == null) {\n\t\t      this.options.autoReconnectOptions = {};\n\t\t    }\n\t\n\t\t    // Add properties to the this.options.autoReconnectOptions object.\n\t\t    // We assign the reference to a reconnectOptions variable to avoid repetition.\n\t\t    var reconnectOptions = this.options.autoReconnectOptions;\n\t\t    if (reconnectOptions.initialDelay == null) {\n\t\t      reconnectOptions.initialDelay = 10000;\n\t\t    }\n\t\t    if (reconnectOptions.randomness == null) {\n\t\t      reconnectOptions.randomness = 10000;\n\t\t    }\n\t\t    if (reconnectOptions.multiplier == null) {\n\t\t      reconnectOptions.multiplier = 1.5;\n\t\t    }\n\t\t    if (reconnectOptions.maxDelay == null) {\n\t\t      reconnectOptions.maxDelay = 60000;\n\t\t    }\n\t\t  }\n\t\n\t\t  if (this.options.subscriptionRetryOptions == null) {\n\t\t    this.options.subscriptionRetryOptions = {};\n\t\t  }\n\t\n\t\t  if (this.options.authEngine) {\n\t\t    this.auth = this.options.authEngine;\n\t\t  } else {\n\t\t    this.auth = new AuthEngine();\n\t\t  }\n\t\n\t\t  if (this.options.codecEngine) {\n\t\t    this.codec = this.options.codecEngine;\n\t\t  } else {\n\t\t    // Default codec engine\n\t\t    this.codec = formatter;\n\t\t  }\n\t\n\t\t  this.options.path = this.options.path.replace(/\\/$/, '') + '/';\n\t\n\t\t  this.options.query = opts.query || {};\n\t\t  if (typeof this.options.query == 'string') {\n\t\t    this.options.query = querystring.parse(this.options.query);\n\t\t  }\n\t\n\t\t  if (this.options.autoConnect) {\n\t\t    this.connect();\n\t\t  }\n\t\n\t\t  this._channelEmitter = new Emitter();\n\t\n\t\t  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\n\t\t    this._unloadHandler = function () {\n\t\t      self.disconnect();\n\t\t    };\n\t\n\t\t    global.addEventListener('beforeunload', this._unloadHandler, false);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype = Object.create(Emitter.prototype);\n\t\n\t\tSCSocket.CONNECTING = SCSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\n\t\tSCSocket.OPEN = SCSocket.prototype.OPEN = SCTransport.prototype.OPEN;\n\t\tSCSocket.CLOSED = SCSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\n\t\n\t\tSCSocket.AUTHENTICATED = SCSocket.prototype.AUTHENTICATED = 'authenticated';\n\t\tSCSocket.UNAUTHENTICATED = SCSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\n\t\n\t\tSCSocket.PENDING = SCSocket.prototype.PENDING = 'pending';\n\t\n\t\tSCSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\n\t\tSCSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\n\t\n\t\tSCSocket.prototype._privateEventHandlerMap = {\n\t\t  '#publish': function (data) {\n\t\t    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n\t\t    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n\t\n\t\t    if (isSubscribed) {\n\t\t      this._channelEmitter.emit(undecoratedChannelName, data.data);\n\t\t    }\n\t\t  },\n\t\t  '#kickOut': function (data) {\n\t\t    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n\t\t    var channel = this.channels[undecoratedChannelName];\n\t\t    if (channel) {\n\t\t      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\n\t\t      channel.emit('kickOut', data.message, undecoratedChannelName);\n\t\t      this._triggerChannelUnsubscribe(channel);\n\t\t    }\n\t\t  },\n\t\t  '#setAuthToken': function (data, response) {\n\t\t    var self = this;\n\t\n\t\t    if (data) {\n\t\t      var triggerAuthenticate = function (err) {\n\t\t        if (err) {\n\t\t          // This is a non-fatal error, we don't want to close the connection\n\t\t          // because of this but we do want to notify the server and throw an error\n\t\t          // on the client.\n\t\t          response.error(err);\n\t\t          self._onSCError(err);\n\t\t        } else {\n\t\t          self._changeToAuthenticatedState(data.token);\n\t\t          response.end();\n\t\t        }\n\t\t      };\n\t\n\t\t      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\n\t\t    } else {\n\t\t      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\n\t\t    }\n\t\t  },\n\t\t  '#removeAuthToken': function (data, response) {\n\t\t    var self = this;\n\t\n\t\t    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n\t\t      if (err) {\n\t\t        // Non-fatal error - Do not close the connection\n\t\t        response.error(err);\n\t\t        self._onSCError(err);\n\t\t      } else {\n\t\t        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n\t\t        self._changeToUnauthenticatedStateAndClearTokens();\n\t\t        response.end();\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t  '#disconnect': function (data) {\n\t\t    this.transport.close(data.code, data.data);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.getState = function () {\n\t\t  return this.state;\n\t\t};\n\t\n\t\tSCSocket.prototype.getBytesReceived = function () {\n\t\t  return this.transport.getBytesReceived();\n\t\t};\n\t\n\t\tSCSocket.prototype.deauthenticate = function (callback) {\n\t\t  var self = this;\n\t\n\t\t  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n\t\t    if (err) {\n\t\t      // Non-fatal error - Do not close the connection\n\t\t      self._onSCError(err);\n\t\t    } else {\n\t\t      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n\t\t      if (self.state != self.CLOSED) {\n\t\t        self.emit('#removeAuthToken');\n\t\t      }\n\t\t      self._changeToUnauthenticatedStateAndClearTokens();\n\t\t    }\n\t\t    callback && callback(err);\n\t\t  });\n\t\t};\n\t\n\t\tSCSocket.prototype.connect = SCSocket.prototype.open = function () {\n\t\t  var self = this;\n\t\n\t\t  if (this.state == this.CLOSED) {\n\t\t    this.pendingReconnect = false;\n\t\t    this.pendingReconnectTimeout = null;\n\t\t    clearTimeout(this._reconnectTimeoutRef);\n\t\n\t\t    this.state = this.CONNECTING;\n\t\t    Emitter.prototype.emit.call(this, 'connecting');\n\t\n\t\t    if (this.transport) {\n\t\t      this.transport.off();\n\t\t    }\n\t\n\t\t    this.transport = new SCTransport(this.auth, this.codec, this.options);\n\t\n\t\t    this.transport.on('open', function (status) {\n\t\t      self.state = self.OPEN;\n\t\t      self._onSCOpen(status);\n\t\t    });\n\t\n\t\t    this.transport.on('error', function (err) {\n\t\t      self._onSCError(err);\n\t\t    });\n\t\n\t\t    this.transport.on('close', function (code, data) {\n\t\t      self.state = self.CLOSED;\n\t\t      self._onSCClose(code, data);\n\t\t    });\n\t\n\t\t    this.transport.on('openAbort', function (code, data) {\n\t\t      self.state = self.CLOSED;\n\t\t      self._onSCClose(code, data, true);\n\t\t    });\n\t\n\t\t    this.transport.on('event', function (event, data, res) {\n\t\t      self._onSCEvent(event, data, res);\n\t\t    });\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.reconnect = function () {\n\t\t  this.disconnect();\n\t\t  this.connect();\n\t\t};\n\t\n\t\tSCSocket.prototype.disconnect = function (code, data) {\n\t\t  code = code || 1000;\n\t\n\t\t  if (typeof code != 'number') {\n\t\t    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n\t\t  }\n\t\n\t\t  if (this.state == this.OPEN || this.state == this.CONNECTING) {\n\t\t    this.transport.close(code, data);\n\t\t  } else {\n\t\t    this.pendingReconnect = false;\n\t\t    this.pendingReconnectTimeout = null;\n\t\t    clearTimeout(this._reconnectTimeoutRef);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.destroy = function () {\n\t\t  if (this._unloadHandler) {\n\t\t    global.removeEventListener('beforeunload', this._unloadHandler, false);\n\t\t  }\n\t\t  this.disconnect();\n\t\t};\n\t\n\t\tSCSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n\t\t  if (this.authState != this.UNAUTHENTICATED) {\n\t\t    var oldState = this.authState;\n\t\t    this.authState = this.UNAUTHENTICATED;\n\t\t    this.signedAuthToken = null;\n\t\t    this.authToken = null;\n\t\n\t\t    var stateChangeData = {\n\t\t      oldState: oldState,\n\t\t      newState: this.authState\n\t\t    };\n\t\t    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n\t\t    if (oldState == this.AUTHENTICATED) {\n\t\t      Emitter.prototype.emit.call(this, 'deauthenticate');\n\t\t    }\n\t\t    Emitter.prototype.emit.call(this, 'authTokenChange', this.signedAuthToken);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n\t\t  this.signedAuthToken = signedAuthToken;\n\t\t  this.authToken = this._extractAuthTokenData(signedAuthToken);\n\t\n\t\t  if (this.authState != this.AUTHENTICATED) {\n\t\t    var oldState = this.authState;\n\t\t    this.authState = this.AUTHENTICATED;\n\t\t    var stateChangeData = {\n\t\t      oldState: oldState,\n\t\t      newState: this.authState,\n\t\t      signedAuthToken: signedAuthToken,\n\t\t      authToken: this.authToken\n\t\t    };\n\t\t    if (!this.preparingPendingSubscriptions) {\n\t\t      this.processPendingSubscriptions();\n\t\t    }\n\t\n\t\t    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n\t\t    Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\n\t\t  }\n\t\t  Emitter.prototype.emit.call(this, 'authTokenChange', signedAuthToken);\n\t\t};\n\t\n\t\tSCSocket.prototype.decodeBase64 = function (encodedString) {\n\t\t  var decodedString;\n\t\t  if (typeof Buffer == 'undefined') {\n\t\t    if (global.atob) {\n\t\t      decodedString = global.atob(encodedString);\n\t\t    } else {\n\t\t      decodedString = base64.decode(encodedString);\n\t\t    }\n\t\t  } else {\n\t\t    var buffer = new Buffer(encodedString, 'base64');\n\t\t    decodedString = buffer.toString('utf8');\n\t\t  }\n\t\t  return decodedString;\n\t\t};\n\t\n\t\tSCSocket.prototype.encodeBase64 = function (decodedString) {\n\t\t  var encodedString;\n\t\t  if (typeof Buffer == 'undefined') {\n\t\t    if (global.btoa) {\n\t\t      encodedString = global.btoa(decodedString);\n\t\t    } else {\n\t\t      encodedString = base64.encode(decodedString);\n\t\t    }\n\t\t  } else {\n\t\t    var buffer = new Buffer(decodedString, 'utf8');\n\t\t    encodedString = buffer.toString('base64');\n\t\t  }\n\t\t  return encodedString;\n\t\t};\n\t\n\t\tSCSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n\t\t  var tokenParts = (signedAuthToken || '').split('.');\n\t\t  var encodedTokenData = tokenParts[1];\n\t\t  if (encodedTokenData != null) {\n\t\t    var tokenData = encodedTokenData;\n\t\t    try {\n\t\t      tokenData = this.decodeBase64(tokenData);\n\t\t      return JSON.parse(tokenData);\n\t\t    } catch (e) {\n\t\t      return tokenData;\n\t\t    }\n\t\t  }\n\t\t  return null;\n\t\t};\n\t\n\t\tSCSocket.prototype.getAuthToken = function () {\n\t\t  return this.authToken;\n\t\t};\n\t\n\t\tSCSocket.prototype.getSignedAuthToken = function () {\n\t\t  return this.signedAuthToken;\n\t\t};\n\t\n\t\t// Perform client-initiated authentication by providing an encrypted token string.\n\t\tSCSocket.prototype.authenticate = function (signedAuthToken, callback) {\n\t\t  var self = this;\n\t\n\t\t  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\n\t\n\t\t    if (authStatus && authStatus.isAuthenticated != null) {\n\t\t      // If authStatus is correctly formatted (has an isAuthenticated property),\n\t\t      // then we will rehydrate the authError.\n\t\t      if (authStatus.authError) {\n\t\t        authStatus.authError = scErrors.hydrateError(authStatus.authError);\n\t\t      }\n\t\t    } else {\n\t\t      // Some errors like BadConnectionError and TimeoutError will not pass a valid\n\t\t      // authStatus object to the current function, so we need to create it ourselves.\n\t\t      authStatus = {\n\t\t        isAuthenticated: self.authState,\n\t\t        authError: null\n\t\t      };\n\t\t    }\n\t\t    if (err) {\n\t\t      if (err.name != 'BadConnectionError' && err.name != 'TimeoutError') {\n\t\t        // In case of a bad/closed connection or a timeout, we maintain the last\n\t\t        // known auth state since those errors don't mean that the token is invalid.\n\t\n\t\t        self._changeToUnauthenticatedStateAndClearTokens();\n\t\t      }\n\t\t      callback && callback(err, authStatus);\n\t\t    } else {\n\t\t      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\n\t\t        if (err) {\n\t\t          self._onSCError(err);\n\t\t        }\n\t\t        if (authStatus.isAuthenticated) {\n\t\t          self._changeToAuthenticatedState(signedAuthToken);\n\t\t        } else {\n\t\t          self._changeToUnauthenticatedStateAndClearTokens();\n\t\t        }\n\t\t        callback && callback(err, authStatus);\n\t\t      });\n\t\t    }\n\t\t  });\n\t\t};\n\t\n\t\tSCSocket.prototype._tryReconnect = function (initialDelay) {\n\t\t  var self = this;\n\t\n\t\t  var exponent = this.connectAttempts++;\n\t\t  var reconnectOptions = this.options.autoReconnectOptions;\n\t\t  var timeout;\n\t\n\t\t  if (initialDelay == null || exponent > 0) {\n\t\t    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n\t\n\t\t    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n\t\t  } else {\n\t\t    timeout = initialDelay;\n\t\t  }\n\t\n\t\t  if (timeout > reconnectOptions.maxDelay) {\n\t\t    timeout = reconnectOptions.maxDelay;\n\t\t  }\n\t\n\t\t  clearTimeout(this._reconnectTimeoutRef);\n\t\n\t\t  this.pendingReconnect = true;\n\t\t  this.pendingReconnectTimeout = timeout;\n\t\t  this._reconnectTimeoutRef = setTimeout(function () {\n\t\t    self.connect();\n\t\t  }, timeout);\n\t\t};\n\t\n\t\tSCSocket.prototype._onSCOpen = function (status) {\n\t\t  var self = this;\n\t\n\t\t  this.preparingPendingSubscriptions = true;\n\t\n\t\t  if (status) {\n\t\t    this.id = status.id;\n\t\t    this.pingTimeout = status.pingTimeout;\n\t\t    this.transport.pingTimeout = this.pingTimeout;\n\t\t    if (status.isAuthenticated) {\n\t\t      this._changeToAuthenticatedState(status.authToken);\n\t\t    } else {\n\t\t      this._changeToUnauthenticatedStateAndClearTokens();\n\t\t    }\n\t\t  } else {\n\t\t    // This can happen if auth.loadToken (in sctransport.js) fails with\n\t\t    // an error - This means that the signedAuthToken cannot be loaded by\n\t\t    // the auth engine and therefore, we need to unauthenticate the socket.\n\t\t    this._changeToUnauthenticatedStateAndClearTokens();\n\t\t  }\n\t\n\t\t  this.connectAttempts = 0;\n\t\n\t\t  if (this.options.autoSubscribeOnConnect) {\n\t\t    this.processPendingSubscriptions();\n\t\t  }\n\t\n\t\t  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n\t\t  // won't break anything.\n\t\t  Emitter.prototype.emit.call(this, 'connect', status, function () {\n\t\t    self.processPendingSubscriptions();\n\t\t  });\n\t\n\t\t  this._flushEmitBuffer();\n\t\t};\n\t\n\t\tSCSocket.prototype._onSCError = function (err) {\n\t\t  var self = this;\n\t\n\t\t  // Throw error in different stack frame so that error handling\n\t\t  // cannot interfere with a reconnect action.\n\t\t  setTimeout(function () {\n\t\t    if (self.listeners('error').length < 1) {\n\t\t      throw err;\n\t\t    } else {\n\t\t      Emitter.prototype.emit.call(self, 'error', err);\n\t\t    }\n\t\t  }, 0);\n\t\t};\n\t\n\t\tSCSocket.prototype._suspendSubscriptions = function () {\n\t\t  var channel, newState;\n\t\t  for (var channelName in this.channels) {\n\t\t    if (this.channels.hasOwnProperty(channelName)) {\n\t\t      channel = this.channels[channelName];\n\t\t      if (channel.state == channel.SUBSCRIBED ||\n\t\t        channel.state == channel.PENDING) {\n\t\n\t\t        newState = channel.PENDING;\n\t\t      } else {\n\t\t        newState = channel.UNSUBSCRIBED;\n\t\t      }\n\t\n\t\t      this._triggerChannelUnsubscribe(channel, newState);\n\t\t    }\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n\t\t  var currentNode = this._emitBuffer.head;\n\t\t  var nextNode;\n\t\n\t\t  while (currentNode) {\n\t\t    nextNode = currentNode.next;\n\t\t    var eventObject = currentNode.data;\n\t\t    clearTimeout(eventObject.timeout);\n\t\t    delete eventObject.timeout;\n\t\t    currentNode.detach();\n\t\t    currentNode = nextNode;\n\t\n\t\t    var callback = eventObject.callback;\n\t\t    if (callback) {\n\t\t      delete eventObject.callback;\n\t\t      var errorMessage = \"Event '\" + eventObject.event +\n\t\t        \"' was aborted due to a bad connection\";\n\t\t      var error = new BadConnectionError(errorMessage, failureType);\n\t\t      callback.call(eventObject, error, eventObject);\n\t\t    }\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._onSCClose = function (code, data, openAbort) {\n\t\t  var self = this;\n\t\n\t\t  this.id = null;\n\t\n\t\t  if (this.transport) {\n\t\t    this.transport.off();\n\t\t  }\n\t\t  this.pendingReconnect = false;\n\t\t  this.pendingReconnectTimeout = null;\n\t\t  clearTimeout(this._reconnectTimeoutRef);\n\t\n\t\t  this._suspendSubscriptions();\n\t\t  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\t\n\t\t  // Try to reconnect\n\t\t  // on server ping timeout (4000)\n\t\t  // or on client pong timeout (4001)\n\t\t  // or on close without status (1005)\n\t\t  // or on handshake failure (4003)\n\t\t  // or on socket hung up (1006)\n\t\t  if (this.options.autoReconnect) {\n\t\t    if (code == 4000 || code == 4001 || code == 1005) {\n\t\t      // If there is a ping or pong timeout or socket closes without\n\t\t      // status, don't wait before trying to reconnect - These could happen\n\t\t      // if the client wakes up after a period of inactivity and in this case we\n\t\t      // want to re-establish the connection as soon as possible.\n\t\t      this._tryReconnect(0);\n\t\n\t\t      // Codes 4500 and above will be treated as permanent disconnects.\n\t\t      // Socket will not try to auto-reconnect.\n\t\t    } else if (code != 1000 && code < 4500) {\n\t\t      this._tryReconnect();\n\t\t    }\n\t\t  }\n\t\n\t\t  if (openAbort) {\n\t\t    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\n\t\t  } else {\n\t\t    Emitter.prototype.emit.call(self, 'disconnect', code, data);\n\t\t  }\n\t\n\t\t  if (!SCSocket.ignoreStatuses[code]) {\n\t\t    var failureMessage;\n\t\t    if (data) {\n\t\t      failureMessage = 'Socket connection failed: ' + data;\n\t\t    } else {\n\t\t      failureMessage = 'Socket connection failed for unknown reasons';\n\t\t    }\n\t\t    var err = new SocketProtocolError(SCSocket.errorStatuses[code] || failureMessage, code);\n\t\t    this._onSCError(err);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._onSCEvent = function (event, data, res) {\n\t\t  var handler = this._privateEventHandlerMap[event];\n\t\t  if (handler) {\n\t\t    handler.call(this, data, res);\n\t\t  } else {\n\t\t    Emitter.prototype.emit.call(this, event, data, function () {\n\t\t      res && res.callback.apply(res, arguments);\n\t\t    });\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.decode = function (message) {\n\t\t  return this.transport.decode(message);\n\t\t};\n\t\n\t\tSCSocket.prototype.encode = function (object) {\n\t\t  return this.transport.encode(object);\n\t\t};\n\t\n\t\tSCSocket.prototype._flushEmitBuffer = function () {\n\t\t  var currentNode = this._emitBuffer.head;\n\t\t  var nextNode;\n\t\n\t\t  while (currentNode) {\n\t\t    nextNode = currentNode.next;\n\t\t    var eventObject = currentNode.data;\n\t\t    currentNode.detach();\n\t\t    this.transport.emitObject(eventObject);\n\t\t    currentNode = nextNode;\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n\t\t  if (eventNode) {\n\t\t    eventNode.detach();\n\t\t  }\n\t\t  delete eventObject.timeout;\n\t\n\t\t  var callback = eventObject.callback;\n\t\t  if (callback) {\n\t\t    delete eventObject.callback;\n\t\t    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n\t\t    callback.call(eventObject, error, eventObject);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._emit = function (event, data, callback) {\n\t\t  var self = this;\n\t\n\t\t  if (this.state == this.CLOSED) {\n\t\t    this.connect();\n\t\t  }\n\t\t  var eventObject = {\n\t\t    event: event,\n\t\t    callback: callback\n\t\t  };\n\t\n\t\t  var eventNode = new LinkedList.Item();\n\t\n\t\t  if (this.options.cloneData) {\n\t\t    eventObject.data = clone(data);\n\t\t  } else {\n\t\t    eventObject.data = data;\n\t\t  }\n\t\t  eventNode.data = eventObject;\n\t\n\t\t  eventObject.timeout = setTimeout(function () {\n\t\t    self._handleEventAckTimeout(eventObject, eventNode);\n\t\t  }, this.ackTimeout);\n\t\n\t\t  this._emitBuffer.append(eventNode);\n\t\n\t\t  if (this.state == this.OPEN) {\n\t\t    this._flushEmitBuffer();\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.send = function (data) {\n\t\t  this.transport.send(data);\n\t\t};\n\t\n\t\tSCSocket.prototype.emit = function (event, data, callback) {\n\t\t  if (this._localEvents[event] == null) {\n\t\t    this._emit(event, data, callback);\n\t\t  } else {\n\t\t    Emitter.prototype.emit.call(this, event, data);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.publish = function (channelName, data, callback) {\n\t\t  var pubData = {\n\t\t    channel: this._decorateChannelName(channelName),\n\t\t    data: data\n\t\t  };\n\t\t  this.emit('#publish', pubData, callback);\n\t\t};\n\t\n\t\tSCSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n\t\t  var channelName = channel.name;\n\t\n\t\t  if (channel.state != channel.SUBSCRIBED) {\n\t\t    var oldState = channel.state;\n\t\t    channel.state = channel.SUBSCRIBED;\n\t\n\t\t    var stateChangeData = {\n\t\t      channel: channelName,\n\t\t      oldState: oldState,\n\t\t      newState: channel.state,\n\t\t      subscriptionOptions: subscriptionOptions\n\t\t    };\n\t\t    channel.emit('subscribeStateChange', stateChangeData);\n\t\t    channel.emit('subscribe', channelName, subscriptionOptions);\n\t\t    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n\t\t    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n\t\t  var channelName = channel.name;\n\t\t  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\t\n\t\t  if (channel.state != channel.UNSUBSCRIBED && meetsAuthRequirements) {\n\t\t    channel.state = channel.UNSUBSCRIBED;\n\t\n\t\t    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\n\t\t    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\n\t\t  }\n\t\t};\n\t\n\t\t// Cancel any pending subscribe callback\n\t\tSCSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n\t\t  if (channel._pendingSubscriptionCid != null) {\n\t\t    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n\t\t    delete channel._pendingSubscriptionCid;\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._decorateChannelName = function (channelName) {\n\t\t  if (this.channelPrefix) {\n\t\t    channelName = this.channelPrefix + channelName;\n\t\t  }\n\t\t  return channelName;\n\t\t};\n\t\n\t\tSCSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n\t\t  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) == 0) {\n\t\t    return decoratedChannelName.replace(this.channelPrefix, '');\n\t\t  }\n\t\t  return decoratedChannelName;\n\t\t};\n\t\n\t\tSCSocket.prototype._trySubscribe = function (channel) {\n\t\t  var self = this;\n\t\n\t\t  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\t\n\t\t  // We can only ever have one pending subscribe action at any given time on a channel\n\t\t  if (this.state == this.OPEN && !this.preparingPendingSubscriptions &&\n\t\t    channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n\t\n\t\t    var options = {\n\t\t      noTimeout: true\n\t\t    };\n\t\n\t\t    var subscriptionOptions = {\n\t\t      channel: this._decorateChannelName(channel.name)\n\t\t    };\n\t\t    if (channel.waitForAuth) {\n\t\t      options.waitForAuth = true;\n\t\t      subscriptionOptions.waitForAuth = options.waitForAuth;\n\t\t    }\n\t\t    if (channel.data) {\n\t\t      subscriptionOptions.data = channel.data;\n\t\t    }\n\t\t    if (channel.batch) {\n\t\t      options.batch = true;\n\t\t      subscriptionOptions.batch = true;\n\t\t    }\n\t\n\t\t    channel._pendingSubscriptionCid = this.transport.emit(\n\t\t      '#subscribe', subscriptionOptions, options,\n\t\t      function (err) {\n\t\t        delete channel._pendingSubscriptionCid;\n\t\t        if (err) {\n\t\t          self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n\t\t        } else {\n\t\t          self._triggerChannelSubscribe(channel, subscriptionOptions);\n\t\t        }\n\t\t      }\n\t\t    );\n\t\t    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.subscribe = function (channelName, options) {\n\t\t  var channel = this.channels[channelName];\n\t\n\t\t  if (!channel) {\n\t\t    channel = new SCChannel(channelName, this, options);\n\t\t    this.channels[channelName] = channel;\n\t\t  } else if (options) {\n\t\t    channel.setOptions(options);\n\t\t  }\n\t\n\t\t  if (channel.state == channel.UNSUBSCRIBED) {\n\t\t    channel.state = channel.PENDING;\n\t\t    this._trySubscribe(channel);\n\t\t  }\n\t\n\t\t  return channel;\n\t\t};\n\t\n\t\tSCSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\n\t\t  var channelName = channel.name;\n\t\t  var oldState = channel.state;\n\t\n\t\t  if (newState) {\n\t\t    channel.state = newState;\n\t\t  } else {\n\t\t    channel.state = channel.UNSUBSCRIBED;\n\t\t  }\n\t\t  this._cancelPendingSubscribeCallback(channel);\n\t\n\t\t  if (oldState == channel.SUBSCRIBED) {\n\t\t    var stateChangeData = {\n\t\t      channel: channelName,\n\t\t      oldState: oldState,\n\t\t      newState: channel.state\n\t\t    };\n\t\t    channel.emit('subscribeStateChange', stateChangeData);\n\t\t    channel.emit('unsubscribe', channelName);\n\t\t    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n\t\t    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype._tryUnsubscribe = function (channel) {\n\t\t  var self = this;\n\t\n\t\t  if (this.state == this.OPEN) {\n\t\t    var options = {\n\t\t      noTimeout: true\n\t\t    };\n\t\t    if (channel.batch) {\n\t\t      options.batch = true;\n\t\t    }\n\t\t    // If there is a pending subscribe action, cancel the callback\n\t\t    this._cancelPendingSubscribeCallback(channel);\n\t\n\t\t    // This operation cannot fail because the TCP protocol guarantees delivery\n\t\t    // so long as the connection remains open. If the connection closes,\n\t\t    // the server will automatically unsubscribe the socket and thus complete\n\t\t    // the operation on the server side.\n\t\t    var decoratedChannelName = this._decorateChannelName(channel.name);\n\t\t    this.transport.emit('#unsubscribe', decoratedChannelName, options);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.unsubscribe = function (channelName) {\n\t\n\t\t  var channel = this.channels[channelName];\n\t\n\t\t  if (channel) {\n\t\t    if (channel.state != channel.UNSUBSCRIBED) {\n\t\n\t\t      this._triggerChannelUnsubscribe(channel);\n\t\t      this._tryUnsubscribe(channel);\n\t\t    }\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.channel = function (channelName, options) {\n\t\t  var currentChannel = this.channels[channelName];\n\t\n\t\t  if (!currentChannel) {\n\t\t    currentChannel = new SCChannel(channelName, this, options);\n\t\t    this.channels[channelName] = currentChannel;\n\t\t  }\n\t\t  return currentChannel;\n\t\t};\n\t\n\t\tSCSocket.prototype.destroyChannel = function (channelName) {\n\t\t  var channel = this.channels[channelName];\n\t\t  channel.unwatch();\n\t\t  channel.unsubscribe();\n\t\t  delete this.channels[channelName];\n\t\t};\n\t\n\t\tSCSocket.prototype.subscriptions = function (includePending) {\n\t\t  var subs = [];\n\t\t  var channel, includeChannel;\n\t\t  for (var channelName in this.channels) {\n\t\t    if (this.channels.hasOwnProperty(channelName)) {\n\t\t      channel = this.channels[channelName];\n\t\n\t\t      if (includePending) {\n\t\t        includeChannel = channel && (channel.state == channel.SUBSCRIBED ||\n\t\t          channel.state == channel.PENDING);\n\t\t      } else {\n\t\t        includeChannel = channel && channel.state == channel.SUBSCRIBED;\n\t\t      }\n\t\n\t\t      if (includeChannel) {\n\t\t        subs.push(channelName);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return subs;\n\t\t};\n\t\n\t\tSCSocket.prototype.isSubscribed = function (channelName, includePending) {\n\t\t  var channel = this.channels[channelName];\n\t\t  if (includePending) {\n\t\t    return !!channel && (channel.state == channel.SUBSCRIBED ||\n\t\t      channel.state == channel.PENDING);\n\t\t  }\n\t\t  return !!channel && channel.state == channel.SUBSCRIBED;\n\t\t};\n\t\n\t\tSCSocket.prototype.processPendingSubscriptions = function () {\n\t\t  var self = this;\n\t\n\t\t  this.preparingPendingSubscriptions = false;\n\t\n\t\t  var pendingChannels = [];\n\t\n\t\t  for (var i in this.channels) {\n\t\t    if (this.channels.hasOwnProperty(i)) {\n\t\t      var channel = this.channels[i];\n\t\t      if (channel.state == channel.PENDING) {\n\t\t        pendingChannels.push(channel);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  pendingChannels.sort(function (a, b) {\n\t\t    var ap = a.priority || 0;\n\t\t    var bp = b.priority || 0;\n\t\t    if (ap > bp) {\n\t\t      return -1;\n\t\t    }\n\t\t    if (ap < bp) {\n\t\t      return 1;\n\t\t    }\n\t\t    return 0;\n\t\t  });\n\t\n\t\t  pendingChannels.forEach(function (channel) {\n\t\t    self._trySubscribe(channel);\n\t\t  });\n\t\t};\n\t\n\t\tSCSocket.prototype.watch = function (channelName, handler) {\n\t\t  if (typeof handler != 'function') {\n\t\t    throw new InvalidArgumentsError('No handler function was provided');\n\t\t  }\n\t\t  this._channelEmitter.on(channelName, handler);\n\t\t};\n\t\n\t\tSCSocket.prototype.unwatch = function (channelName, handler) {\n\t\t  if (handler) {\n\t\t    this._channelEmitter.removeListener(channelName, handler);\n\t\t  } else {\n\t\t    this._channelEmitter.removeAllListeners(channelName);\n\t\t  }\n\t\t};\n\t\n\t\tSCSocket.prototype.watchers = function (channelName) {\n\t\t  return this._channelEmitter.listeners(channelName);\n\t\t};\n\t\n\t\tmodule.exports = SCSocket;\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5).Buffer))\n\t\n\t/***/ }),\n\t/* 5 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t\t * The buffer module from node.js, for the browser.\n\t\t *\n\t\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t\t * @license  MIT\n\t\t */\n\t\t/* eslint-disable no-proto */\n\t\n\t\t'use strict'\n\t\n\t\tvar base64 = __webpack_require__(6)\n\t\tvar ieee754 = __webpack_require__(7)\n\t\tvar isArray = __webpack_require__(8)\n\t\n\t\texports.Buffer = Buffer\n\t\texports.SlowBuffer = SlowBuffer\n\t\texports.INSPECT_MAX_BYTES = 50\n\t\n\t\t/**\n\t\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t\t *   === true    Use Uint8Array implementation (fastest)\n\t\t *   === false   Use Object implementation (most compatible, even IE6)\n\t\t *\n\t\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t\t * Opera 11.6+, iOS 4.2+.\n\t\t *\n\t\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t\t * when the browser supports typed arrays.\n\t\t *\n\t\t * Note:\n\t\t *\n\t\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t\t *\n\t\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t\t *\n\t\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t\t *     incorrect length in some situations.\n\t\n\t\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t\t * get the Object implementation, which is slower but behaves correctly.\n\t\t */\n\t\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t\t  ? global.TYPED_ARRAY_SUPPORT\n\t\t  : typedArraySupport()\n\t\n\t\t/*\n\t\t * Export kMaxLength after typed array support is determined.\n\t\t */\n\t\texports.kMaxLength = kMaxLength()\n\t\n\t\tfunction typedArraySupport () {\n\t\t  try {\n\t\t    var arr = new Uint8Array(1)\n\t\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t\t  } catch (e) {\n\t\t    return false\n\t\t  }\n\t\t}\n\t\n\t\tfunction kMaxLength () {\n\t\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t\t    ? 0x7fffffff\n\t\t    : 0x3fffffff\n\t\t}\n\t\n\t\tfunction createBuffer (that, length) {\n\t\t  if (kMaxLength() < length) {\n\t\t    throw new RangeError('Invalid typed array length')\n\t\t  }\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    // Return an augmented `Uint8Array` instance, for best performance\n\t\t    that = new Uint8Array(length)\n\t\t    that.__proto__ = Buffer.prototype\n\t\t  } else {\n\t\t    // Fallback: Return an object instance of the Buffer class\n\t\t    if (that === null) {\n\t\t      that = new Buffer(length)\n\t\t    }\n\t\t    that.length = length\n\t\t  }\n\t\n\t\t  return that\n\t\t}\n\t\n\t\t/**\n\t\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t\t * returns a single octet.\n\t\t *\n\t\t * The `Uint8Array` prototype remains unmodified.\n\t\t */\n\t\n\t\tfunction Buffer (arg, encodingOrOffset, length) {\n\t\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t\t    return new Buffer(arg, encodingOrOffset, length)\n\t\t  }\n\t\n\t\t  // Common case.\n\t\t  if (typeof arg === 'number') {\n\t\t    if (typeof encodingOrOffset === 'string') {\n\t\t      throw new Error(\n\t\t        'If encoding is specified then the first argument must be a string'\n\t\t      )\n\t\t    }\n\t\t    return allocUnsafe(this, arg)\n\t\t  }\n\t\t  return from(this, arg, encodingOrOffset, length)\n\t\t}\n\t\n\t\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\t\tBuffer._augment = function (arr) {\n\t\t  arr.__proto__ = Buffer.prototype\n\t\t  return arr\n\t\t}\n\t\n\t\tfunction from (that, value, encodingOrOffset, length) {\n\t\t  if (typeof value === 'number') {\n\t\t    throw new TypeError('\"value\" argument must not be a number')\n\t\t  }\n\t\n\t\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t\t  }\n\t\n\t\t  if (typeof value === 'string') {\n\t\t    return fromString(that, value, encodingOrOffset)\n\t\t  }\n\t\n\t\t  return fromObject(that, value)\n\t\t}\n\t\n\t\t/**\n\t\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t\t * if value is a number.\n\t\t * Buffer.from(str[, encoding])\n\t\t * Buffer.from(array)\n\t\t * Buffer.from(buffer)\n\t\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t\t **/\n\t\tBuffer.from = function (value, encodingOrOffset, length) {\n\t\t  return from(null, value, encodingOrOffset, length)\n\t\t}\n\t\n\t\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t\t  Buffer.__proto__ = Uint8Array\n\t\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t\t      Buffer[Symbol.species] === Buffer) {\n\t\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t\t    Object.defineProperty(Buffer, Symbol.species, {\n\t\t      value: null,\n\t\t      configurable: true\n\t\t    })\n\t\t  }\n\t\t}\n\t\n\t\tfunction assertSize (size) {\n\t\t  if (typeof size !== 'number') {\n\t\t    throw new TypeError('\"size\" argument must be a number')\n\t\t  } else if (size < 0) {\n\t\t    throw new RangeError('\"size\" argument must not be negative')\n\t\t  }\n\t\t}\n\t\n\t\tfunction alloc (that, size, fill, encoding) {\n\t\t  assertSize(size)\n\t\t  if (size <= 0) {\n\t\t    return createBuffer(that, size)\n\t\t  }\n\t\t  if (fill !== undefined) {\n\t\t    // Only pay attention to encoding if it's a string. This\n\t\t    // prevents accidentally sending in a number that would\n\t\t    // be interpretted as a start offset.\n\t\t    return typeof encoding === 'string'\n\t\t      ? createBuffer(that, size).fill(fill, encoding)\n\t\t      : createBuffer(that, size).fill(fill)\n\t\t  }\n\t\t  return createBuffer(that, size)\n\t\t}\n\t\n\t\t/**\n\t\t * Creates a new filled Buffer instance.\n\t\t * alloc(size[, fill[, encoding]])\n\t\t **/\n\t\tBuffer.alloc = function (size, fill, encoding) {\n\t\t  return alloc(null, size, fill, encoding)\n\t\t}\n\t\n\t\tfunction allocUnsafe (that, size) {\n\t\t  assertSize(size)\n\t\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    for (var i = 0; i < size; ++i) {\n\t\t      that[i] = 0\n\t\t    }\n\t\t  }\n\t\t  return that\n\t\t}\n\t\n\t\t/**\n\t\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t\t * */\n\t\tBuffer.allocUnsafe = function (size) {\n\t\t  return allocUnsafe(null, size)\n\t\t}\n\t\t/**\n\t\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t\t */\n\t\tBuffer.allocUnsafeSlow = function (size) {\n\t\t  return allocUnsafe(null, size)\n\t\t}\n\t\n\t\tfunction fromString (that, string, encoding) {\n\t\t  if (typeof encoding !== 'string' || encoding === '') {\n\t\t    encoding = 'utf8'\n\t\t  }\n\t\n\t\t  if (!Buffer.isEncoding(encoding)) {\n\t\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t\t  }\n\t\n\t\t  var length = byteLength(string, encoding) | 0\n\t\t  that = createBuffer(that, length)\n\t\n\t\t  var actual = that.write(string, encoding)\n\t\n\t\t  if (actual !== length) {\n\t\t    // Writing a hex string, for example, that contains invalid characters will\n\t\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t\t    // 'abxxcd' will be treated as 'ab')\n\t\t    that = that.slice(0, actual)\n\t\t  }\n\t\n\t\t  return that\n\t\t}\n\t\n\t\tfunction fromArrayLike (that, array) {\n\t\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t\t  that = createBuffer(that, length)\n\t\t  for (var i = 0; i < length; i += 1) {\n\t\t    that[i] = array[i] & 255\n\t\t  }\n\t\t  return that\n\t\t}\n\t\n\t\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t\t  }\n\t\n\t\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t\t    throw new RangeError('\\'length\\' is out of bounds')\n\t\t  }\n\t\n\t\t  if (byteOffset === undefined && length === undefined) {\n\t\t    array = new Uint8Array(array)\n\t\t  } else if (length === undefined) {\n\t\t    array = new Uint8Array(array, byteOffset)\n\t\t  } else {\n\t\t    array = new Uint8Array(array, byteOffset, length)\n\t\t  }\n\t\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    // Return an augmented `Uint8Array` instance, for best performance\n\t\t    that = array\n\t\t    that.__proto__ = Buffer.prototype\n\t\t  } else {\n\t\t    // Fallback: Return an object instance of the Buffer class\n\t\t    that = fromArrayLike(that, array)\n\t\t  }\n\t\t  return that\n\t\t}\n\t\n\t\tfunction fromObject (that, obj) {\n\t\t  if (Buffer.isBuffer(obj)) {\n\t\t    var len = checked(obj.length) | 0\n\t\t    that = createBuffer(that, len)\n\t\n\t\t    if (that.length === 0) {\n\t\t      return that\n\t\t    }\n\t\n\t\t    obj.copy(that, 0, 0, len)\n\t\t    return that\n\t\t  }\n\t\n\t\t  if (obj) {\n\t\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t\t        return createBuffer(that, 0)\n\t\t      }\n\t\t      return fromArrayLike(that, obj)\n\t\t    }\n\t\n\t\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t\t      return fromArrayLike(that, obj.data)\n\t\t    }\n\t\t  }\n\t\n\t\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t\t}\n\t\n\t\tfunction checked (length) {\n\t\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t\t  // length is NaN (which is otherwise coerced to zero.)\n\t\t  if (length >= kMaxLength()) {\n\t\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t\t  }\n\t\t  return length | 0\n\t\t}\n\t\n\t\tfunction SlowBuffer (length) {\n\t\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t\t    length = 0\n\t\t  }\n\t\t  return Buffer.alloc(+length)\n\t\t}\n\t\n\t\tBuffer.isBuffer = function isBuffer (b) {\n\t\t  return !!(b != null && b._isBuffer)\n\t\t}\n\t\n\t\tBuffer.compare = function compare (a, b) {\n\t\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t\t    throw new TypeError('Arguments must be Buffers')\n\t\t  }\n\t\n\t\t  if (a === b) return 0\n\t\n\t\t  var x = a.length\n\t\t  var y = b.length\n\t\n\t\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t\t    if (a[i] !== b[i]) {\n\t\t      x = a[i]\n\t\t      y = b[i]\n\t\t      break\n\t\t    }\n\t\t  }\n\t\n\t\t  if (x < y) return -1\n\t\t  if (y < x) return 1\n\t\t  return 0\n\t\t}\n\t\n\t\tBuffer.isEncoding = function isEncoding (encoding) {\n\t\t  switch (String(encoding).toLowerCase()) {\n\t\t    case 'hex':\n\t\t    case 'utf8':\n\t\t    case 'utf-8':\n\t\t    case 'ascii':\n\t\t    case 'latin1':\n\t\t    case 'binary':\n\t\t    case 'base64':\n\t\t    case 'ucs2':\n\t\t    case 'ucs-2':\n\t\t    case 'utf16le':\n\t\t    case 'utf-16le':\n\t\t      return true\n\t\t    default:\n\t\t      return false\n\t\t  }\n\t\t}\n\t\n\t\tBuffer.concat = function concat (list, length) {\n\t\t  if (!isArray(list)) {\n\t\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t\t  }\n\t\n\t\t  if (list.length === 0) {\n\t\t    return Buffer.alloc(0)\n\t\t  }\n\t\n\t\t  var i\n\t\t  if (length === undefined) {\n\t\t    length = 0\n\t\t    for (i = 0; i < list.length; ++i) {\n\t\t      length += list[i].length\n\t\t    }\n\t\t  }\n\t\n\t\t  var buffer = Buffer.allocUnsafe(length)\n\t\t  var pos = 0\n\t\t  for (i = 0; i < list.length; ++i) {\n\t\t    var buf = list[i]\n\t\t    if (!Buffer.isBuffer(buf)) {\n\t\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t\t    }\n\t\t    buf.copy(buffer, pos)\n\t\t    pos += buf.length\n\t\t  }\n\t\t  return buffer\n\t\t}\n\t\n\t\tfunction byteLength (string, encoding) {\n\t\t  if (Buffer.isBuffer(string)) {\n\t\t    return string.length\n\t\t  }\n\t\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t\t    return string.byteLength\n\t\t  }\n\t\t  if (typeof string !== 'string') {\n\t\t    string = '' + string\n\t\t  }\n\t\n\t\t  var len = string.length\n\t\t  if (len === 0) return 0\n\t\n\t\t  // Use a for loop to avoid recursion\n\t\t  var loweredCase = false\n\t\t  for (;;) {\n\t\t    switch (encoding) {\n\t\t      case 'ascii':\n\t\t      case 'latin1':\n\t\t      case 'binary':\n\t\t        return len\n\t\t      case 'utf8':\n\t\t      case 'utf-8':\n\t\t      case undefined:\n\t\t        return utf8ToBytes(string).length\n\t\t      case 'ucs2':\n\t\t      case 'ucs-2':\n\t\t      case 'utf16le':\n\t\t      case 'utf-16le':\n\t\t        return len * 2\n\t\t      case 'hex':\n\t\t        return len >>> 1\n\t\t      case 'base64':\n\t\t        return base64ToBytes(string).length\n\t\t      default:\n\t\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t\t        encoding = ('' + encoding).toLowerCase()\n\t\t        loweredCase = true\n\t\t    }\n\t\t  }\n\t\t}\n\t\tBuffer.byteLength = byteLength\n\t\n\t\tfunction slowToString (encoding, start, end) {\n\t\t  var loweredCase = false\n\t\n\t\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t\t  // property of a typed array.\n\t\n\t\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t\t  // to their upper/lower bounds if the value passed is out of range.\n\t\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t\t  if (start === undefined || start < 0) {\n\t\t    start = 0\n\t\t  }\n\t\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t\t  // coercion fail below.\n\t\t  if (start > this.length) {\n\t\t    return ''\n\t\t  }\n\t\n\t\t  if (end === undefined || end > this.length) {\n\t\t    end = this.length\n\t\t  }\n\t\n\t\t  if (end <= 0) {\n\t\t    return ''\n\t\t  }\n\t\n\t\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t\t  end >>>= 0\n\t\t  start >>>= 0\n\t\n\t\t  if (end <= start) {\n\t\t    return ''\n\t\t  }\n\t\n\t\t  if (!encoding) encoding = 'utf8'\n\t\n\t\t  while (true) {\n\t\t    switch (encoding) {\n\t\t      case 'hex':\n\t\t        return hexSlice(this, start, end)\n\t\n\t\t      case 'utf8':\n\t\t      case 'utf-8':\n\t\t        return utf8Slice(this, start, end)\n\t\n\t\t      case 'ascii':\n\t\t        return asciiSlice(this, start, end)\n\t\n\t\t      case 'latin1':\n\t\t      case 'binary':\n\t\t        return latin1Slice(this, start, end)\n\t\n\t\t      case 'base64':\n\t\t        return base64Slice(this, start, end)\n\t\n\t\t      case 'ucs2':\n\t\t      case 'ucs-2':\n\t\t      case 'utf16le':\n\t\t      case 'utf-16le':\n\t\t        return utf16leSlice(this, start, end)\n\t\n\t\t      default:\n\t\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t\t        encoding = (encoding + '').toLowerCase()\n\t\t        loweredCase = true\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t\t// Buffer instances.\n\t\tBuffer.prototype._isBuffer = true\n\t\n\t\tfunction swap (b, n, m) {\n\t\t  var i = b[n]\n\t\t  b[n] = b[m]\n\t\t  b[m] = i\n\t\t}\n\t\n\t\tBuffer.prototype.swap16 = function swap16 () {\n\t\t  var len = this.length\n\t\t  if (len % 2 !== 0) {\n\t\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t\t  }\n\t\t  for (var i = 0; i < len; i += 2) {\n\t\t    swap(this, i, i + 1)\n\t\t  }\n\t\t  return this\n\t\t}\n\t\n\t\tBuffer.prototype.swap32 = function swap32 () {\n\t\t  var len = this.length\n\t\t  if (len % 4 !== 0) {\n\t\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t\t  }\n\t\t  for (var i = 0; i < len; i += 4) {\n\t\t    swap(this, i, i + 3)\n\t\t    swap(this, i + 1, i + 2)\n\t\t  }\n\t\t  return this\n\t\t}\n\t\n\t\tBuffer.prototype.swap64 = function swap64 () {\n\t\t  var len = this.length\n\t\t  if (len % 8 !== 0) {\n\t\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t\t  }\n\t\t  for (var i = 0; i < len; i += 8) {\n\t\t    swap(this, i, i + 7)\n\t\t    swap(this, i + 1, i + 6)\n\t\t    swap(this, i + 2, i + 5)\n\t\t    swap(this, i + 3, i + 4)\n\t\t  }\n\t\t  return this\n\t\t}\n\t\n\t\tBuffer.prototype.toString = function toString () {\n\t\t  var length = this.length | 0\n\t\t  if (length === 0) return ''\n\t\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t\t  return slowToString.apply(this, arguments)\n\t\t}\n\t\n\t\tBuffer.prototype.equals = function equals (b) {\n\t\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t\t  if (this === b) return true\n\t\t  return Buffer.compare(this, b) === 0\n\t\t}\n\t\n\t\tBuffer.prototype.inspect = function inspect () {\n\t\t  var str = ''\n\t\t  var max = exports.INSPECT_MAX_BYTES\n\t\t  if (this.length > 0) {\n\t\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t\t    if (this.length > max) str += ' ... '\n\t\t  }\n\t\t  return '<Buffer ' + str + '>'\n\t\t}\n\t\n\t\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t\t  if (!Buffer.isBuffer(target)) {\n\t\t    throw new TypeError('Argument must be a Buffer')\n\t\t  }\n\t\n\t\t  if (start === undefined) {\n\t\t    start = 0\n\t\t  }\n\t\t  if (end === undefined) {\n\t\t    end = target ? target.length : 0\n\t\t  }\n\t\t  if (thisStart === undefined) {\n\t\t    thisStart = 0\n\t\t  }\n\t\t  if (thisEnd === undefined) {\n\t\t    thisEnd = this.length\n\t\t  }\n\t\n\t\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t\t    throw new RangeError('out of range index')\n\t\t  }\n\t\n\t\t  if (thisStart >= thisEnd && start >= end) {\n\t\t    return 0\n\t\t  }\n\t\t  if (thisStart >= thisEnd) {\n\t\t    return -1\n\t\t  }\n\t\t  if (start >= end) {\n\t\t    return 1\n\t\t  }\n\t\n\t\t  start >>>= 0\n\t\t  end >>>= 0\n\t\t  thisStart >>>= 0\n\t\t  thisEnd >>>= 0\n\t\n\t\t  if (this === target) return 0\n\t\n\t\t  var x = thisEnd - thisStart\n\t\t  var y = end - start\n\t\t  var len = Math.min(x, y)\n\t\n\t\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t\t  var targetCopy = target.slice(start, end)\n\t\n\t\t  for (var i = 0; i < len; ++i) {\n\t\t    if (thisCopy[i] !== targetCopy[i]) {\n\t\t      x = thisCopy[i]\n\t\t      y = targetCopy[i]\n\t\t      break\n\t\t    }\n\t\t  }\n\t\n\t\t  if (x < y) return -1\n\t\t  if (y < x) return 1\n\t\t  return 0\n\t\t}\n\t\n\t\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t\t//\n\t\t// Arguments:\n\t\t// - buffer - a Buffer to search\n\t\t// - val - a string, Buffer, or number\n\t\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t\t// - encoding - an optional encoding, relevant is val is a string\n\t\t// - dir - true for indexOf, false for lastIndexOf\n\t\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t\t  // Empty buffer means no match\n\t\t  if (buffer.length === 0) return -1\n\t\n\t\t  // Normalize byteOffset\n\t\t  if (typeof byteOffset === 'string') {\n\t\t    encoding = byteOffset\n\t\t    byteOffset = 0\n\t\t  } else if (byteOffset > 0x7fffffff) {\n\t\t    byteOffset = 0x7fffffff\n\t\t  } else if (byteOffset < -0x80000000) {\n\t\t    byteOffset = -0x80000000\n\t\t  }\n\t\t  byteOffset = +byteOffset  // Coerce to Number.\n\t\t  if (isNaN(byteOffset)) {\n\t\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t\t  }\n\t\n\t\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t\t  if (byteOffset >= buffer.length) {\n\t\t    if (dir) return -1\n\t\t    else byteOffset = buffer.length - 1\n\t\t  } else if (byteOffset < 0) {\n\t\t    if (dir) byteOffset = 0\n\t\t    else return -1\n\t\t  }\n\t\n\t\t  // Normalize val\n\t\t  if (typeof val === 'string') {\n\t\t    val = Buffer.from(val, encoding)\n\t\t  }\n\t\n\t\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t\t  if (Buffer.isBuffer(val)) {\n\t\t    // Special case: looking for empty string/buffer always fails\n\t\t    if (val.length === 0) {\n\t\t      return -1\n\t\t    }\n\t\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t\t  } else if (typeof val === 'number') {\n\t\t    val = val & 0xFF // Search for a byte value [0-255]\n\t\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t\t      if (dir) {\n\t\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t\t      } else {\n\t\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t\t      }\n\t\t    }\n\t\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t\t  }\n\t\n\t\t  throw new TypeError('val must be string, number or Buffer')\n\t\t}\n\t\n\t\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t\t  var indexSize = 1\n\t\t  var arrLength = arr.length\n\t\t  var valLength = val.length\n\t\n\t\t  if (encoding !== undefined) {\n\t\t    encoding = String(encoding).toLowerCase()\n\t\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t\t      if (arr.length < 2 || val.length < 2) {\n\t\t        return -1\n\t\t      }\n\t\t      indexSize = 2\n\t\t      arrLength /= 2\n\t\t      valLength /= 2\n\t\t      byteOffset /= 2\n\t\t    }\n\t\t  }\n\t\n\t\t  function read (buf, i) {\n\t\t    if (indexSize === 1) {\n\t\t      return buf[i]\n\t\t    } else {\n\t\t      return buf.readUInt16BE(i * indexSize)\n\t\t    }\n\t\t  }\n\t\n\t\t  var i\n\t\t  if (dir) {\n\t\t    var foundIndex = -1\n\t\t    for (i = byteOffset; i < arrLength; i++) {\n\t\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t\t        if (foundIndex === -1) foundIndex = i\n\t\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t\t      } else {\n\t\t        if (foundIndex !== -1) i -= i - foundIndex\n\t\t        foundIndex = -1\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t\t    for (i = byteOffset; i >= 0; i--) {\n\t\t      var found = true\n\t\t      for (var j = 0; j < valLength; j++) {\n\t\t        if (read(arr, i + j) !== read(val, j)) {\n\t\t          found = false\n\t\t          break\n\t\t        }\n\t\t      }\n\t\t      if (found) return i\n\t\t    }\n\t\t  }\n\t\n\t\t  return -1\n\t\t}\n\t\n\t\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t\t}\n\t\n\t\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t\t}\n\t\n\t\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t\t}\n\t\n\t\tfunction hexWrite (buf, string, offset, length) {\n\t\t  offset = Number(offset) || 0\n\t\t  var remaining = buf.length - offset\n\t\t  if (!length) {\n\t\t    length = remaining\n\t\t  } else {\n\t\t    length = Number(length)\n\t\t    if (length > remaining) {\n\t\t      length = remaining\n\t\t    }\n\t\t  }\n\t\n\t\t  // must be an even number of digits\n\t\t  var strLen = string.length\n\t\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t\t  if (length > strLen / 2) {\n\t\t    length = strLen / 2\n\t\t  }\n\t\t  for (var i = 0; i < length; ++i) {\n\t\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t\t    if (isNaN(parsed)) return i\n\t\t    buf[offset + i] = parsed\n\t\t  }\n\t\t  return i\n\t\t}\n\t\n\t\tfunction utf8Write (buf, string, offset, length) {\n\t\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t\t}\n\t\n\t\tfunction asciiWrite (buf, string, offset, length) {\n\t\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t\t}\n\t\n\t\tfunction latin1Write (buf, string, offset, length) {\n\t\t  return asciiWrite(buf, string, offset, length)\n\t\t}\n\t\n\t\tfunction base64Write (buf, string, offset, length) {\n\t\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t\t}\n\t\n\t\tfunction ucs2Write (buf, string, offset, length) {\n\t\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t\t}\n\t\n\t\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t\t  // Buffer#write(string)\n\t\t  if (offset === undefined) {\n\t\t    encoding = 'utf8'\n\t\t    length = this.length\n\t\t    offset = 0\n\t\t  // Buffer#write(string, encoding)\n\t\t  } else if (length === undefined && typeof offset === 'string') {\n\t\t    encoding = offset\n\t\t    length = this.length\n\t\t    offset = 0\n\t\t  // Buffer#write(string, offset[, length][, encoding])\n\t\t  } else if (isFinite(offset)) {\n\t\t    offset = offset | 0\n\t\t    if (isFinite(length)) {\n\t\t      length = length | 0\n\t\t      if (encoding === undefined) encoding = 'utf8'\n\t\t    } else {\n\t\t      encoding = length\n\t\t      length = undefined\n\t\t    }\n\t\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t\t  } else {\n\t\t    throw new Error(\n\t\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t\t    )\n\t\t  }\n\t\n\t\t  var remaining = this.length - offset\n\t\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t\t  }\n\t\n\t\t  if (!encoding) encoding = 'utf8'\n\t\n\t\t  var loweredCase = false\n\t\t  for (;;) {\n\t\t    switch (encoding) {\n\t\t      case 'hex':\n\t\t        return hexWrite(this, string, offset, length)\n\t\n\t\t      case 'utf8':\n\t\t      case 'utf-8':\n\t\t        return utf8Write(this, string, offset, length)\n\t\n\t\t      case 'ascii':\n\t\t        return asciiWrite(this, string, offset, length)\n\t\n\t\t      case 'latin1':\n\t\t      case 'binary':\n\t\t        return latin1Write(this, string, offset, length)\n\t\n\t\t      case 'base64':\n\t\t        // Warning: maxLength not taken into account in base64Write\n\t\t        return base64Write(this, string, offset, length)\n\t\n\t\t      case 'ucs2':\n\t\t      case 'ucs-2':\n\t\t      case 'utf16le':\n\t\t      case 'utf-16le':\n\t\t        return ucs2Write(this, string, offset, length)\n\t\n\t\t      default:\n\t\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t\t        encoding = ('' + encoding).toLowerCase()\n\t\t        loweredCase = true\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\tBuffer.prototype.toJSON = function toJSON () {\n\t\t  return {\n\t\t    type: 'Buffer',\n\t\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t\t  }\n\t\t}\n\t\n\t\tfunction base64Slice (buf, start, end) {\n\t\t  if (start === 0 && end === buf.length) {\n\t\t    return base64.fromByteArray(buf)\n\t\t  } else {\n\t\t    return base64.fromByteArray(buf.slice(start, end))\n\t\t  }\n\t\t}\n\t\n\t\tfunction utf8Slice (buf, start, end) {\n\t\t  end = Math.min(buf.length, end)\n\t\t  var res = []\n\t\n\t\t  var i = start\n\t\t  while (i < end) {\n\t\t    var firstByte = buf[i]\n\t\t    var codePoint = null\n\t\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t\t      : (firstByte > 0xDF) ? 3\n\t\t      : (firstByte > 0xBF) ? 2\n\t\t      : 1\n\t\n\t\t    if (i + bytesPerSequence <= end) {\n\t\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t\t      switch (bytesPerSequence) {\n\t\t        case 1:\n\t\t          if (firstByte < 0x80) {\n\t\t            codePoint = firstByte\n\t\t          }\n\t\t          break\n\t\t        case 2:\n\t\t          secondByte = buf[i + 1]\n\t\t          if ((secondByte & 0xC0) === 0x80) {\n\t\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t\t            if (tempCodePoint > 0x7F) {\n\t\t              codePoint = tempCodePoint\n\t\t            }\n\t\t          }\n\t\t          break\n\t\t        case 3:\n\t\t          secondByte = buf[i + 1]\n\t\t          thirdByte = buf[i + 2]\n\t\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t\t              codePoint = tempCodePoint\n\t\t            }\n\t\t          }\n\t\t          break\n\t\t        case 4:\n\t\t          secondByte = buf[i + 1]\n\t\t          thirdByte = buf[i + 2]\n\t\t          fourthByte = buf[i + 3]\n\t\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t\t              codePoint = tempCodePoint\n\t\t            }\n\t\t          }\n\t\t      }\n\t\t    }\n\t\n\t\t    if (codePoint === null) {\n\t\t      // we did not generate a valid codePoint so insert a\n\t\t      // replacement char (U+FFFD) and advance only 1 byte\n\t\t      codePoint = 0xFFFD\n\t\t      bytesPerSequence = 1\n\t\t    } else if (codePoint > 0xFFFF) {\n\t\t      // encode to utf16 (surrogate pair dance)\n\t\t      codePoint -= 0x10000\n\t\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t\t    }\n\t\n\t\t    res.push(codePoint)\n\t\t    i += bytesPerSequence\n\t\t  }\n\t\n\t\t  return decodeCodePointsArray(res)\n\t\t}\n\t\n\t\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t\t// the lowest limit is Chrome, with 0x10000 args.\n\t\t// We go 1 magnitude less, for safety\n\t\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\t\tfunction decodeCodePointsArray (codePoints) {\n\t\t  var len = codePoints.length\n\t\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t\t  }\n\t\n\t\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t\t  var res = ''\n\t\t  var i = 0\n\t\t  while (i < len) {\n\t\t    res += String.fromCharCode.apply(\n\t\t      String,\n\t\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t\t    )\n\t\t  }\n\t\t  return res\n\t\t}\n\t\n\t\tfunction asciiSlice (buf, start, end) {\n\t\t  var ret = ''\n\t\t  end = Math.min(buf.length, end)\n\t\n\t\t  for (var i = start; i < end; ++i) {\n\t\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t\t  }\n\t\t  return ret\n\t\t}\n\t\n\t\tfunction latin1Slice (buf, start, end) {\n\t\t  var ret = ''\n\t\t  end = Math.min(buf.length, end)\n\t\n\t\t  for (var i = start; i < end; ++i) {\n\t\t    ret += String.fromCharCode(buf[i])\n\t\t  }\n\t\t  return ret\n\t\t}\n\t\n\t\tfunction hexSlice (buf, start, end) {\n\t\t  var len = buf.length\n\t\n\t\t  if (!start || start < 0) start = 0\n\t\t  if (!end || end < 0 || end > len) end = len\n\t\n\t\t  var out = ''\n\t\t  for (var i = start; i < end; ++i) {\n\t\t    out += toHex(buf[i])\n\t\t  }\n\t\t  return out\n\t\t}\n\t\n\t\tfunction utf16leSlice (buf, start, end) {\n\t\t  var bytes = buf.slice(start, end)\n\t\t  var res = ''\n\t\t  for (var i = 0; i < bytes.length; i += 2) {\n\t\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t\t  }\n\t\t  return res\n\t\t}\n\t\n\t\tBuffer.prototype.slice = function slice (start, end) {\n\t\t  var len = this.length\n\t\t  start = ~~start\n\t\t  end = end === undefined ? len : ~~end\n\t\n\t\t  if (start < 0) {\n\t\t    start += len\n\t\t    if (start < 0) start = 0\n\t\t  } else if (start > len) {\n\t\t    start = len\n\t\t  }\n\t\n\t\t  if (end < 0) {\n\t\t    end += len\n\t\t    if (end < 0) end = 0\n\t\t  } else if (end > len) {\n\t\t    end = len\n\t\t  }\n\t\n\t\t  if (end < start) end = start\n\t\n\t\t  var newBuf\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    newBuf = this.subarray(start, end)\n\t\t    newBuf.__proto__ = Buffer.prototype\n\t\t  } else {\n\t\t    var sliceLen = end - start\n\t\t    newBuf = new Buffer(sliceLen, undefined)\n\t\t    for (var i = 0; i < sliceLen; ++i) {\n\t\t      newBuf[i] = this[i + start]\n\t\t    }\n\t\t  }\n\t\n\t\t  return newBuf\n\t\t}\n\t\n\t\t/*\n\t\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t\t */\n\t\tfunction checkOffset (offset, ext, length) {\n\t\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t\t}\n\t\n\t\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t\t  offset = offset | 0\n\t\t  byteLength = byteLength | 0\n\t\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t\t  var val = this[offset]\n\t\t  var mul = 1\n\t\t  var i = 0\n\t\t  while (++i < byteLength && (mul *= 0x100)) {\n\t\t    val += this[offset + i] * mul\n\t\t  }\n\t\n\t\t  return val\n\t\t}\n\t\n\t\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t\t  offset = offset | 0\n\t\t  byteLength = byteLength | 0\n\t\t  if (!noAssert) {\n\t\t    checkOffset(offset, byteLength, this.length)\n\t\t  }\n\t\n\t\t  var val = this[offset + --byteLength]\n\t\t  var mul = 1\n\t\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t\t    val += this[offset + --byteLength] * mul\n\t\t  }\n\t\n\t\t  return val\n\t\t}\n\t\n\t\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t\t  return this[offset]\n\t\t}\n\t\n\t\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t\t  return this[offset] | (this[offset + 1] << 8)\n\t\t}\n\t\n\t\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t\t  return (this[offset] << 8) | this[offset + 1]\n\t\t}\n\t\n\t\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t\t  return ((this[offset]) |\n\t\t      (this[offset + 1] << 8) |\n\t\t      (this[offset + 2] << 16)) +\n\t\t      (this[offset + 3] * 0x1000000)\n\t\t}\n\t\n\t\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t\t  return (this[offset] * 0x1000000) +\n\t\t    ((this[offset + 1] << 16) |\n\t\t    (this[offset + 2] << 8) |\n\t\t    this[offset + 3])\n\t\t}\n\t\n\t\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t\t  offset = offset | 0\n\t\t  byteLength = byteLength | 0\n\t\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t\t  var val = this[offset]\n\t\t  var mul = 1\n\t\t  var i = 0\n\t\t  while (++i < byteLength && (mul *= 0x100)) {\n\t\t    val += this[offset + i] * mul\n\t\t  }\n\t\t  mul *= 0x80\n\t\n\t\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t\t  return val\n\t\t}\n\t\n\t\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t\t  offset = offset | 0\n\t\t  byteLength = byteLength | 0\n\t\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t\t  var i = byteLength\n\t\t  var mul = 1\n\t\t  var val = this[offset + --i]\n\t\t  while (i > 0 && (mul *= 0x100)) {\n\t\t    val += this[offset + --i] * mul\n\t\t  }\n\t\t  mul *= 0x80\n\t\n\t\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t\t  return val\n\t\t}\n\t\n\t\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t\t  return ((0xff - this[offset] + 1) * -1)\n\t\t}\n\t\n\t\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t\t  var val = this[offset] | (this[offset + 1] << 8)\n\t\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t\t}\n\t\n\t\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t\t  var val = this[offset + 1] | (this[offset] << 8)\n\t\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t\t}\n\t\n\t\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t\t  return (this[offset]) |\n\t\t    (this[offset + 1] << 8) |\n\t\t    (this[offset + 2] << 16) |\n\t\t    (this[offset + 3] << 24)\n\t\t}\n\t\n\t\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t\t  return (this[offset] << 24) |\n\t\t    (this[offset + 1] << 16) |\n\t\t    (this[offset + 2] << 8) |\n\t\t    (this[offset + 3])\n\t\t}\n\t\n\t\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\t  return ieee754.read(this, offset, true, 23, 4)\n\t\t}\n\t\n\t\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\t  return ieee754.read(this, offset, false, 23, 4)\n\t\t}\n\t\n\t\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t\t  return ieee754.read(this, offset, true, 52, 8)\n\t\t}\n\t\n\t\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t\t  return ieee754.read(this, offset, false, 52, 8)\n\t\t}\n\t\n\t\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t\t}\n\t\n\t\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  byteLength = byteLength | 0\n\t\t  if (!noAssert) {\n\t\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t\t  }\n\t\n\t\t  var mul = 1\n\t\t  var i = 0\n\t\t  this[offset] = value & 0xFF\n\t\t  while (++i < byteLength && (mul *= 0x100)) {\n\t\t    this[offset + i] = (value / mul) & 0xFF\n\t\t  }\n\t\n\t\t  return offset + byteLength\n\t\t}\n\t\n\t\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  byteLength = byteLength | 0\n\t\t  if (!noAssert) {\n\t\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t\t  }\n\t\n\t\t  var i = byteLength - 1\n\t\t  var mul = 1\n\t\t  this[offset + i] = value & 0xFF\n\t\t  while (--i >= 0 && (mul *= 0x100)) {\n\t\t    this[offset + i] = (value / mul) & 0xFF\n\t\t  }\n\t\n\t\t  return offset + byteLength\n\t\t}\n\t\n\t\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t\t  this[offset] = (value & 0xff)\n\t\t  return offset + 1\n\t\t}\n\t\n\t\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t\t  if (value < 0) value = 0xffff + value + 1\n\t\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t\t      (littleEndian ? i : 1 - i) * 8\n\t\t  }\n\t\t}\n\t\n\t\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value & 0xff)\n\t\t    this[offset + 1] = (value >>> 8)\n\t\t  } else {\n\t\t    objectWriteUInt16(this, value, offset, true)\n\t\t  }\n\t\t  return offset + 2\n\t\t}\n\t\n\t\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value >>> 8)\n\t\t    this[offset + 1] = (value & 0xff)\n\t\t  } else {\n\t\t    objectWriteUInt16(this, value, offset, false)\n\t\t  }\n\t\t  return offset + 2\n\t\t}\n\t\n\t\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t\t  if (value < 0) value = 0xffffffff + value + 1\n\t\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t\t  }\n\t\t}\n\t\n\t\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset + 3] = (value >>> 24)\n\t\t    this[offset + 2] = (value >>> 16)\n\t\t    this[offset + 1] = (value >>> 8)\n\t\t    this[offset] = (value & 0xff)\n\t\t  } else {\n\t\t    objectWriteUInt32(this, value, offset, true)\n\t\t  }\n\t\t  return offset + 4\n\t\t}\n\t\n\t\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value >>> 24)\n\t\t    this[offset + 1] = (value >>> 16)\n\t\t    this[offset + 2] = (value >>> 8)\n\t\t    this[offset + 3] = (value & 0xff)\n\t\t  } else {\n\t\t    objectWriteUInt32(this, value, offset, false)\n\t\t  }\n\t\t  return offset + 4\n\t\t}\n\t\n\t\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) {\n\t\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t\t  }\n\t\n\t\t  var i = 0\n\t\t  var mul = 1\n\t\t  var sub = 0\n\t\t  this[offset] = value & 0xFF\n\t\t  while (++i < byteLength && (mul *= 0x100)) {\n\t\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t\t      sub = 1\n\t\t    }\n\t\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t\t  }\n\t\n\t\t  return offset + byteLength\n\t\t}\n\t\n\t\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) {\n\t\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t\t  }\n\t\n\t\t  var i = byteLength - 1\n\t\t  var mul = 1\n\t\t  var sub = 0\n\t\t  this[offset + i] = value & 0xFF\n\t\t  while (--i >= 0 && (mul *= 0x100)) {\n\t\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t\t      sub = 1\n\t\t    }\n\t\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t\t  }\n\t\n\t\t  return offset + byteLength\n\t\t}\n\t\n\t\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t\t  if (value < 0) value = 0xff + value + 1\n\t\t  this[offset] = (value & 0xff)\n\t\t  return offset + 1\n\t\t}\n\t\n\t\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value & 0xff)\n\t\t    this[offset + 1] = (value >>> 8)\n\t\t  } else {\n\t\t    objectWriteUInt16(this, value, offset, true)\n\t\t  }\n\t\t  return offset + 2\n\t\t}\n\t\n\t\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value >>> 8)\n\t\t    this[offset + 1] = (value & 0xff)\n\t\t  } else {\n\t\t    objectWriteUInt16(this, value, offset, false)\n\t\t  }\n\t\t  return offset + 2\n\t\t}\n\t\n\t\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value & 0xff)\n\t\t    this[offset + 1] = (value >>> 8)\n\t\t    this[offset + 2] = (value >>> 16)\n\t\t    this[offset + 3] = (value >>> 24)\n\t\t  } else {\n\t\t    objectWriteUInt32(this, value, offset, true)\n\t\t  }\n\t\t  return offset + 4\n\t\t}\n\t\n\t\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t\t  value = +value\n\t\t  offset = offset | 0\n\t\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t\t  if (value < 0) value = 0xffffffff + value + 1\n\t\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    this[offset] = (value >>> 24)\n\t\t    this[offset + 1] = (value >>> 16)\n\t\t    this[offset + 2] = (value >>> 8)\n\t\t    this[offset + 3] = (value & 0xff)\n\t\t  } else {\n\t\t    objectWriteUInt32(this, value, offset, false)\n\t\t  }\n\t\t  return offset + 4\n\t\t}\n\t\n\t\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t\t  if (offset < 0) throw new RangeError('Index out of range')\n\t\t}\n\t\n\t\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t\t  if (!noAssert) {\n\t\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t\t  }\n\t\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t\t  return offset + 4\n\t\t}\n\t\n\t\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t\t  return writeFloat(this, value, offset, true, noAssert)\n\t\t}\n\t\n\t\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t\t  return writeFloat(this, value, offset, false, noAssert)\n\t\t}\n\t\n\t\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t\t  if (!noAssert) {\n\t\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t\t  }\n\t\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t\t  return offset + 8\n\t\t}\n\t\n\t\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t\t  return writeDouble(this, value, offset, true, noAssert)\n\t\t}\n\t\n\t\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t\t  return writeDouble(this, value, offset, false, noAssert)\n\t\t}\n\t\n\t\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\t\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t\t  if (!start) start = 0\n\t\t  if (!end && end !== 0) end = this.length\n\t\t  if (targetStart >= target.length) targetStart = target.length\n\t\t  if (!targetStart) targetStart = 0\n\t\t  if (end > 0 && end < start) end = start\n\t\n\t\t  // Copy 0 bytes; we're done\n\t\t  if (end === start) return 0\n\t\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t\t  // Fatal error conditions\n\t\t  if (targetStart < 0) {\n\t\t    throw new RangeError('targetStart out of bounds')\n\t\t  }\n\t\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t\t  // Are we oob?\n\t\t  if (end > this.length) end = this.length\n\t\t  if (target.length - targetStart < end - start) {\n\t\t    end = target.length - targetStart + start\n\t\t  }\n\t\n\t\t  var len = end - start\n\t\t  var i\n\t\n\t\t  if (this === target && start < targetStart && targetStart < end) {\n\t\t    // descending copy from end\n\t\t    for (i = len - 1; i >= 0; --i) {\n\t\t      target[i + targetStart] = this[i + start]\n\t\t    }\n\t\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t\t    // ascending copy from start\n\t\t    for (i = 0; i < len; ++i) {\n\t\t      target[i + targetStart] = this[i + start]\n\t\t    }\n\t\t  } else {\n\t\t    Uint8Array.prototype.set.call(\n\t\t      target,\n\t\t      this.subarray(start, start + len),\n\t\t      targetStart\n\t\t    )\n\t\t  }\n\t\n\t\t  return len\n\t\t}\n\t\n\t\t// Usage:\n\t\t//    buffer.fill(number[, offset[, end]])\n\t\t//    buffer.fill(buffer[, offset[, end]])\n\t\t//    buffer.fill(string[, offset[, end]][, encoding])\n\t\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t\t  // Handle string cases:\n\t\t  if (typeof val === 'string') {\n\t\t    if (typeof start === 'string') {\n\t\t      encoding = start\n\t\t      start = 0\n\t\t      end = this.length\n\t\t    } else if (typeof end === 'string') {\n\t\t      encoding = end\n\t\t      end = this.length\n\t\t    }\n\t\t    if (val.length === 1) {\n\t\t      var code = val.charCodeAt(0)\n\t\t      if (code < 256) {\n\t\t        val = code\n\t\t      }\n\t\t    }\n\t\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t\t      throw new TypeError('encoding must be a string')\n\t\t    }\n\t\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t\t    }\n\t\t  } else if (typeof val === 'number') {\n\t\t    val = val & 255\n\t\t  }\n\t\n\t\t  // Invalid ranges are not set to a default, so can range check early.\n\t\t  if (start < 0 || this.length < start || this.length < end) {\n\t\t    throw new RangeError('Out of range index')\n\t\t  }\n\t\n\t\t  if (end <= start) {\n\t\t    return this\n\t\t  }\n\t\n\t\t  start = start >>> 0\n\t\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t\t  if (!val) val = 0\n\t\n\t\t  var i\n\t\t  if (typeof val === 'number') {\n\t\t    for (i = start; i < end; ++i) {\n\t\t      this[i] = val\n\t\t    }\n\t\t  } else {\n\t\t    var bytes = Buffer.isBuffer(val)\n\t\t      ? val\n\t\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t\t    var len = bytes.length\n\t\t    for (i = 0; i < end - start; ++i) {\n\t\t      this[i + start] = bytes[i % len]\n\t\t    }\n\t\t  }\n\t\n\t\t  return this\n\t\t}\n\t\n\t\t// HELPER FUNCTIONS\n\t\t// ================\n\t\n\t\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\t\tfunction base64clean (str) {\n\t\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t\t  // Node converts strings with length < 2 to ''\n\t\t  if (str.length < 2) return ''\n\t\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t\t  while (str.length % 4 !== 0) {\n\t\t    str = str + '='\n\t\t  }\n\t\t  return str\n\t\t}\n\t\n\t\tfunction stringtrim (str) {\n\t\t  if (str.trim) return str.trim()\n\t\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t\t}\n\t\n\t\tfunction toHex (n) {\n\t\t  if (n < 16) return '0' + n.toString(16)\n\t\t  return n.toString(16)\n\t\t}\n\t\n\t\tfunction utf8ToBytes (string, units) {\n\t\t  units = units || Infinity\n\t\t  var codePoint\n\t\t  var length = string.length\n\t\t  var leadSurrogate = null\n\t\t  var bytes = []\n\t\n\t\t  for (var i = 0; i < length; ++i) {\n\t\t    codePoint = string.charCodeAt(i)\n\t\n\t\t    // is surrogate component\n\t\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t\t      // last char was a lead\n\t\t      if (!leadSurrogate) {\n\t\t        // no lead yet\n\t\t        if (codePoint > 0xDBFF) {\n\t\t          // unexpected trail\n\t\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t\t          continue\n\t\t        } else if (i + 1 === length) {\n\t\t          // unpaired lead\n\t\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t\t          continue\n\t\t        }\n\t\n\t\t        // valid lead\n\t\t        leadSurrogate = codePoint\n\t\n\t\t        continue\n\t\t      }\n\t\n\t\t      // 2 leads in a row\n\t\t      if (codePoint < 0xDC00) {\n\t\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t\t        leadSurrogate = codePoint\n\t\t        continue\n\t\t      }\n\t\n\t\t      // valid surrogate pair\n\t\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t\t    } else if (leadSurrogate) {\n\t\t      // valid bmp char, but last char was a lead\n\t\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t\t    }\n\t\n\t\t    leadSurrogate = null\n\t\n\t\t    // encode utf8\n\t\t    if (codePoint < 0x80) {\n\t\t      if ((units -= 1) < 0) break\n\t\t      bytes.push(codePoint)\n\t\t    } else if (codePoint < 0x800) {\n\t\t      if ((units -= 2) < 0) break\n\t\t      bytes.push(\n\t\t        codePoint >> 0x6 | 0xC0,\n\t\t        codePoint & 0x3F | 0x80\n\t\t      )\n\t\t    } else if (codePoint < 0x10000) {\n\t\t      if ((units -= 3) < 0) break\n\t\t      bytes.push(\n\t\t        codePoint >> 0xC | 0xE0,\n\t\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t\t        codePoint & 0x3F | 0x80\n\t\t      )\n\t\t    } else if (codePoint < 0x110000) {\n\t\t      if ((units -= 4) < 0) break\n\t\t      bytes.push(\n\t\t        codePoint >> 0x12 | 0xF0,\n\t\t        codePoint >> 0xC & 0x3F | 0x80,\n\t\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t\t        codePoint & 0x3F | 0x80\n\t\t      )\n\t\t    } else {\n\t\t      throw new Error('Invalid code point')\n\t\t    }\n\t\t  }\n\t\n\t\t  return bytes\n\t\t}\n\t\n\t\tfunction asciiToBytes (str) {\n\t\t  var byteArray = []\n\t\t  for (var i = 0; i < str.length; ++i) {\n\t\t    // Node's code seems to be doing this and not & 0x7F..\n\t\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t\t  }\n\t\t  return byteArray\n\t\t}\n\t\n\t\tfunction utf16leToBytes (str, units) {\n\t\t  var c, hi, lo\n\t\t  var byteArray = []\n\t\t  for (var i = 0; i < str.length; ++i) {\n\t\t    if ((units -= 2) < 0) break\n\t\n\t\t    c = str.charCodeAt(i)\n\t\t    hi = c >> 8\n\t\t    lo = c % 256\n\t\t    byteArray.push(lo)\n\t\t    byteArray.push(hi)\n\t\t  }\n\t\n\t\t  return byteArray\n\t\t}\n\t\n\t\tfunction base64ToBytes (str) {\n\t\t  return base64.toByteArray(base64clean(str))\n\t\t}\n\t\n\t\tfunction blitBuffer (src, dst, offset, length) {\n\t\t  for (var i = 0; i < length; ++i) {\n\t\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t\t    dst[i + offset] = src[i]\n\t\t  }\n\t\t  return i\n\t\t}\n\t\n\t\tfunction isnan (val) {\n\t\t  return val !== val // eslint-disable-line no-self-compare\n\t\t}\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ }),\n\t/* 6 */\n\t/***/ (function(module, exports) {\n\t\n\t\t'use strict'\n\t\n\t\texports.byteLength = byteLength\n\t\texports.toByteArray = toByteArray\n\t\texports.fromByteArray = fromByteArray\n\t\n\t\tvar lookup = []\n\t\tvar revLookup = []\n\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\t\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t\t  lookup[i] = code[i]\n\t\t  revLookup[code.charCodeAt(i)] = i\n\t\t}\n\t\n\t\trevLookup['-'.charCodeAt(0)] = 62\n\t\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\t\tfunction placeHoldersCount (b64) {\n\t\t  var len = b64.length\n\t\t  if (len % 4 > 0) {\n\t\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t\t  }\n\t\n\t\t  // the number of equal signs (place holders)\n\t\t  // if there are two placeholders, than the two characters before it\n\t\t  // represent one byte\n\t\t  // if there is only one, then the three characters before it represent 2 bytes\n\t\t  // this is just a cheap hack to not do indexOf twice\n\t\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t\t}\n\t\n\t\tfunction byteLength (b64) {\n\t\t  // base64 is 4/3 + up to two characters of the original data\n\t\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t\t}\n\t\n\t\tfunction toByteArray (b64) {\n\t\t  var i, l, tmp, placeHolders, arr\n\t\t  var len = b64.length\n\t\t  placeHolders = placeHoldersCount(b64)\n\t\n\t\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t\t  // if there are placeholders, only get up to the last complete 4 chars\n\t\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t\t  var L = 0\n\t\n\t\t  for (i = 0; i < l; i += 4) {\n\t\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t\t    arr[L++] = (tmp >> 16) & 0xFF\n\t\t    arr[L++] = (tmp >> 8) & 0xFF\n\t\t    arr[L++] = tmp & 0xFF\n\t\t  }\n\t\n\t\t  if (placeHolders === 2) {\n\t\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t\t    arr[L++] = tmp & 0xFF\n\t\t  } else if (placeHolders === 1) {\n\t\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t\t    arr[L++] = (tmp >> 8) & 0xFF\n\t\t    arr[L++] = tmp & 0xFF\n\t\t  }\n\t\n\t\t  return arr\n\t\t}\n\t\n\t\tfunction tripletToBase64 (num) {\n\t\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t\t}\n\t\n\t\tfunction encodeChunk (uint8, start, end) {\n\t\t  var tmp\n\t\t  var output = []\n\t\t  for (var i = start; i < end; i += 3) {\n\t\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t    output.push(tripletToBase64(tmp))\n\t\t  }\n\t\t  return output.join('')\n\t\t}\n\t\n\t\tfunction fromByteArray (uint8) {\n\t\t  var tmp\n\t\t  var len = uint8.length\n\t\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t\t  var output = ''\n\t\t  var parts = []\n\t\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t\t  }\n\t\n\t\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t\t  if (extraBytes === 1) {\n\t\t    tmp = uint8[len - 1]\n\t\t    output += lookup[tmp >> 2]\n\t\t    output += lookup[(tmp << 4) & 0x3F]\n\t\t    output += '=='\n\t\t  } else if (extraBytes === 2) {\n\t\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t\t    output += lookup[tmp >> 10]\n\t\t    output += lookup[(tmp >> 4) & 0x3F]\n\t\t    output += lookup[(tmp << 2) & 0x3F]\n\t\t    output += '='\n\t\t  }\n\t\n\t\t  parts.push(output)\n\t\n\t\t  return parts.join('')\n\t\t}\n\t\n\t\n\t/***/ }),\n\t/* 7 */\n\t/***/ (function(module, exports) {\n\t\n\t\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t\t  var e, m\n\t\t  var eLen = nBytes * 8 - mLen - 1\n\t\t  var eMax = (1 << eLen) - 1\n\t\t  var eBias = eMax >> 1\n\t\t  var nBits = -7\n\t\t  var i = isLE ? (nBytes - 1) : 0\n\t\t  var d = isLE ? -1 : 1\n\t\t  var s = buffer[offset + i]\n\t\n\t\t  i += d\n\t\n\t\t  e = s & ((1 << (-nBits)) - 1)\n\t\t  s >>= (-nBits)\n\t\t  nBits += eLen\n\t\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t\t  m = e & ((1 << (-nBits)) - 1)\n\t\t  e >>= (-nBits)\n\t\t  nBits += mLen\n\t\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t\t  if (e === 0) {\n\t\t    e = 1 - eBias\n\t\t  } else if (e === eMax) {\n\t\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t\t  } else {\n\t\t    m = m + Math.pow(2, mLen)\n\t\t    e = e - eBias\n\t\t  }\n\t\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t\t}\n\t\n\t\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t\t  var e, m, c\n\t\t  var eLen = nBytes * 8 - mLen - 1\n\t\t  var eMax = (1 << eLen) - 1\n\t\t  var eBias = eMax >> 1\n\t\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t\t  var i = isLE ? 0 : (nBytes - 1)\n\t\t  var d = isLE ? 1 : -1\n\t\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t\t  value = Math.abs(value)\n\t\n\t\t  if (isNaN(value) || value === Infinity) {\n\t\t    m = isNaN(value) ? 1 : 0\n\t\t    e = eMax\n\t\t  } else {\n\t\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t\t      e--\n\t\t      c *= 2\n\t\t    }\n\t\t    if (e + eBias >= 1) {\n\t\t      value += rt / c\n\t\t    } else {\n\t\t      value += rt * Math.pow(2, 1 - eBias)\n\t\t    }\n\t\t    if (value * c >= 2) {\n\t\t      e++\n\t\t      c /= 2\n\t\t    }\n\t\n\t\t    if (e + eBias >= eMax) {\n\t\t      m = 0\n\t\t      e = eMax\n\t\t    } else if (e + eBias >= 1) {\n\t\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t\t      e = e + eBias\n\t\t    } else {\n\t\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t\t      e = 0\n\t\t    }\n\t\t  }\n\t\n\t\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t\t  e = (e << mLen) | m\n\t\t  eLen += mLen\n\t\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t\t  buffer[offset + i - d] |= s * 128\n\t\t}\n\t\n\t\n\t/***/ }),\n\t/* 8 */\n\t/***/ (function(module, exports) {\n\t\n\t\tvar toString = {}.toString;\n\t\n\t\tmodule.exports = Array.isArray || function (arr) {\n\t\t  return toString.call(arr) == '[object Array]';\n\t\t};\n\t\n\t\n\t/***/ }),\n\t/* 9 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\n\t\t/**\n\t\t * Expose `Emitter`.\n\t\t */\n\t\n\t\tif (true) {\n\t\t  module.exports = Emitter;\n\t\t}\n\t\n\t\t/**\n\t\t * Initialize a new `Emitter`.\n\t\t *\n\t\t * @api public\n\t\t */\n\t\n\t\tfunction Emitter(obj) {\n\t\t  if (obj) return mixin(obj);\n\t\t};\n\t\n\t\t/**\n\t\t * Mixin the emitter properties.\n\t\t *\n\t\t * @param {Object} obj\n\t\t * @return {Object}\n\t\t * @api private\n\t\t */\n\t\n\t\tfunction mixin(obj) {\n\t\t  for (var key in Emitter.prototype) {\n\t\t    obj[key] = Emitter.prototype[key];\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\n\t\t/**\n\t\t * Listen on the given `event` with `fn`.\n\t\t *\n\t\t * @param {String} event\n\t\t * @param {Function} fn\n\t\t * @return {Emitter}\n\t\t * @api public\n\t\t */\n\t\n\t\tEmitter.prototype.on =\n\t\tEmitter.prototype.addEventListener = function(event, fn){\n\t\t  this._callbacks = this._callbacks || {};\n\t\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n\t\t    .push(fn);\n\t\t  return this;\n\t\t};\n\t\n\t\t/**\n\t\t * Adds an `event` listener that will be invoked a single\n\t\t * time then automatically removed.\n\t\t *\n\t\t * @param {String} event\n\t\t * @param {Function} fn\n\t\t * @return {Emitter}\n\t\t * @api public\n\t\t */\n\t\n\t\tEmitter.prototype.once = function(event, fn){\n\t\t  function on() {\n\t\t    this.off(event, on);\n\t\t    fn.apply(this, arguments);\n\t\t  }\n\t\n\t\t  on.fn = fn;\n\t\t  this.on(event, on);\n\t\t  return this;\n\t\t};\n\t\n\t\t/**\n\t\t * Remove the given callback for `event` or all\n\t\t * registered callbacks.\n\t\t *\n\t\t * @param {String} event\n\t\t * @param {Function} fn\n\t\t * @return {Emitter}\n\t\t * @api public\n\t\t */\n\t\n\t\tEmitter.prototype.off =\n\t\tEmitter.prototype.removeListener =\n\t\tEmitter.prototype.removeAllListeners =\n\t\tEmitter.prototype.removeEventListener = function(event, fn){\n\t\t  this._callbacks = this._callbacks || {};\n\t\n\t\t  // all\n\t\t  if (0 == arguments.length) {\n\t\t    this._callbacks = {};\n\t\t    return this;\n\t\t  }\n\t\n\t\t  // specific event\n\t\t  var callbacks = this._callbacks['$' + event];\n\t\t  if (!callbacks) return this;\n\t\n\t\t  // remove all handlers\n\t\t  if (1 == arguments.length) {\n\t\t    delete this._callbacks['$' + event];\n\t\t    return this;\n\t\t  }\n\t\n\t\t  // remove specific handler\n\t\t  var cb;\n\t\t  for (var i = 0; i < callbacks.length; i++) {\n\t\t    cb = callbacks[i];\n\t\t    if (cb === fn || cb.fn === fn) {\n\t\t      callbacks.splice(i, 1);\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  return this;\n\t\t};\n\t\n\t\t/**\n\t\t * Emit `event` with the given args.\n\t\t *\n\t\t * @param {String} event\n\t\t * @param {Mixed} ...\n\t\t * @return {Emitter}\n\t\t */\n\t\n\t\tEmitter.prototype.emit = function(event){\n\t\t  this._callbacks = this._callbacks || {};\n\t\t  var args = [].slice.call(arguments, 1)\n\t\t    , callbacks = this._callbacks['$' + event];\n\t\n\t\t  if (callbacks) {\n\t\t    callbacks = callbacks.slice(0);\n\t\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t\t      callbacks[i].apply(this, args);\n\t\t    }\n\t\t  }\n\t\n\t\t  return this;\n\t\t};\n\t\n\t\t/**\n\t\t * Return array of callbacks for `event`.\n\t\t *\n\t\t * @param {String} event\n\t\t * @return {Array}\n\t\t * @api public\n\t\t */\n\t\n\t\tEmitter.prototype.listeners = function(event){\n\t\t  this._callbacks = this._callbacks || {};\n\t\t  return this._callbacks['$' + event] || [];\n\t\t};\n\t\n\t\t/**\n\t\t * Check if this emitter has `event` handlers.\n\t\t *\n\t\t * @param {String} event\n\t\t * @return {Boolean}\n\t\t * @api public\n\t\t */\n\t\n\t\tEmitter.prototype.hasListeners = function(event){\n\t\t  return !! this.listeners(event).length;\n\t\t};\n\t\n\t\n\t/***/ }),\n\t/* 10 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\tvar Emitter = __webpack_require__(9);\n\t\n\t\tvar SCChannel = function (name, client, options) {\n\t\t  var self = this;\n\t\n\t\t  Emitter.call(this);\n\t\n\t\t  this.PENDING = 'pending';\n\t\t  this.SUBSCRIBED = 'subscribed';\n\t\t  this.UNSUBSCRIBED = 'unsubscribed';\n\t\n\t\t  this.name = name;\n\t\t  this.state = this.UNSUBSCRIBED;\n\t\t  this.client = client;\n\t\n\t\t  this.options = options || {};\n\t\t  this.setOptions(this.options);\n\t\t};\n\t\n\t\tSCChannel.prototype = Object.create(Emitter.prototype);\n\t\n\t\tSCChannel.prototype.setOptions = function (options) {\n\t\t  if (!options) {\n\t\t    options = {};\n\t\t  }\n\t\t  this.waitForAuth = options.waitForAuth || false;\n\t\t  this.batch = options.batch || false;\n\t\n\t\t  if (options.data !== undefined) {\n\t\t    this.data = options.data;\n\t\t  }\n\t\t};\n\t\n\t\tSCChannel.prototype.getState = function () {\n\t\t  return this.state;\n\t\t};\n\t\n\t\tSCChannel.prototype.subscribe = function (options) {\n\t\t  this.client.subscribe(this.name, options);\n\t\t};\n\t\n\t\tSCChannel.prototype.unsubscribe = function () {\n\t\t  this.client.unsubscribe(this.name);\n\t\t};\n\t\n\t\tSCChannel.prototype.isSubscribed = function (includePending) {\n\t\t  return this.client.isSubscribed(this.name, includePending);\n\t\t};\n\t\n\t\tSCChannel.prototype.publish = function (data, callback) {\n\t\t  this.client.publish(this.name, data, callback);\n\t\t};\n\t\n\t\tSCChannel.prototype.watch = function (handler) {\n\t\t  this.client.watch(this.name, handler);\n\t\t};\n\t\n\t\tSCChannel.prototype.unwatch = function (handler) {\n\t\t  this.client.unwatch(this.name, handler);\n\t\t};\n\t\n\t\tSCChannel.prototype.watchers = function () {\n\t\t  return this.client.watchers(this.name);\n\t\t};\n\t\n\t\tSCChannel.prototype.destroy = function () {\n\t\t  this.client.destroyChannel(this.name);\n\t\t};\n\t\n\t\tmodule.exports.SCChannel = SCChannel;\n\t\n\t\n\t/***/ }),\n\t/* 11 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\tvar scErrors = __webpack_require__(12);\n\t\tvar InvalidActionError = scErrors.InvalidActionError;\n\t\n\t\tvar Response = function (socket, id) {\n\t\t  this.socket = socket;\n\t\t  this.id = id;\n\t\t  this.sent = false;\n\t\t};\n\t\n\t\tResponse.prototype._respond = function (responseData) {\n\t\t  if (this.sent) {\n\t\t    throw new InvalidActionError('Response ' + this.id + ' has already been sent');\n\t\t  } else {\n\t\t    this.sent = true;\n\t\t    this.socket.send(this.socket.encode(responseData));\n\t\t  }\n\t\t};\n\t\n\t\tResponse.prototype.end = function (data) {\n\t\t  if (this.id) {\n\t\t    var responseData = {\n\t\t      rid: this.id\n\t\t    };\n\t\t    if (data !== undefined) {\n\t\t      responseData.data = data;\n\t\t    }\n\t\t    this._respond(responseData);\n\t\t  }\n\t\t};\n\t\n\t\tResponse.prototype.error = function (error, data) {\n\t\t  if (this.id) {\n\t\t    var err = scErrors.dehydrateError(error);\n\t\n\t\t    var responseData = {\n\t\t      rid: this.id,\n\t\t      error: err\n\t\t    };\n\t\t    if (data !== undefined) {\n\t\t      responseData.data = data;\n\t\t    }\n\t\n\t\t    this._respond(responseData);\n\t\t  }\n\t\t};\n\t\n\t\tResponse.prototype.callback = function (error, data) {\n\t\t  if (error) {\n\t\t    this.error(error, data);\n\t\t  } else {\n\t\t    this.end(data);\n\t\t  }\n\t\t};\n\t\n\t\tmodule.exports.Response = Response;\n\t\n\t\n\t/***/ }),\n\t/* 12 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\tvar decycle = __webpack_require__(13);\n\t\n\t\tvar isStrict = (function () { return !this; })();\n\t\n\t\tfunction AuthTokenExpiredError(message, expiry) {\n\t\t  this.name = 'AuthTokenExpiredError';\n\t\t  this.message = message;\n\t\t  this.expiry = expiry;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tAuthTokenExpiredError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction AuthTokenInvalidError(message) {\n\t\t  this.name = 'AuthTokenInvalidError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tAuthTokenInvalidError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction AuthTokenNotBeforeError(message, date) {\n\t\t  this.name = 'AuthTokenNotBeforeError';\n\t\t  this.message = message;\n\t\t  this.date = date;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\t// For any other auth token error.\n\t\tfunction AuthTokenError(message) {\n\t\t  this.name = 'AuthTokenError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tAuthTokenError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction SilentMiddlewareBlockedError(message, type) {\n\t\t  this.name = 'SilentMiddlewareBlockedError';\n\t\t  this.message = message;\n\t\t  this.type = type;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction InvalidActionError(message) {\n\t\t  this.name = 'InvalidActionError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tInvalidActionError.prototype = Object.create(Error.prototype);\n\t\n\t\tfunction InvalidArgumentsError(message) {\n\t\t  this.name = 'InvalidArgumentsError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tInvalidArgumentsError.prototype = Object.create(Error.prototype);\n\t\n\t\tfunction InvalidOptionsError(message) {\n\t\t  this.name = 'InvalidOptionsError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tInvalidOptionsError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction InvalidMessageError(message) {\n\t\t  this.name = 'InvalidMessageError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tInvalidMessageError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction SocketProtocolError(message, code) {\n\t\t  this.name = 'SocketProtocolError';\n\t\t  this.message = message;\n\t\t  this.code = code;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tSocketProtocolError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction ServerProtocolError(message) {\n\t\t  this.name = 'ServerProtocolError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tServerProtocolError.prototype = Object.create(Error.prototype);\n\t\n\t\tfunction HTTPServerError(message) {\n\t\t  this.name = 'HTTPServerError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tHTTPServerError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction ResourceLimitError(message) {\n\t\t  this.name = 'ResourceLimitError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tResourceLimitError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction TimeoutError(message) {\n\t\t  this.name = 'TimeoutError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tTimeoutError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction BadConnectionError(message, type) {\n\t\t  this.name = 'BadConnectionError';\n\t\t  this.message = message;\n\t\t  this.type = type;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tBadConnectionError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction BrokerError(message) {\n\t\t  this.name = 'BrokerError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tBrokerError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction ProcessExitError(message, code) {\n\t\t  this.name = 'ProcessExitError';\n\t\t  this.message = message;\n\t\t  this.code = code;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tProcessExitError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\tfunction UnknownError(message) {\n\t\t  this.name = 'UnknownError';\n\t\t  this.message = message;\n\t\t  if (Error.captureStackTrace && !isStrict) {\n\t\t    Error.captureStackTrace(this, arguments.callee);\n\t\t  } else {\n\t\t    this.stack = (new Error()).stack;\n\t\t  }\n\t\t}\n\t\tUnknownError.prototype = Object.create(Error.prototype);\n\t\n\t\n\t\t// Expose all error types\n\t\n\t\tmodule.exports = {\n\t\t  AuthTokenExpiredError: AuthTokenExpiredError,\n\t\t  AuthTokenInvalidError: AuthTokenInvalidError,\n\t\t  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\n\t\t  AuthTokenError: AuthTokenError,\n\t\t  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\n\t\t  InvalidActionError: InvalidActionError,\n\t\t  InvalidArgumentsError: InvalidArgumentsError,\n\t\t  InvalidOptionsError: InvalidOptionsError,\n\t\t  InvalidMessageError: InvalidMessageError,\n\t\t  SocketProtocolError: SocketProtocolError,\n\t\t  ServerProtocolError: ServerProtocolError,\n\t\t  HTTPServerError: HTTPServerError,\n\t\t  ResourceLimitError: ResourceLimitError,\n\t\t  TimeoutError: TimeoutError,\n\t\t  BadConnectionError: BadConnectionError,\n\t\t  BrokerError: BrokerError,\n\t\t  ProcessExitError: ProcessExitError,\n\t\t  UnknownError: UnknownError\n\t\t};\n\t\n\t\tmodule.exports.socketProtocolErrorStatuses = {\n\t\t  1001: 'Socket was disconnected',\n\t\t  1002: 'A WebSocket protocol error was encountered',\n\t\t  1003: 'Server terminated socket because it received invalid data',\n\t\t  1005: 'Socket closed without status code',\n\t\t  1006: 'Socket hung up',\n\t\t  1007: 'Message format was incorrect',\n\t\t  1008: 'Encountered a policy violation',\n\t\t  1009: 'Message was too big to process',\n\t\t  1010: 'Client ended the connection because the server did not comply with extension requirements',\n\t\t  1011: 'Server encountered an unexpected fatal condition',\n\t\t  4000: 'Server ping timed out',\n\t\t  4001: 'Client pong timed out',\n\t\t  4002: 'Server failed to sign auth token',\n\t\t  4003: 'Failed to complete handshake',\n\t\t  4004: 'Client failed to save auth token',\n\t\t  4005: 'Did not receive #handshake from client before timeout',\n\t\t  4006: 'Failed to bind socket to message broker',\n\t\t  4007: 'Client connection establishment timed out'\n\t\t};\n\t\n\t\tmodule.exports.socketProtocolIgnoreStatuses = {\n\t\t  1000: 'Socket closed normally',\n\t\t  1001: 'Socket hung up'\n\t\t};\n\t\n\t\t// Properties related to error domains cannot be serialized.\n\t\tvar unserializableErrorProperties = {\n\t\t  domain: 1,\n\t\t  domainEmitter: 1,\n\t\t  domainThrown: 1\n\t\t};\n\t\n\t\tmodule.exports.dehydrateError = function (error, includeStackTrace) {\n\t\t  var dehydratedError;\n\t\n\t\t  if (error && typeof error == 'object') {\n\t\t    dehydratedError = {\n\t\t      message: error.message\n\t\t    };\n\t\t    if (includeStackTrace) {\n\t\t      dehydratedError.stack = error.stack;\n\t\t    }\n\t\t    for (var i in error) {\n\t\t      if (!unserializableErrorProperties[i]) {\n\t\t        dehydratedError[i] = error[i];\n\t\t      }\n\t\t    }\n\t\t  } else if (typeof error == 'function') {\n\t\t    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\n\t\t  } else {\n\t\t    dehydratedError = error;\n\t\t  }\n\t\n\t\t  return decycle(dehydratedError);\n\t\t};\n\t\n\t\tmodule.exports.hydrateError = function (error) {\n\t\t  var hydratedError = null;\n\t\t  if (error != null) {\n\t\t    if (typeof error == 'object') {\n\t\t      hydratedError = new Error(error.message);\n\t\t      for (var i in error) {\n\t\t        if (error.hasOwnProperty(i)) {\n\t\t          hydratedError[i] = error[i];\n\t\t        }\n\t\t      }\n\t\t    } else {\n\t\t      hydratedError = error;\n\t\t    }\n\t\t  }\n\t\t  return hydratedError;\n\t\t};\n\t\n\t\tmodule.exports.decycle = decycle;\n\t\n\t\n\t/***/ }),\n\t/* 13 */\n\t/***/ (function(module, exports) {\n\t\n\t\t// Based on https://github.com/dscape/cycle/blob/master/cycle.js\n\t\n\t\tmodule.exports = function decycle(object) {\n\t\t// Make a deep copy of an object or array, assuring that there is at most\n\t\t// one instance of each object or array in the resulting structure. The\n\t\t// duplicate references (which might be forming cycles) are replaced with\n\t\t// an object of the form\n\t\t//      {$ref: PATH}\n\t\t// where the PATH is a JSONPath string that locates the first occurance.\n\t\t// So,\n\t\t//      var a = [];\n\t\t//      a[0] = a;\n\t\t//      return JSON.stringify(JSON.decycle(a));\n\t\t// produces the string '[{\"$ref\":\"$\"}]'.\n\t\n\t\t// JSONPath is used to locate the unique object. $ indicates the top level of\n\t\t// the object or array. [NUMBER] or [STRING] indicates a child member or\n\t\t// property.\n\t\n\t\t    var objects = [],   // Keep a reference to each unique object or array\n\t\t        paths = [];     // Keep the path to each unique object or array\n\t\n\t\t    return (function derez(value, path) {\n\t\n\t\t// The derez recurses through the object, producing the deep copy.\n\t\n\t\t        var i,          // The loop counter\n\t\t            name,       // Property name\n\t\t            nu;         // The new object or array\n\t\n\t\t// typeof null === 'object', so go on if this value is really an object but not\n\t\t// one of the weird builtin objects.\n\t\n\t\t        if (typeof value === 'object' && value !== null &&\n\t\t                !(value instanceof Boolean) &&\n\t\t                !(value instanceof Date)    &&\n\t\t                !(value instanceof Number)  &&\n\t\t                !(value instanceof RegExp)  &&\n\t\t                !(value instanceof String)) {\n\t\n\t\t// If the value is an object or array, look to see if we have already\n\t\t// encountered it. If so, return a $ref/path object. This is a hard way,\n\t\t// linear search that will get slower as the number of unique objects grows.\n\t\n\t\t            for (i = 0; i < objects.length; i += 1) {\n\t\t                if (objects[i] === value) {\n\t\t                    return {$ref: paths[i]};\n\t\t                }\n\t\t            }\n\t\n\t\t// Otherwise, accumulate the unique value and its path.\n\t\n\t\t            objects.push(value);\n\t\t            paths.push(path);\n\t\n\t\t// If it is an array, replicate the array.\n\t\n\t\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t\t                nu = [];\n\t\t                for (i = 0; i < value.length; i += 1) {\n\t\t                    nu[i] = derez(value[i], path + '[' + i + ']');\n\t\t                }\n\t\t            } else {\n\t\n\t\t// If it is an object, replicate the object.\n\t\n\t\t                nu = {};\n\t\t                for (name in value) {\n\t\t                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n\t\t                        nu[name] = derez(value[name],\n\t\t                            path + '[' + JSON.stringify(name) + ']');\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t            return nu;\n\t\t        }\n\t\t        return value;\n\t\t    }(object, '$'));\n\t\t};\n\t\n\t\n\t/***/ }),\n\t/* 14 */\n\t/***/ (function(module, exports) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(global) {var AuthEngine = function () {\n\t\t  this._internalStorage = {};\n\t\t  this.isLocalStorageEnabled = this._checkLocalStorageEnabled();\n\t\t};\n\t\n\t\tAuthEngine.prototype._checkLocalStorageEnabled = function () {\n\t\t  var err;\n\t\t  try {\n\t\t    // Some browsers will throw an error here if localStorage is disabled.\n\t\t    global.localStorage;\n\t\n\t\t    // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n\t\t    // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.\n\t\t    global.localStorage.setItem('__scLocalStorageTest', 1);\n\t\t    global.localStorage.removeItem('__scLocalStorageTest');\n\t\t  } catch (e) {\n\t\t    err = e;\n\t\t  }\n\t\t  return !err;\n\t\t};\n\t\n\t\tAuthEngine.prototype.saveToken = function (name, token, options, callback) {\n\t\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t\t    global.localStorage.setItem(name, token);\n\t\t  } else {\n\t\t    this._internalStorage[name] = token;\n\t\t  }\n\t\t  callback && callback(null, token);\n\t\t};\n\t\n\t\tAuthEngine.prototype.removeToken = function (name, callback) {\n\t\t  var token;\n\t\n\t\t  this.loadToken(name, function (err, authToken) {\n\t\t    token = authToken;\n\t\t  });\n\t\n\t\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t\t    global.localStorage.removeItem(name);\n\t\t  } else {\n\t\t    delete this._internalStorage[name];\n\t\t  }\n\t\n\t\t  callback && callback(null, token);\n\t\t};\n\t\n\t\tAuthEngine.prototype.loadToken = function (name, callback) {\n\t\t  var token;\n\t\n\t\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t\t    token = global.localStorage.getItem(name);\n\t\t  } else {\n\t\t    token = this._internalStorage[name] || null;\n\t\t  }\n\t\t  callback(null, token);\n\t\t};\n\t\n\t\tmodule.exports.AuthEngine = AuthEngine;\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ }),\n\t/* 15 */\n\t/***/ (function(module, exports) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(global) {var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t\n\t\tvar arrayBufferToBase64 = function (arraybuffer) {\n\t\t  var bytes = new Uint8Array(arraybuffer);\n\t\t  var len = bytes.length;\n\t\t  var base64 = '';\n\t\n\t\t  for (var i = 0; i < len; i += 3) {\n\t\t    base64 += base64Chars[bytes[i] >> 2];\n\t\t    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t\t    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t\t    base64 += base64Chars[bytes[i + 2] & 63];\n\t\t  }\n\t\n\t\t  if ((len % 3) === 2) {\n\t\t    base64 = base64.substring(0, base64.length - 1) + '=';\n\t\t  } else if (len % 3 === 1) {\n\t\t    base64 = base64.substring(0, base64.length - 2) + '==';\n\t\t  }\n\t\n\t\t  return base64;\n\t\t};\n\t\n\t\tvar binaryToBase64Replacer = function (key, value) {\n\t\t  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n\t\t    return {\n\t\t      base64: true,\n\t\t      data: arrayBufferToBase64(value)\n\t\t    };\n\t\t  } else if (global.Buffer) {\n\t\t    if (value instanceof global.Buffer){\n\t\t      return {\n\t\t        base64: true,\n\t\t        data: value.toString('base64')\n\t\t      };\n\t\t    }\n\t\t    // Some versions of Node.js convert Buffers to Objects before they are passed to\n\t\t    // the replacer function - Because of this, we need to rehydrate Buffers\n\t\t    // before we can convert them to base64 strings.\n\t\t    if (value && value.type == 'Buffer' && value.data instanceof Array) {\n\t\t      var rehydratedBuffer;\n\t\t      if (global.Buffer.from) {\n\t\t        rehydratedBuffer = global.Buffer.from(value.data);\n\t\t      } else {\n\t\t        rehydratedBuffer = new global.Buffer(value.data);\n\t\t      }\n\t\t      return {\n\t\t        base64: true,\n\t\t        data: rehydratedBuffer.toString('base64')\n\t\t      };\n\t\t    }\n\t\t  }\n\t\t  return value;\n\t\t};\n\t\n\t\t// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n\t\t// See encode function below for more details.\n\t\tmodule.exports.decode = function (input) {\n\t\t  if (input == null) {\n\t\t   return null;\n\t\t  }\n\t\t  // Leave ping or pong message as is\n\t\t  if (input == '#1' || input == '#2') {\n\t\t    return input;\n\t\t  }\n\t\t  var message = input.toString();\n\t\n\t\t  try {\n\t\t    return JSON.parse(message);\n\t\t  } catch (err) {}\n\t\t  return message;\n\t\t};\n\t\n\t\n\t\t// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n\t\t// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n\t\t// If you want to create your own custom codec, you can encode the object into any format\n\t\t// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n\t\t// function is able to rehydrate that object back into its original JavaScript Object format\n\t\t// (which adheres to the SC protocol).\n\t\t// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n\t\t// for details about the SC protocol.\n\t\tmodule.exports.encode = function (object) {\n\t\t  // Leave ping or pong message as is\n\t\t  if (object == '#1' || object == '#2') {\n\t\t    return object;\n\t\t  }\n\t\t  return JSON.stringify(object, binaryToBase64Replacer);\n\t\t};\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ }),\n\t/* 16 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(global) {var Emitter = __webpack_require__(9);\n\t\tvar Response = __webpack_require__(11).Response;\n\t\tvar querystring = __webpack_require__(17);\n\t\tvar WebSocket;\n\t\tvar createWebSocket;\n\t\n\t\tif (global.WebSocket) {\n\t\t  WebSocket = global.WebSocket;\n\t\t  createWebSocket = function (uri, options) {\n\t\t    return new WebSocket(uri);\n\t\t  };\n\t\t} else {\n\t\t  WebSocket = __webpack_require__(20);\n\t\t  createWebSocket = function (uri, options) {\n\t\t    return new WebSocket(uri, null, options);\n\t\t  };\n\t\t}\n\t\n\t\tvar scErrors = __webpack_require__(12);\n\t\tvar TimeoutError = scErrors.TimeoutError;\n\t\tvar BadConnectionError = scErrors.BadConnectionError;\n\t\n\t\n\t\tvar SCTransport = function (authEngine, codecEngine, options) {\n\t\t  this.state = this.CLOSED;\n\t\t  this.auth = authEngine;\n\t\t  this.codec = codecEngine;\n\t\t  this.options = options;\n\t\t  this.connectTimeout = options.connectTimeout;\n\t\t  this.pingTimeout = options.ackTimeout;\n\t\t  this.callIdGenerator = options.callIdGenerator;\n\t\t  this.authTokenName = options.authTokenName;\n\t\n\t\t  this._pingTimeoutTicker = null;\n\t\t  this._callbackMap = {};\n\t\t  this._batchSendList = [];\n\t\n\t\t  this.open();\n\t\t};\n\t\n\t\tSCTransport.prototype = Object.create(Emitter.prototype);\n\t\n\t\tSCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';\n\t\tSCTransport.OPEN = SCTransport.prototype.OPEN = 'open';\n\t\tSCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';\n\t\n\t\tSCTransport.prototype.uri = function () {\n\t\t  var query = this.options.query || {};\n\t\t  var schema = this.options.secure ? 'wss' : 'ws';\n\t\n\t\t  if (this.options.timestampRequests) {\n\t\t    query[this.options.timestampParam] = (new Date()).getTime();\n\t\t  }\n\t\n\t\t  query = querystring.encode(query);\n\t\n\t\t  if (query.length) {\n\t\t    query = '?' + query;\n\t\t  }\n\t\n\t\t  var host;\n\t\t  if (this.options.host) {\n\t\t    host = this.options.host;\n\t\t  } else {\n\t\t    var port = '';\n\t\n\t\t    if (this.options.port && ((schema == 'wss' && this.options.port != 443)\n\t\t      || (schema == 'ws' && this.options.port != 80))) {\n\t\t      port = ':' + this.options.port;\n\t\t    }\n\t\t    host = this.options.hostname + port;\n\t\t  }\n\t\n\t\t  return schema + '://' + host + this.options.path + query;\n\t\t};\n\t\n\t\tSCTransport.prototype.open = function () {\n\t\t  var self = this;\n\t\n\t\t  this.state = this.CONNECTING;\n\t\t  var uri = this.uri();\n\t\n\t\t  var wsSocket = createWebSocket(uri, this.options);\n\t\t  wsSocket.binaryType = this.options.binaryType;\n\t\t  this.socket = wsSocket;\n\t\n\t\t  wsSocket.onopen = function () {\n\t\t    self._onOpen();\n\t\t  };\n\t\n\t\t  wsSocket.onclose = function (event) {\n\t\t    var code;\n\t\t    if (event.code == null) {\n\t\t      // This is to handle an edge case in React Native whereby\n\t\t      // event.code is undefined when the mobile device is locked.\n\t\t      // TODO: This is not perfect since this condition could also apply to\n\t\t      // an abnormal close (no close control frame) which would be a 1006.\n\t\t      code = 1005;\n\t\t    } else {\n\t\t      code = event.code;\n\t\t    }\n\t\t    self._onClose(code, event.reason);\n\t\t  };\n\t\n\t\t  wsSocket.onmessage = function (message, flags) {\n\t\t    self._onMessage(message.data);\n\t\t  };\n\t\n\t\t  wsSocket.onerror = function (error) {\n\t\t    // The onclose event will be called automatically after the onerror event\n\t\t    // if the socket is connected - Otherwise, if it's in the middle of\n\t\t    // connecting, we want to close it manually with a 1006 - This is necessary\n\t\t    // to prevent inconsistent behavior when running the client in Node.js\n\t\t    // vs in a browser.\n\t\n\t\t    if (self.state === self.CONNECTING) {\n\t\t      self._onClose(1006);\n\t\t    }\n\t\t  };\n\t\n\t\t  this._connectTimeoutRef = setTimeout(function () {\n\t\t    self._onClose(4007);\n\t\t    self.socket.close(4007);\n\t\t  }, this.connectTimeout);\n\t\t};\n\t\n\t\tSCTransport.prototype._onOpen = function () {\n\t\t  var self = this;\n\t\n\t\t  clearTimeout(this._connectTimeoutRef);\n\t\t  this._resetPingTimeout();\n\t\n\t\t  this._handshake(function (err, status) {\n\t\t    if (err) {\n\t\t      self._onError(err);\n\t\t      self._onClose(4003);\n\t\t      self.socket.close(4003);\n\t\t    } else {\n\t\t      self.state = self.OPEN;\n\t\t      Emitter.prototype.emit.call(self, 'open', status);\n\t\t      self._resetPingTimeout();\n\t\t    }\n\t\t  });\n\t\t};\n\t\n\t\tSCTransport.prototype._handshake = function (callback) {\n\t\t  var self = this;\n\t\t  this.auth.loadToken(this.authTokenName, function (err, token) {\n\t\t    if (err) {\n\t\t      callback(err);\n\t\t    } else {\n\t\t      // Don't wait for this.state to be 'open'.\n\t\t      // The underlying WebSocket (this.socket) is already open.\n\t\t      var options = {\n\t\t        force: true\n\t\t      };\n\t\t      self.emit('#handshake', {\n\t\t        authToken: token\n\t\t      }, options, function (err, status) {\n\t\t        if (status) {\n\t\t          // Add the token which was used as part of authentication attempt\n\t\t          // to the status object.\n\t\t          status.authToken = token;\n\t\t          if (status.authError) {\n\t\t            status.authError = scErrors.hydrateError(status.authError);\n\t\t          }\n\t\t        }\n\t\t        callback(err, status);\n\t\t      });\n\t\t    }\n\t\t  });\n\t\t};\n\t\n\t\tSCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n\t\t  for (var i in this._callbackMap) {\n\t\t    if (this._callbackMap.hasOwnProperty(i)) {\n\t\t      var eventObject = this._callbackMap[i];\n\t\t      delete this._callbackMap[i];\n\t\n\t\t      clearTimeout(eventObject.timeout);\n\t\t      delete eventObject.timeout;\n\t\n\t\t      var errorMessage = \"Event '\" + eventObject.event +\n\t\t        \"' was aborted due to a bad connection\";\n\t\t      var badConnectionError = new BadConnectionError(errorMessage, failureType);\n\t\n\t\t      var callback = eventObject.callback;\n\t\t      delete eventObject.callback;\n\t\t      callback.call(eventObject, badConnectionError, eventObject);\n\t\t    }\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype._onClose = function (code, data) {\n\t\t  delete this.socket.onopen;\n\t\t  delete this.socket.onclose;\n\t\t  delete this.socket.onmessage;\n\t\t  delete this.socket.onerror;\n\t\n\t\t  clearTimeout(this._connectTimeoutRef);\n\t\n\t\t  if (this.state == this.OPEN) {\n\t\t    this.state = this.CLOSED;\n\t\t    Emitter.prototype.emit.call(this, 'close', code, data);\n\t\t    this._abortAllPendingEventsDueToBadConnection('disconnect');\n\t\n\t\t  } else if (this.state == this.CONNECTING) {\n\t\t    this.state = this.CLOSED;\n\t\t    Emitter.prototype.emit.call(this, 'openAbort', code, data);\n\t\t    this._abortAllPendingEventsDueToBadConnection('connectAbort');\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype._handleEventObject = function (obj, message) {\n\t\t  if (obj && obj.event != null) {\n\t\t    var response = new Response(this, obj.cid);\n\t\t    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);\n\t\t  } else if (obj && obj.rid != null) {\n\t\t    var eventObject = this._callbackMap[obj.rid];\n\t\t    if (eventObject) {\n\t\t      clearTimeout(eventObject.timeout);\n\t\t      delete eventObject.timeout;\n\t\t      delete this._callbackMap[obj.rid];\n\t\n\t\t      if (eventObject.callback) {\n\t\t        var rehydratedError = scErrors.hydrateError(obj.error);\n\t\t        eventObject.callback(rehydratedError, obj.data);\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    Emitter.prototype.emit.call(this, 'event', 'raw', message);\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype._onMessage = function (message) {\n\t\t  Emitter.prototype.emit.call(this, 'event', 'message', message);\n\t\n\t\t  var obj = this.decode(message);\n\t\n\t\t  // If ping\n\t\t  if (obj == '#1') {\n\t\t    this._resetPingTimeout();\n\t\t    if (this.socket.readyState == this.socket.OPEN) {\n\t\t      this.sendObject('#2');\n\t\t    }\n\t\t  } else {\n\t\t    if (Array.isArray(obj)) {\n\t\t      var len = obj.length;\n\t\t      for (var i = 0; i < len; i++) {\n\t\t        this._handleEventObject(obj[i], message);\n\t\t      }\n\t\t    } else {\n\t\t      this._handleEventObject(obj, message);\n\t\t    }\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype._onError = function (err) {\n\t\t  Emitter.prototype.emit.call(this, 'error', err);\n\t\t};\n\t\n\t\tSCTransport.prototype._resetPingTimeout = function () {\n\t\t  var self = this;\n\t\n\t\t  var now = (new Date()).getTime();\n\t\t  clearTimeout(this._pingTimeoutTicker);\n\t\n\t\t  this._pingTimeoutTicker = setTimeout(function () {\n\t\t    self._onClose(4000);\n\t\t    self.socket.close(4000);\n\t\t  }, this.pingTimeout);\n\t\t};\n\t\n\t\tSCTransport.prototype.getBytesReceived = function () {\n\t\t  return this.socket.bytesReceived;\n\t\t};\n\t\n\t\tSCTransport.prototype.close = function (code, data) {\n\t\t  code = code || 1000;\n\t\n\t\t  if (this.state == this.OPEN) {\n\t\t    var packet = {\n\t\t      code: code,\n\t\t      data: data\n\t\t    };\n\t\t    this.emit('#disconnect', packet);\n\t\n\t\t    this._onClose(code, data);\n\t\t    this.socket.close(code);\n\t\n\t\t  } else if (this.state == this.CONNECTING) {\n\t\t    this._onClose(code, data);\n\t\t    this.socket.close(code);\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype.emitObject = function (eventObject, options) {\n\t\t  var simpleEventObject = {\n\t\t    event: eventObject.event,\n\t\t    data: eventObject.data\n\t\t  };\n\t\n\t\t  if (eventObject.callback) {\n\t\t    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();\n\t\t    this._callbackMap[eventObject.cid] = eventObject;\n\t\t  }\n\t\n\t\t  this.sendObject(simpleEventObject, options);\n\t\n\t\t  return eventObject.cid || null;\n\t\t};\n\t\n\t\tSCTransport.prototype._handleEventAckTimeout = function (eventObject) {\n\t\n\t\t  if (eventObject.cid) {\n\t\t    delete this._callbackMap[eventObject.cid];\n\t\t  }\n\t\t  delete eventObject.timeout;\n\t\n\t\t  var callback = eventObject.callback;\n\t\t  if (callback) {\n\t\t    delete eventObject.callback;\n\t\t    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n\t\t    callback.call(eventObject, error, eventObject);\n\t\t  }\n\t\t};\n\t\n\t\t// The last two optional arguments (a and b) can be options and/or callback\n\t\tSCTransport.prototype.emit = function (event, data, a, b) {\n\t\t  var self = this;\n\t\n\t\t  var callback, options;\n\t\n\t\t  if (b) {\n\t\t    options = a;\n\t\t    callback = b;\n\t\t  } else {\n\t\t    if (a instanceof Function) {\n\t\t      options = {};\n\t\t      callback = a;\n\t\t    } else {\n\t\t      options = a;\n\t\t    }\n\t\t  }\n\t\n\t\t  var eventObject = {\n\t\t    event: event,\n\t\t    data: data,\n\t\t    callback: callback\n\t\t  };\n\t\n\t\t  if (callback && !options.noTimeout) {\n\t\t    eventObject.timeout = setTimeout(function () {\n\t\t      self._handleEventAckTimeout(eventObject);\n\t\t    }, this.options.ackTimeout);\n\t\t  }\n\t\n\t\t  var cid = null;\n\t\t  if (this.state == this.OPEN || options.force) {\n\t\t    cid = this.emitObject(eventObject, options);\n\t\t  }\n\t\t  return cid;\n\t\t};\n\t\n\t\tSCTransport.prototype.cancelPendingResponse = function (cid) {\n\t\t  delete this._callbackMap[cid];\n\t\t};\n\t\n\t\tSCTransport.prototype.decode = function (message) {\n\t\t  return this.codec.decode(message);\n\t\t};\n\t\n\t\tSCTransport.prototype.encode = function (object) {\n\t\t  return this.codec.encode(object);\n\t\t};\n\t\n\t\tSCTransport.prototype.send = function (data) {\n\t\t  if (this.socket.readyState != this.socket.OPEN) {\n\t\t    this._onClose(1005);\n\t\t  } else {\n\t\t    this.socket.send(data);\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype.serializeObject = function (object) {\n\t\t  var str, formatError;\n\t\t  try {\n\t\t    str = this.encode(object);\n\t\t  } catch (err) {\n\t\t    formatError = err;\n\t\t    this._onError(formatError);\n\t\t  }\n\t\t  if (!formatError) {\n\t\t    return str;\n\t\t  }\n\t\t  return null;\n\t\t};\n\t\n\t\tSCTransport.prototype.sendObjectBatch = function (object) {\n\t\t  var self = this;\n\t\n\t\t  this._batchSendList.push(object);\n\t\t  if (this._batchTimeout) {\n\t\t    return;\n\t\t  }\n\t\n\t\t  this._batchTimeout = setTimeout(function () {\n\t\t    delete self._batchTimeout;\n\t\t    if (self._batchSendList.length) {\n\t\t      var str = self.serializeObject(self._batchSendList);\n\t\t      if (str != null) {\n\t\t        self.send(str);\n\t\t      }\n\t\t      self._batchSendList = [];\n\t\t    }\n\t\t  }, this.options.pubSubBatchDuration || 0);\n\t\t};\n\t\n\t\tSCTransport.prototype.sendObjectSingle = function (object) {\n\t\t  var str = this.serializeObject(object);\n\t\t  if (str != null) {\n\t\t    this.send(str);\n\t\t  }\n\t\t};\n\t\n\t\tSCTransport.prototype.sendObject = function (object, options) {\n\t\t  if (options && options.batch) {\n\t\t    this.sendObjectBatch(object);\n\t\t  } else {\n\t\t    this.sendObjectSingle(object);\n\t\t  }\n\t\t};\n\t\n\t\tmodule.exports.SCTransport = SCTransport;\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ }),\n\t/* 17 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.decode = exports.parse = __webpack_require__(18);\n\t\texports.encode = exports.stringify = __webpack_require__(19);\n\t\n\t\n\t/***/ }),\n\t/* 18 */\n\t/***/ (function(module, exports) {\n\t\n\t\t// Copyright Joyent, Inc. and other Node contributors.\n\t\t//\n\t\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t\t// copy of this software and associated documentation files (the\n\t\t// \"Software\"), to deal in the Software without restriction, including\n\t\t// without limitation the rights to use, copy, modify, merge, publish,\n\t\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t\t// persons to whom the Software is furnished to do so, subject to the\n\t\t// following conditions:\n\t\t//\n\t\t// The above copyright notice and this permission notice shall be included\n\t\t// in all copies or substantial portions of the Software.\n\t\t//\n\t\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t\t'use strict';\n\t\n\t\t// If obj.hasOwnProperty has been overridden, then calling\n\t\t// obj.hasOwnProperty(prop) will break.\n\t\t// See: https://github.com/joyent/node/issues/1707\n\t\tfunction hasOwnProperty(obj, prop) {\n\t\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t\t}\n\t\n\t\tmodule.exports = function(qs, sep, eq, options) {\n\t\t  sep = sep || '&';\n\t\t  eq = eq || '=';\n\t\t  var obj = {};\n\t\n\t\t  if (typeof qs !== 'string' || qs.length === 0) {\n\t\t    return obj;\n\t\t  }\n\t\n\t\t  var regexp = /\\+/g;\n\t\t  qs = qs.split(sep);\n\t\n\t\t  var maxKeys = 1000;\n\t\t  if (options && typeof options.maxKeys === 'number') {\n\t\t    maxKeys = options.maxKeys;\n\t\t  }\n\t\n\t\t  var len = qs.length;\n\t\t  // maxKeys <= 0 means that we should not limit keys count\n\t\t  if (maxKeys > 0 && len > maxKeys) {\n\t\t    len = maxKeys;\n\t\t  }\n\t\n\t\t  for (var i = 0; i < len; ++i) {\n\t\t    var x = qs[i].replace(regexp, '%20'),\n\t\t        idx = x.indexOf(eq),\n\t\t        kstr, vstr, k, v;\n\t\n\t\t    if (idx >= 0) {\n\t\t      kstr = x.substr(0, idx);\n\t\t      vstr = x.substr(idx + 1);\n\t\t    } else {\n\t\t      kstr = x;\n\t\t      vstr = '';\n\t\t    }\n\t\n\t\t    k = decodeURIComponent(kstr);\n\t\t    v = decodeURIComponent(vstr);\n\t\n\t\t    if (!hasOwnProperty(obj, k)) {\n\t\t      obj[k] = v;\n\t\t    } else if (Array.isArray(obj[k])) {\n\t\t      obj[k].push(v);\n\t\t    } else {\n\t\t      obj[k] = [obj[k], v];\n\t\t    }\n\t\t  }\n\t\n\t\t  return obj;\n\t\t};\n\t\n\t\n\t/***/ }),\n\t/* 19 */\n\t/***/ (function(module, exports) {\n\t\n\t\t// Copyright Joyent, Inc. and other Node contributors.\n\t\t//\n\t\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t\t// copy of this software and associated documentation files (the\n\t\t// \"Software\"), to deal in the Software without restriction, including\n\t\t// without limitation the rights to use, copy, modify, merge, publish,\n\t\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t\t// persons to whom the Software is furnished to do so, subject to the\n\t\t// following conditions:\n\t\t//\n\t\t// The above copyright notice and this permission notice shall be included\n\t\t// in all copies or substantial portions of the Software.\n\t\t//\n\t\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t\t'use strict';\n\t\n\t\tvar stringifyPrimitive = function(v) {\n\t\t  switch (typeof v) {\n\t\t    case 'string':\n\t\t      return v;\n\t\n\t\t    case 'boolean':\n\t\t      return v ? 'true' : 'false';\n\t\n\t\t    case 'number':\n\t\t      return isFinite(v) ? v : '';\n\t\n\t\t    default:\n\t\t      return '';\n\t\t  }\n\t\t};\n\t\n\t\tmodule.exports = function(obj, sep, eq, name) {\n\t\t  sep = sep || '&';\n\t\t  eq = eq || '=';\n\t\t  if (obj === null) {\n\t\t    obj = undefined;\n\t\t  }\n\t\n\t\t  if (typeof obj === 'object') {\n\t\t    return Object.keys(obj).map(function(k) {\n\t\t      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\t\t      if (Array.isArray(obj[k])) {\n\t\t        return obj[k].map(function(v) {\n\t\t          return ks + encodeURIComponent(stringifyPrimitive(v));\n\t\t        }).join(sep);\n\t\t      } else {\n\t\t        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n\t\t      }\n\t\t    }).join(sep);\n\t\n\t\t  }\n\t\n\t\t  if (!name) return '';\n\t\t  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n\t\t         encodeURIComponent(stringifyPrimitive(obj));\n\t\t};\n\t\n\t\n\t/***/ }),\n\t/* 20 */\n\t/***/ (function(module, exports) {\n\t\n\t\tvar global;\n\t\tif (typeof WorkerGlobalScope !== 'undefined') {\n\t\t  global = self;\n\t\t} else {\n\t\t  global = typeof window != 'undefined' && window || (function() { return this; })();\n\t\t}\n\t\n\t\tvar WebSocket = global.WebSocket || global.MozWebSocket;\n\t\n\t\t/**\n\t\t * WebSocket constructor.\n\t\t *\n\t\t * The third `opts` options object gets ignored in web browsers, since it's\n\t\t * non-standard, and throws a TypeError if passed to the constructor.\n\t\t * See: https://github.com/einaros/ws/issues/227\n\t\t *\n\t\t * @param {String} uri\n\t\t * @param {Array} protocols (optional)\n\t\t * @param {Object} opts (optional)\n\t\t * @api public\n\t\t */\n\t\n\t\tfunction ws(uri, protocols, opts) {\n\t\t  var instance;\n\t\t  if (protocols) {\n\t\t    instance = new WebSocket(uri, protocols);\n\t\t  } else {\n\t\t    instance = new WebSocket(uri);\n\t\t  }\n\t\t  return instance;\n\t\t}\n\t\n\t\tif (WebSocket) ws.prototype = WebSocket.prototype;\n\t\n\t\tmodule.exports = WebSocket ? ws : null;\n\t\n\t\n\t/***/ }),\n\t/* 21 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tmodule.exports = __webpack_require__(22);\n\t\n\t\n\t/***/ }),\n\t/* 22 */\n\t/***/ (function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\t/**\n\t\t * Constants.\n\t\t */\n\t\n\t\tvar errorMessage;\n\t\n\t\terrorMessage = 'An argument without append, prepend, ' +\n\t\t    'or detach methods was given to `List';\n\t\n\t\t/**\n\t\t * Creates a new List: A linked list is a bit like an Array, but\n\t\t * knows nothing about how many items are in it, and knows only about its\n\t\t * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n\t\t * &c.) knows which item comes before or after it (its more like the\n\t\t * implementation of the DOM in JavaScript).\n\t\t * @global\n\t\t * @private\n\t\t * @constructor\n\t\t * @class Represents an instance of List.\n\t\t */\n\t\n\t\tfunction List(/*items...*/) {\n\t\t    if (arguments.length) {\n\t\t        return List.from(arguments);\n\t\t    }\n\t\t}\n\t\n\t\tvar ListPrototype;\n\t\n\t\tListPrototype = List.prototype;\n\t\n\t\t/**\n\t\t * Creates a new list from the arguments (each a list item) passed in.\n\t\t * @name List.of\n\t\t * @param {...ListItem} [items] - Zero or more items to attach.\n\t\t * @returns {list} - A new instance of List.\n\t\t */\n\t\n\t\tList.of = function (/*items...*/) {\n\t\t    return List.from.call(this, arguments);\n\t\t};\n\t\n\t\t/**\n\t\t * Creates a new list from the given array-like object (each a list item)\n\t\t * passed in.\n\t\t * @name List.from\n\t\t * @param {ListItem[]} [items] - The items to append.\n\t\t * @returns {list} - A new instance of List.\n\t\t */\n\t\tList.from = function (items) {\n\t\t    var list = new this(), length, iterator, item;\n\t\n\t\t    if (items && (length = items.length)) {\n\t\t        iterator = -1;\n\t\n\t\t        while (++iterator < length) {\n\t\t            item = items[iterator];\n\t\n\t\t            if (item !== null && item !== undefined) {\n\t\t                list.append(item);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\n\t\t    return list;\n\t\t};\n\t\n\t\t/**\n\t\t * List#head\n\t\t * Default to `null`.\n\t\t */\n\t\tListPrototype.head = null;\n\t\n\t\t/**\n\t\t * List#tail\n\t\t * Default to `null`.\n\t\t */\n\t\tListPrototype.tail = null;\n\t\n\t\t/**\n\t\t * Returns the list's items as an array. This does *not* detach the items.\n\t\t * @name List#toArray\n\t\t * @returns {ListItem[]} - An array of (still attached) ListItems.\n\t\t */\n\t\tListPrototype.toArray = function () {\n\t\t    var item = this.head,\n\t\t        result = [];\n\t\n\t\t    while (item) {\n\t\t        result.push(item);\n\t\t        item = item.next;\n\t\t    }\n\t\n\t\t    return result;\n\t\t};\n\t\n\t\t/**\n\t\t * Prepends the given item to the list: Item will be the new first item\n\t\t * (`head`).\n\t\t * @name List#prepend\n\t\t * @param {ListItem} item - The item to prepend.\n\t\t * @returns {ListItem} - An instance of ListItem (the given item).\n\t\t */\n\t\tListPrototype.prepend = function (item) {\n\t\t    if (!item) {\n\t\t        return false;\n\t\t    }\n\t\n\t\t    if (!item.append || !item.prepend || !item.detach) {\n\t\t        throw new Error(errorMessage + '#prepend`.');\n\t\t    }\n\t\n\t\t    var self, head;\n\t\n\t\t    // Cache self.\n\t\t    self = this;\n\t\n\t\t    // If self has a first item, defer prepend to the first items prepend\n\t\t    // method, and return the result.\n\t\t    head = self.head;\n\t\n\t\t    if (head) {\n\t\t        return head.prepend(item);\n\t\t    }\n\t\n\t\t    // ...otherwise, there is no `head` (or `tail`) item yet.\n\t\n\t\t    // Detach the prependee.\n\t\t    item.detach();\n\t\n\t\t    // Set the prependees parent list to reference self.\n\t\t    item.list = self;\n\t\n\t\t    // Set self's first item to the prependee, and return the item.\n\t\t    self.head = item;\n\t\n\t\t    return item;\n\t\t};\n\t\n\t\t/**\n\t\t * Appends the given item to the list: Item will be the new last item (`tail`)\n\t\t * if the list had a first item, and its first item (`head`) otherwise.\n\t\t * @name List#append\n\t\t * @param {ListItem} item - The item to append.\n\t\t * @returns {ListItem} - An instance of ListItem (the given item).\n\t\t */\n\t\n\t\tListPrototype.append = function (item) {\n\t\t    if (!item) {\n\t\t        return false;\n\t\t    }\n\t\n\t\t    if (!item.append || !item.prepend || !item.detach) {\n\t\t        throw new Error(errorMessage + '#append`.');\n\t\t    }\n\t\n\t\t    var self, head, tail;\n\t\n\t\t    // Cache self.\n\t\t    self = this;\n\t\n\t\t    // If self has a last item, defer appending to the last items append\n\t\t    // method, and return the result.\n\t\t    tail = self.tail;\n\t\n\t\t    if (tail) {\n\t\t        return tail.append(item);\n\t\t    }\n\t\n\t\t    // If self has a first item, defer appending to the first items append\n\t\t    // method, and return the result.\n\t\t    head = self.head;\n\t\n\t\t    if (head) {\n\t\t        return head.append(item);\n\t\t    }\n\t\n\t\t    // ...otherwise, there is no `tail` or `head` item yet.\n\t\n\t\t    // Detach the appendee.\n\t\t    item.detach();\n\t\n\t\t    // Set the appendees parent list to reference self.\n\t\t    item.list = self;\n\t\n\t\t    // Set self's first item to the appendee, and return the item.\n\t\t    self.head = item;\n\t\n\t\t    return item;\n\t\t};\n\t\n\t\t/**\n\t\t * Creates a new ListItem: A linked list item is a bit like DOM node:\n\t\t * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n\t\t * and the item after it (`next`).\n\t\t * @global\n\t\t * @private\n\t\t * @constructor\n\t\t * @class Represents an instance of ListItem.\n\t\t */\n\t\n\t\tfunction ListItem() {}\n\t\n\t\tList.Item = ListItem;\n\t\n\t\tvar ListItemPrototype = ListItem.prototype;\n\t\n\t\tListItemPrototype.next = null;\n\t\n\t\tListItemPrototype.prev = null;\n\t\n\t\tListItemPrototype.list = null;\n\t\n\t\t/**\n\t\t * Detaches the item operated on from its parent list.\n\t\t * @name ListItem#detach\n\t\t * @returns {ListItem} - The item operated on.\n\t\t */\n\t\tListItemPrototype.detach = function () {\n\t\t    // Cache self, the parent list, and the previous and next items.\n\t\t    var self = this,\n\t\t        list = self.list,\n\t\t        prev = self.prev,\n\t\t        next = self.next;\n\t\n\t\t    // If the item is already detached, return self.\n\t\t    if (!list) {\n\t\t        return self;\n\t\t    }\n\t\n\t\t    // If self is the last item in the parent list, link the lists last item\n\t\t    // to the previous item.\n\t\t    if (list.tail === self) {\n\t\t        list.tail = prev;\n\t\t    }\n\t\n\t\t    // If self is the first item in the parent list, link the lists first item\n\t\t    // to the next item.\n\t\t    if (list.head === self) {\n\t\t        list.head = next;\n\t\t    }\n\t\n\t\t    // If both the last and first items in the parent list are the same,\n\t\t    // remove the link to the last item.\n\t\t    if (list.tail === list.head) {\n\t\t        list.tail = null;\n\t\t    }\n\t\n\t\t    // If a previous item exists, link its next item to selfs next item.\n\t\t    if (prev) {\n\t\t        prev.next = next;\n\t\t    }\n\t\n\t\t    // If a next item exists, link its previous item to selfs previous item.\n\t\t    if (next) {\n\t\t        next.prev = prev;\n\t\t    }\n\t\n\t\t    // Remove links from self to both the next and previous items, and to the\n\t\t    // parent list.\n\t\t    self.prev = self.next = self.list = null;\n\t\n\t\t    // Return self.\n\t\t    return self;\n\t\t};\n\t\n\t\t/**\n\t\t * Prepends the given item *before* the item operated on.\n\t\t * @name ListItem#prepend\n\t\t * @param {ListItem} item - The item to prepend.\n\t\t * @returns {ListItem} - The item operated on, or false when that item is not\n\t\t * attached.\n\t\t */\n\t\tListItemPrototype.prepend = function (item) {\n\t\t    if (!item || !item.append || !item.prepend || !item.detach) {\n\t\t        throw new Error(errorMessage + 'Item#prepend`.');\n\t\t    }\n\t\n\t\t    // Cache self, the parent list, and the previous item.\n\t\t    var self = this,\n\t\t        list = self.list,\n\t\t        prev = self.prev;\n\t\n\t\t    // If self is detached, return false.\n\t\t    if (!list) {\n\t\t        return false;\n\t\t    }\n\t\n\t\t    // Detach the prependee.\n\t\t    item.detach();\n\t\n\t\t    // If self has a previous item...\n\t\t    if (prev) {\n\t\t        // ...link the prependees previous item, to selfs previous item.\n\t\t        item.prev = prev;\n\t\n\t\t        // ...link the previous items next item, to self.\n\t\t        prev.next = item;\n\t\t    }\n\t\n\t\t    // Set the prependees next item to self.\n\t\t    item.next = self;\n\t\n\t\t    // Set the prependees parent list to selfs parent list.\n\t\t    item.list = list;\n\t\n\t\t    // Set the previous item of self to the prependee.\n\t\t    self.prev = item;\n\t\n\t\t    // If self is the first item in the parent list, link the lists first item\n\t\t    // to the prependee.\n\t\t    if (self === list.head) {\n\t\t        list.head = item;\n\t\t    }\n\t\n\t\t    // If the the parent list has no last item, link the lists last item to\n\t\t    // self.\n\t\t    if (!list.tail) {\n\t\t        list.tail = self;\n\t\t    }\n\t\n\t\t    // Return the prependee.\n\t\t    return item;\n\t\t};\n\t\n\t\t/**\n\t\t * Appends the given item *after* the item operated on.\n\t\t * @name ListItem#append\n\t\t * @param {ListItem} item - The item to append.\n\t\t * @returns {ListItem} - The item operated on, or false when that item is not\n\t\t * attached.\n\t\t */\n\t\tListItemPrototype.append = function (item) {\n\t\t    // If item is falsey, return false.\n\t\t    if (!item || !item.append || !item.prepend || !item.detach) {\n\t\t        throw new Error(errorMessage + 'Item#append`.');\n\t\t    }\n\t\n\t\t    // Cache self, the parent list, and the next item.\n\t\t    var self = this,\n\t\t        list = self.list,\n\t\t        next = self.next;\n\t\n\t\t    // If self is detached, return false.\n\t\t    if (!list) {\n\t\t        return false;\n\t\t    }\n\t\n\t\t    // Detach the appendee.\n\t\t    item.detach();\n\t\n\t\t    // If self has a next item...\n\t\t    if (next) {\n\t\t        // ...link the appendees next item, to selfs next item.\n\t\t        item.next = next;\n\t\n\t\t        // ...link the next items previous item, to the appendee.\n\t\t        next.prev = item;\n\t\t    }\n\t\n\t\t    // Set the appendees previous item to self.\n\t\t    item.prev = self;\n\t\n\t\t    // Set the appendees parent list to selfs parent list.\n\t\t    item.list = list;\n\t\n\t\t    // Set the next item of self to the appendee.\n\t\t    self.next = item;\n\t\n\t\t    // If the the parent list has no last item or if self is the parent lists\n\t\t    // last item, link the lists last item to the appendee.\n\t\t    if (self === list.tail || !list.tail) {\n\t\t        list.tail = item;\n\t\t    }\n\t\n\t\t    // Return the appendee.\n\t\t    return item;\n\t\t};\n\t\n\t\t/**\n\t\t * Expose `List`.\n\t\t */\n\t\n\t\tmodule.exports = List;\n\t\n\t\n\t/***/ }),\n\t/* 23 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */\n\t\t;(function(root) {\n\t\n\t\t\t// Detect free variables `exports`.\n\t\t\tvar freeExports = typeof exports == 'object' && exports;\n\t\n\t\t\t// Detect free variable `module`.\n\t\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\t\tmodule.exports == freeExports && module;\n\t\n\t\t\t// Detect free variable `global`, from Node.js or Browserified code, and use\n\t\t\t// it as `root`.\n\t\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\t\troot = freeGlobal;\n\t\t\t}\n\t\n\t\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t\tvar InvalidCharacterError = function(message) {\n\t\t\t\tthis.message = message;\n\t\t\t};\n\t\t\tInvalidCharacterError.prototype = new Error;\n\t\t\tInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\t\n\t\t\tvar error = function(message) {\n\t\t\t\t// Note: the error messages used throughout this file match those used by\n\t\t\t\t// the native `atob`/`btoa` implementation in Chromium.\n\t\t\t\tthrow new InvalidCharacterError(message);\n\t\t\t};\n\t\n\t\t\tvar TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t// http://whatwg.org/html/common-microsyntaxes.html#space-character\n\t\t\tvar REGEX_SPACE_CHARACTERS = /[\\t\\n\\f\\r ]/g;\n\t\n\t\t\t// `decode` is designed to be fully compatible with `atob` as described in the\n\t\t\t// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob\n\t\t\t// The optimized base64-decoding algorithm used is based on @atks excellent\n\t\t\t// implementation. https://gist.github.com/atk/1020396\n\t\t\tvar decode = function(input) {\n\t\t\t\tinput = String(input)\n\t\t\t\t\t.replace(REGEX_SPACE_CHARACTERS, '');\n\t\t\t\tvar length = input.length;\n\t\t\t\tif (length % 4 == 0) {\n\t\t\t\t\tinput = input.replace(/==?$/, '');\n\t\t\t\t\tlength = input.length;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tlength % 4 == 1 ||\n\t\t\t\t\t// http://whatwg.org/C#alphanumeric-ascii-characters\n\t\t\t\t\t/[^+a-zA-Z0-9/]/.test(input)\n\t\t\t\t) {\n\t\t\t\t\terror(\n\t\t\t\t\t\t'Invalid character: the string to be decoded is not correctly encoded.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tvar bitCounter = 0;\n\t\t\t\tvar bitStorage;\n\t\t\t\tvar buffer;\n\t\t\t\tvar output = '';\n\t\t\t\tvar position = -1;\n\t\t\t\twhile (++position < length) {\n\t\t\t\t\tbuffer = TABLE.indexOf(input.charAt(position));\n\t\t\t\t\tbitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;\n\t\t\t\t\t// Unless this is the first of a group of 4 characters\n\t\t\t\t\tif (bitCounter++ % 4) {\n\t\t\t\t\t\t// convert the first 8 bits to a single ASCII character.\n\t\t\t\t\t\toutput += String.fromCharCode(\n\t\t\t\t\t\t\t0xFF & bitStorage >> (-2 * bitCounter & 6)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t};\n\t\n\t\t\t// `encode` is designed to be fully compatible with `btoa` as described in the\n\t\t\t// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa\n\t\t\tvar encode = function(input) {\n\t\t\t\tinput = String(input);\n\t\t\t\tif (/[^\\0-\\xFF]/.test(input)) {\n\t\t\t\t\t// Note: no need to special-case astral symbols here, as surrogates are\n\t\t\t\t\t// matched, and the input is supposed to only contain ASCII anyway.\n\t\t\t\t\terror(\n\t\t\t\t\t\t'The string to be encoded contains characters outside of the ' +\n\t\t\t\t\t\t'Latin1 range.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tvar padding = input.length % 3;\n\t\t\t\tvar output = '';\n\t\t\t\tvar position = -1;\n\t\t\t\tvar a;\n\t\t\t\tvar b;\n\t\t\t\tvar c;\n\t\t\t\tvar d;\n\t\t\t\tvar buffer;\n\t\t\t\t// Make sure any padding is handled outside of the loop.\n\t\t\t\tvar length = input.length - padding;\n\t\n\t\t\t\twhile (++position < length) {\n\t\t\t\t\t// Read three bytes, i.e. 24 bits.\n\t\t\t\t\ta = input.charCodeAt(position) << 16;\n\t\t\t\t\tb = input.charCodeAt(++position) << 8;\n\t\t\t\t\tc = input.charCodeAt(++position);\n\t\t\t\t\tbuffer = a + b + c;\n\t\t\t\t\t// Turn the 24 bits into four chunks of 6 bits each, and append the\n\t\t\t\t\t// matching character for each of them to the output.\n\t\t\t\t\toutput += (\n\t\t\t\t\t\tTABLE.charAt(buffer >> 18 & 0x3F) +\n\t\t\t\t\t\tTABLE.charAt(buffer >> 12 & 0x3F) +\n\t\t\t\t\t\tTABLE.charAt(buffer >> 6 & 0x3F) +\n\t\t\t\t\t\tTABLE.charAt(buffer & 0x3F)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tif (padding == 2) {\n\t\t\t\t\ta = input.charCodeAt(position) << 8;\n\t\t\t\t\tb = input.charCodeAt(++position);\n\t\t\t\t\tbuffer = a + b;\n\t\t\t\t\toutput += (\n\t\t\t\t\t\tTABLE.charAt(buffer >> 10) +\n\t\t\t\t\t\tTABLE.charAt((buffer >> 4) & 0x3F) +\n\t\t\t\t\t\tTABLE.charAt((buffer << 2) & 0x3F) +\n\t\t\t\t\t\t'='\n\t\t\t\t\t);\n\t\t\t\t} else if (padding == 1) {\n\t\t\t\t\tbuffer = input.charCodeAt(position);\n\t\t\t\t\toutput += (\n\t\t\t\t\t\tTABLE.charAt(buffer >> 2) +\n\t\t\t\t\t\tTABLE.charAt((buffer << 4) & 0x3F) +\n\t\t\t\t\t\t'=='\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\treturn output;\n\t\t\t};\n\t\n\t\t\tvar base64 = {\n\t\t\t\t'encode': encode,\n\t\t\t\t'decode': decode,\n\t\t\t\t'version': '0.1.0'\n\t\t\t};\n\t\n\t\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t\t// like the following:\n\t\t\tif (\n\t\t\t\ttrue\n\t\t\t) {\n\t\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\t\treturn base64;\n\t\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\t\tfreeModule.exports = base64;\n\t\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\t\tfor (var key in base64) {\n\t\t\t\t\t\tbase64.hasOwnProperty(key) && (freeExports[key] = base64[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { // in Rhino or a web browser\n\t\t\t\troot.base64 = base64;\n\t\t\t}\n\t\n\t\t}(this));\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)(module), (function() { return this; }())))\n\t\n\t/***/ }),\n\t/* 24 */\n\t/***/ (function(module, exports) {\n\t\n\t\tmodule.exports = function(module) {\n\t\t\tif(!module.webpackPolyfill) {\n\t\t\t\tmodule.deprecate = function() {};\n\t\t\t\tmodule.paths = [];\n\t\t\t\t// module.parent = undefined by default\n\t\t\t\tmodule.children = [];\n\t\t\t\tmodule.webpackPolyfill = 1;\n\t\t\t}\n\t\t\treturn module;\n\t\t}\n\t\n\t\n\t/***/ }),\n\t/* 25 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {\n\t\t'use strict';\n\t\n\t\tfunction _instanceof(obj, type) {\n\t\t  return type != null && obj instanceof type;\n\t\t}\n\t\n\t\tvar nativeMap;\n\t\ttry {\n\t\t  nativeMap = Map;\n\t\t} catch(_) {\n\t\t  // maybe a reference error because no `Map`. Give it a dummy value that no\n\t\t  // value will ever be an instanceof.\n\t\t  nativeMap = function() {};\n\t\t}\n\t\n\t\tvar nativeSet;\n\t\ttry {\n\t\t  nativeSet = Set;\n\t\t} catch(_) {\n\t\t  nativeSet = function() {};\n\t\t}\n\t\n\t\tvar nativePromise;\n\t\ttry {\n\t\t  nativePromise = Promise;\n\t\t} catch(_) {\n\t\t  nativePromise = function() {};\n\t\t}\n\t\n\t\t/**\n\t\t * Clones (copies) an Object using deep copying.\n\t\t *\n\t\t * This function supports circular references by default, but if you are certain\n\t\t * there are no circular references in your object, you can save some CPU time\n\t\t * by calling clone(obj, false).\n\t\t *\n\t\t * Caution: if `circular` is false and `parent` contains circular references,\n\t\t * your program may enter an infinite loop and crash.\n\t\t *\n\t\t * @param `parent` - the object to be cloned\n\t\t * @param `circular` - set to true if the object to be cloned may contain\n\t\t *    circular references. (optional - true by default)\n\t\t * @param `depth` - set to a number if the object is only to be cloned to\n\t\t *    a particular depth. (optional - defaults to Infinity)\n\t\t * @param `prototype` - sets the prototype to be used when cloning an object.\n\t\t *    (optional - defaults to parent prototype).\n\t\t * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n\t\t *    should be cloned as well. Non-enumerable properties on the prototype\n\t\t *    chain will be ignored. (optional - false by default)\n\t\t*/\n\t\tfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n\t\t  if (typeof circular === 'object') {\n\t\t    depth = circular.depth;\n\t\t    prototype = circular.prototype;\n\t\t    includeNonEnumerable = circular.includeNonEnumerable;\n\t\t    circular = circular.circular;\n\t\t  }\n\t\t  // maintain two arrays for circular references, where corresponding parents\n\t\t  // and children have the same index\n\t\t  var allParents = [];\n\t\t  var allChildren = [];\n\t\n\t\t  var useBuffer = typeof Buffer != 'undefined';\n\t\n\t\t  if (typeof circular == 'undefined')\n\t\t    circular = true;\n\t\n\t\t  if (typeof depth == 'undefined')\n\t\t    depth = Infinity;\n\t\n\t\t  // recurse this function so we don't reset allParents and allChildren\n\t\t  function _clone(parent, depth) {\n\t\t    // cloning null always returns null\n\t\t    if (parent === null)\n\t\t      return null;\n\t\n\t\t    if (depth === 0)\n\t\t      return parent;\n\t\n\t\t    var child;\n\t\t    var proto;\n\t\t    if (typeof parent != 'object') {\n\t\t      return parent;\n\t\t    }\n\t\n\t\t    if (_instanceof(parent, nativeMap)) {\n\t\t      child = new nativeMap();\n\t\t    } else if (_instanceof(parent, nativeSet)) {\n\t\t      child = new nativeSet();\n\t\t    } else if (_instanceof(parent, nativePromise)) {\n\t\t      child = new nativePromise(function (resolve, reject) {\n\t\t        parent.then(function(value) {\n\t\t          resolve(_clone(value, depth - 1));\n\t\t        }, function(err) {\n\t\t          reject(_clone(err, depth - 1));\n\t\t        });\n\t\t      });\n\t\t    } else if (clone.__isArray(parent)) {\n\t\t      child = [];\n\t\t    } else if (clone.__isRegExp(parent)) {\n\t\t      child = new RegExp(parent.source, __getRegExpFlags(parent));\n\t\t      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n\t\t    } else if (clone.__isDate(parent)) {\n\t\t      child = new Date(parent.getTime());\n\t\t    } else if (useBuffer && Buffer.isBuffer(parent)) {\n\t\t      child = new Buffer(parent.length);\n\t\t      parent.copy(child);\n\t\t      return child;\n\t\t    } else if (_instanceof(parent, Error)) {\n\t\t      child = Object.create(parent);\n\t\t    } else {\n\t\t      if (typeof prototype == 'undefined') {\n\t\t        proto = Object.getPrototypeOf(parent);\n\t\t        child = Object.create(proto);\n\t\t      }\n\t\t      else {\n\t\t        child = Object.create(prototype);\n\t\t        proto = prototype;\n\t\t      }\n\t\t    }\n\t\n\t\t    if (circular) {\n\t\t      var index = allParents.indexOf(parent);\n\t\n\t\t      if (index != -1) {\n\t\t        return allChildren[index];\n\t\t      }\n\t\t      allParents.push(parent);\n\t\t      allChildren.push(child);\n\t\t    }\n\t\n\t\t    if (_instanceof(parent, nativeMap)) {\n\t\t      parent.forEach(function(value, key) {\n\t\t        var keyChild = _clone(key, depth - 1);\n\t\t        var valueChild = _clone(value, depth - 1);\n\t\t        child.set(keyChild, valueChild);\n\t\t      });\n\t\t    }\n\t\t    if (_instanceof(parent, nativeSet)) {\n\t\t      parent.forEach(function(value) {\n\t\t        var entryChild = _clone(value, depth - 1);\n\t\t        child.add(entryChild);\n\t\t      });\n\t\t    }\n\t\n\t\t    for (var i in parent) {\n\t\t      var attrs;\n\t\t      if (proto) {\n\t\t        attrs = Object.getOwnPropertyDescriptor(proto, i);\n\t\t      }\n\t\n\t\t      if (attrs && attrs.set == null) {\n\t\t        continue;\n\t\t      }\n\t\t      child[i] = _clone(parent[i], depth - 1);\n\t\t    }\n\t\n\t\t    if (Object.getOwnPropertySymbols) {\n\t\t      var symbols = Object.getOwnPropertySymbols(parent);\n\t\t      for (var i = 0; i < symbols.length; i++) {\n\t\t        // Don't need to worry about cloning a symbol because it is a primitive,\n\t\t        // like a number or string.\n\t\t        var symbol = symbols[i];\n\t\t        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n\t\t        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n\t\t          continue;\n\t\t        }\n\t\t        child[symbol] = _clone(parent[symbol], depth - 1);\n\t\t        if (!descriptor.enumerable) {\n\t\t          Object.defineProperty(child, symbol, {\n\t\t            enumerable: false\n\t\t          });\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    if (includeNonEnumerable) {\n\t\t      var allPropertyNames = Object.getOwnPropertyNames(parent);\n\t\t      for (var i = 0; i < allPropertyNames.length; i++) {\n\t\t        var propertyName = allPropertyNames[i];\n\t\t        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n\t\t        if (descriptor && descriptor.enumerable) {\n\t\t          continue;\n\t\t        }\n\t\t        child[propertyName] = _clone(parent[propertyName], depth - 1);\n\t\t        Object.defineProperty(child, propertyName, {\n\t\t          enumerable: false\n\t\t        });\n\t\t      }\n\t\t    }\n\t\n\t\t    return child;\n\t\t  }\n\t\n\t\t  return _clone(parent, depth);\n\t\t}\n\t\n\t\t/**\n\t\t * Simple flat clone using prototype, accepts only objects, usefull for property\n\t\t * override on FLAT configuration object (no nested props).\n\t\t *\n\t\t * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n\t\t * works.\n\t\t */\n\t\tclone.clonePrototype = function clonePrototype(parent) {\n\t\t  if (parent === null)\n\t\t    return null;\n\t\n\t\t  var c = function () {};\n\t\t  c.prototype = parent;\n\t\t  return new c();\n\t\t};\n\t\n\t\t// private utility functions\n\t\n\t\tfunction __objToStr(o) {\n\t\t  return Object.prototype.toString.call(o);\n\t\t}\n\t\tclone.__objToStr = __objToStr;\n\t\n\t\tfunction __isDate(o) {\n\t\t  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n\t\t}\n\t\tclone.__isDate = __isDate;\n\t\n\t\tfunction __isArray(o) {\n\t\t  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n\t\t}\n\t\tclone.__isArray = __isArray;\n\t\n\t\tfunction __isRegExp(o) {\n\t\t  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n\t\t}\n\t\tclone.__isRegExp = __isRegExp;\n\t\n\t\tfunction __getRegExpFlags(re) {\n\t\t  var flags = '';\n\t\t  if (re.global) flags += 'g';\n\t\t  if (re.ignoreCase) flags += 'i';\n\t\t  if (re.multiline) flags += 'm';\n\t\t  return flags;\n\t\t}\n\t\tclone.__getRegExpFlags = __getRegExpFlags;\n\t\n\t\treturn clone;\n\t\t})();\n\t\n\t\tif (typeof module === 'object' && module.exports) {\n\t\t  module.exports = clone;\n\t\t}\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))\n\t\n\t/***/ }),\n\t/* 26 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\t\n\t\t/* WEBPACK VAR INJECTION */(function(global) {var SCSocket = __webpack_require__(4);\n\t\tvar scErrors = __webpack_require__(12);\n\t\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\t\n\t\tvar _connections = {};\n\t\n\t\tfunction getMultiplexId(options) {\n\t\t  var protocolPrefix = options.secure ? 'https://' : 'http://';\n\t\t  var queryString = '';\n\t\t  if (options.query) {\n\t\t    if (typeof options.query == 'string') {\n\t\t      queryString = options.query;\n\t\t    } else {\n\t\t      var queryArray = [];\n\t\t      var queryMap = options.query;\n\t\t      for (var key in queryMap) {\n\t\t        if (queryMap.hasOwnProperty(key)) {\n\t\t          queryArray.push(key + '=' + queryMap[key]);\n\t\t        }\n\t\t      }\n\t\t      if (queryArray.length) {\n\t\t        queryString = '?' + queryArray.join('&');\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  var host;\n\t\t  if (options.host) {\n\t\t    host = options.host;\n\t\t  } else {\n\t\t    host = options.hostname + ':' + options.port;\n\t\t  }\n\t\t  return protocolPrefix + host + options.path + queryString;\n\t\t}\n\t\n\t\tfunction isUrlSecure() {\n\t\t  return global.location && location.protocol == 'https:';\n\t\t}\n\t\n\t\tfunction getPort(options, isSecureDefault) {\n\t\t  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n\t\t  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n\t\t}\n\t\n\t\tfunction connect(options) {\n\t\t  var self = this;\n\t\n\t\t  options = options || {};\n\t\n\t\t  if (options.host && options.port) {\n\t\t    throw new InvalidArgumentsError('The host option should already include the' +\n\t\t      ' port number in the format hostname:port - Because of this, the host and port options' +\n\t\t      ' cannot be specified together; use the hostname option instead');\n\t\t  }\n\t\n\t\t  var isSecureDefault = isUrlSecure();\n\t\n\t\t  var opts = {\n\t\t    port: getPort(options, isSecureDefault),\n\t\t    hostname: global.location && location.hostname,\n\t\t    path: '/socketcluster/',\n\t\t    secure: isSecureDefault,\n\t\t    autoConnect: true,\n\t\t    autoReconnect: true,\n\t\t    autoSubscribeOnConnect: true,\n\t\t    connectTimeout: 20000,\n\t\t    ackTimeout: 10000,\n\t\t    timestampRequests: false,\n\t\t    timestampParam: 't',\n\t\t    authEngine: null,\n\t\t    authTokenName: 'socketCluster.authToken',\n\t\t    binaryType: 'arraybuffer',\n\t\t    multiplex: true,\n\t\t    pubSubBatchDuration: null,\n\t\t    cloneData: false\n\t\t  };\n\t\t  for (var i in options) {\n\t\t    if (options.hasOwnProperty(i)) {\n\t\t      opts[i] = options[i];\n\t\t    }\n\t\t  }\n\t\t  var multiplexId = getMultiplexId(opts);\n\t\t  if (opts.multiplex === false) {\n\t\t    return new SCSocket(opts);\n\t\t  }\n\t\t  if (_connections[multiplexId]) {\n\t\t    _connections[multiplexId].connect();\n\t\t  } else {\n\t\t    _connections[multiplexId] = new SCSocket(opts);\n\t\t  }\n\t\t  return _connections[multiplexId];\n\t\t}\n\t\n\t\tfunction destroy(options) {\n\t\t  var self = this;\n\t\n\t\t  options = options || {};\n\t\t  var isSecureDefault = isUrlSecure();\n\t\n\t\t  var opts = {\n\t\t    port: getPort(options, isSecureDefault),\n\t\t    hostname: global.location && location.hostname,\n\t\t    path: '/socketcluster/',\n\t\t    secure: isSecureDefault\n\t\t  };\n\t\t  for (var i in options) {\n\t\t    if (options.hasOwnProperty(i)) {\n\t\t      opts[i] = options[i];\n\t\t    }\n\t\t  }\n\t\t  var multiplexId = getMultiplexId(opts);\n\t\t  var socket = _connections[multiplexId];\n\t\t  if (socket) {\n\t\t    socket.destroy();\n\t\t  }\n\t\t  delete _connections[multiplexId];\n\t\t}\n\t\n\t\tmodule.exports = {\n\t\t  connect: connect,\n\t\t  destroy: destroy,\n\t\t  connections: _connections\n\t\t};\n\t\n\t\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\t\n\t/***/ })\n\t/******/ ])\n\t});\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(5)\n\tvar ieee754 = __webpack_require__(6)\n\tvar isArray = __webpack_require__(7)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var SCSocket = __webpack_require__(3);\n\tvar scErrors = __webpack_require__(9);\n\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\t\n\tvar _connections = {};\n\t\n\tfunction getMultiplexId(options) {\n\t  var protocolPrefix = options.secure ? 'https://' : 'http://';\n\t  var queryString = '';\n\t  if (options.query) {\n\t    if (typeof options.query == 'string') {\n\t      queryString = options.query;\n\t    } else {\n\t      var queryArray = [];\n\t      var queryMap = options.query;\n\t      for (var key in queryMap) {\n\t        if (queryMap.hasOwnProperty(key)) {\n\t          queryArray.push(key + '=' + queryMap[key]);\n\t        }\n\t      }\n\t      if (queryArray.length) {\n\t        queryString = '?' + queryArray.join('&');\n\t      }\n\t    }\n\t  }\n\t  var host;\n\t  if (options.host) {\n\t    host = options.host;\n\t  } else {\n\t    host = options.hostname + ':' + options.port;\n\t  }\n\t  return protocolPrefix + host + options.path + queryString;\n\t}\n\t\n\tfunction isUrlSecure() {\n\t  return global.location && location.protocol == 'https:';\n\t}\n\t\n\tfunction getPort(options, isSecureDefault) {\n\t  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n\t  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n\t}\n\t\n\tfunction connect(options) {\n\t  var self = this;\n\t\n\t  options = options || {};\n\t\n\t  if (options.host && options.port) {\n\t    throw new InvalidArgumentsError('The host option should already include the' +\n\t      ' port number in the format hostname:port - Because of this, the host and port options' +\n\t      ' cannot be specified together; use the hostname option instead');\n\t  }\n\t\n\t  var isSecureDefault = isUrlSecure();\n\t\n\t  var opts = {\n\t    port: getPort(options, isSecureDefault),\n\t    hostname: global.location && location.hostname,\n\t    path: '/socketcluster/',\n\t    secure: isSecureDefault,\n\t    autoConnect: true,\n\t    autoReconnect: true,\n\t    autoSubscribeOnConnect: true,\n\t    connectTimeout: 20000,\n\t    ackTimeout: 10000,\n\t    timestampRequests: false,\n\t    timestampParam: 't',\n\t    authEngine: null,\n\t    authTokenName: 'socketCluster.authToken',\n\t    binaryType: 'arraybuffer',\n\t    multiplex: true,\n\t    pubSubBatchDuration: null,\n\t    cloneData: false\n\t  };\n\t  for (var i in options) {\n\t    if (options.hasOwnProperty(i)) {\n\t      opts[i] = options[i];\n\t    }\n\t  }\n\t  var multiplexId = getMultiplexId(opts);\n\t  if (opts.multiplex === false) {\n\t    return new SCSocket(opts);\n\t  }\n\t  if (_connections[multiplexId]) {\n\t    _connections[multiplexId].connect();\n\t  } else {\n\t    _connections[multiplexId] = new SCSocket(opts);\n\t  }\n\t  return _connections[multiplexId];\n\t}\n\t\n\tfunction destroy(options) {\n\t  var self = this;\n\t\n\t  options = options || {};\n\t  var isSecureDefault = isUrlSecure();\n\t\n\t  var opts = {\n\t    port: getPort(options, isSecureDefault),\n\t    hostname: global.location && location.hostname,\n\t    path: '/socketcluster/',\n\t    secure: isSecureDefault\n\t  };\n\t  for (var i in options) {\n\t    if (options.hasOwnProperty(i)) {\n\t      opts[i] = options[i];\n\t    }\n\t  }\n\t  var multiplexId = getMultiplexId(opts);\n\t  var socket = _connections[multiplexId];\n\t  if (socket) {\n\t    socket.destroy();\n\t  }\n\t  delete _connections[multiplexId];\n\t}\n\t\n\tmodule.exports = {\n\t  connect: connect,\n\t  destroy: destroy,\n\t  connections: _connections\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar decycle = __webpack_require__(10);\r\n\t\r\n\tvar isStrict = (function () { return !this; })();\r\n\t\r\n\tfunction AuthTokenExpiredError(message, expiry) {\r\n\t  this.name = 'AuthTokenExpiredError';\r\n\t  this.message = message;\r\n\t  this.expiry = expiry;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenExpiredError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction AuthTokenInvalidError(message) {\r\n\t  this.name = 'AuthTokenInvalidError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenInvalidError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction AuthTokenNotBeforeError(message, date) {\r\n\t  this.name = 'AuthTokenNotBeforeError';\r\n\t  this.message = message;\r\n\t  this.date = date;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\t// For any other auth token error.\r\n\tfunction AuthTokenError(message) {\r\n\t  this.name = 'AuthTokenError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tAuthTokenError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction SilentMiddlewareBlockedError(message, type) {\r\n\t  this.name = 'SilentMiddlewareBlockedError';\r\n\t  this.message = message;\r\n\t  this.type = type;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction InvalidActionError(message) {\r\n\t  this.name = 'InvalidActionError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidActionError.prototype = Object.create(Error.prototype);\r\n\t\r\n\tfunction InvalidArgumentsError(message) {\r\n\t  this.name = 'InvalidArgumentsError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidArgumentsError.prototype = Object.create(Error.prototype);\r\n\t\r\n\tfunction InvalidOptionsError(message) {\r\n\t  this.name = 'InvalidOptionsError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidOptionsError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction InvalidMessageError(message) {\r\n\t  this.name = 'InvalidMessageError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tInvalidMessageError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction SocketProtocolError(message, code) {\r\n\t  this.name = 'SocketProtocolError';\r\n\t  this.message = message;\r\n\t  this.code = code;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tSocketProtocolError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction ServerProtocolError(message) {\r\n\t  this.name = 'ServerProtocolError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tServerProtocolError.prototype = Object.create(Error.prototype);\r\n\t\r\n\tfunction HTTPServerError(message) {\r\n\t  this.name = 'HTTPServerError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tHTTPServerError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction ResourceLimitError(message) {\r\n\t  this.name = 'ResourceLimitError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tResourceLimitError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction TimeoutError(message) {\r\n\t  this.name = 'TimeoutError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tTimeoutError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction BadConnectionError(message, type) {\r\n\t  this.name = 'BadConnectionError';\r\n\t  this.message = message;\r\n\t  this.type = type;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tBadConnectionError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction BrokerError(message) {\r\n\t  this.name = 'BrokerError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tBrokerError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction ProcessExitError(message, code) {\r\n\t  this.name = 'ProcessExitError';\r\n\t  this.message = message;\r\n\t  this.code = code;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tProcessExitError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\tfunction UnknownError(message) {\r\n\t  this.name = 'UnknownError';\r\n\t  this.message = message;\r\n\t  if (Error.captureStackTrace && !isStrict) {\r\n\t    Error.captureStackTrace(this, arguments.callee);\r\n\t  } else {\r\n\t    this.stack = (new Error()).stack;\r\n\t  }\r\n\t}\r\n\tUnknownError.prototype = Object.create(Error.prototype);\r\n\t\r\n\t\r\n\t// Expose all error types\r\n\t\r\n\tmodule.exports = {\r\n\t  AuthTokenExpiredError: AuthTokenExpiredError,\r\n\t  AuthTokenInvalidError: AuthTokenInvalidError,\r\n\t  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\r\n\t  AuthTokenError: AuthTokenError,\r\n\t  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\r\n\t  InvalidActionError: InvalidActionError,\r\n\t  InvalidArgumentsError: InvalidArgumentsError,\r\n\t  InvalidOptionsError: InvalidOptionsError,\r\n\t  InvalidMessageError: InvalidMessageError,\r\n\t  SocketProtocolError: SocketProtocolError,\r\n\t  ServerProtocolError: ServerProtocolError,\r\n\t  HTTPServerError: HTTPServerError,\r\n\t  ResourceLimitError: ResourceLimitError,\r\n\t  TimeoutError: TimeoutError,\r\n\t  BadConnectionError: BadConnectionError,\r\n\t  BrokerError: BrokerError,\r\n\t  ProcessExitError: ProcessExitError,\r\n\t  UnknownError: UnknownError\r\n\t};\r\n\t\r\n\tmodule.exports.socketProtocolErrorStatuses = {\r\n\t  1001: 'Socket was disconnected',\r\n\t  1002: 'A WebSocket protocol error was encountered',\r\n\t  1003: 'Server terminated socket because it received invalid data',\r\n\t  1005: 'Socket closed without status code',\r\n\t  1006: 'Socket hung up',\r\n\t  1007: 'Message format was incorrect',\r\n\t  1008: 'Encountered a policy violation',\r\n\t  1009: 'Message was too big to process',\r\n\t  1010: 'Client ended the connection because the server did not comply with extension requirements',\r\n\t  1011: 'Server encountered an unexpected fatal condition',\r\n\t  4000: 'Server ping timed out',\r\n\t  4001: 'Client pong timed out',\r\n\t  4002: 'Server failed to sign auth token',\r\n\t  4003: 'Failed to complete handshake',\r\n\t  4004: 'Client failed to save auth token',\r\n\t  4005: 'Did not receive #handshake from client before timeout',\r\n\t  4006: 'Failed to bind socket to message broker',\r\n\t  4007: 'Client connection establishment timed out'\r\n\t};\r\n\t\r\n\tmodule.exports.socketProtocolIgnoreStatuses = {\r\n\t  1000: 'Socket closed normally',\r\n\t  1001: 'Socket hung up'\r\n\t};\r\n\t\r\n\t// Properties related to error domains cannot be serialized.\r\n\tvar unserializableErrorProperties = {\r\n\t  domain: 1,\r\n\t  domainEmitter: 1,\r\n\t  domainThrown: 1\r\n\t};\r\n\t\r\n\tmodule.exports.dehydrateError = function (error, includeStackTrace) {\r\n\t  var dehydratedError;\r\n\t\r\n\t  if (error && typeof error == 'object') {\r\n\t    dehydratedError = {\r\n\t      message: error.message\r\n\t    };\r\n\t    if (includeStackTrace) {\r\n\t      dehydratedError.stack = error.stack;\r\n\t    }\r\n\t    for (var i in error) {\r\n\t      if (!unserializableErrorProperties[i]) {\r\n\t        dehydratedError[i] = error[i];\r\n\t      }\r\n\t    }\r\n\t  } else if (typeof error == 'function') {\r\n\t    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\r\n\t  } else {\r\n\t    dehydratedError = error;\r\n\t  }\r\n\t\r\n\t  return decycle(dehydratedError);\r\n\t};\r\n\t\r\n\tmodule.exports.hydrateError = function (error) {\r\n\t  var hydratedError = null;\r\n\t  if (error != null) {\r\n\t    if (typeof error == 'object') {\r\n\t      hydratedError = new Error(error.message);\r\n\t      for (var i in error) {\r\n\t        if (error.hasOwnProperty(i)) {\r\n\t          hydratedError[i] = error[i];\r\n\t        }\r\n\t      }\r\n\t    } else {\r\n\t      hydratedError = error;\r\n\t    }\r\n\t  }\r\n\t  return hydratedError;\r\n\t};\r\n\t\r\n\tmodule.exports.decycle = decycle;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t// Based on https://github.com/dscape/cycle/blob/master/cycle.js\r\n\t\r\n\tmodule.exports = function decycle(object) {\r\n\t// Make a deep copy of an object or array, assuring that there is at most\r\n\t// one instance of each object or array in the resulting structure. The\r\n\t// duplicate references (which might be forming cycles) are replaced with\r\n\t// an object of the form\r\n\t//      {$ref: PATH}\r\n\t// where the PATH is a JSONPath string that locates the first occurance.\r\n\t// So,\r\n\t//      var a = [];\r\n\t//      a[0] = a;\r\n\t//      return JSON.stringify(JSON.decycle(a));\r\n\t// produces the string '[{\"$ref\":\"$\"}]'.\r\n\t\r\n\t// JSONPath is used to locate the unique object. $ indicates the top level of\r\n\t// the object or array. [NUMBER] or [STRING] indicates a child member or\r\n\t// property.\r\n\t\r\n\t    var objects = [],   // Keep a reference to each unique object or array\r\n\t        paths = [];     // Keep the path to each unique object or array\r\n\t\r\n\t    return (function derez(value, path) {\r\n\t\r\n\t// The derez recurses through the object, producing the deep copy.\r\n\t\r\n\t        var i,          // The loop counter\r\n\t            name,       // Property name\r\n\t            nu;         // The new object or array\r\n\t\r\n\t// typeof null === 'object', so go on if this value is really an object but not\r\n\t// one of the weird builtin objects.\r\n\t\r\n\t        if (typeof value === 'object' && value !== null &&\r\n\t                !(value instanceof Boolean) &&\r\n\t                !(value instanceof Date)    &&\r\n\t                !(value instanceof Number)  &&\r\n\t                !(value instanceof RegExp)  &&\r\n\t                !(value instanceof String)) {\r\n\t\r\n\t// If the value is an object or array, look to see if we have already\r\n\t// encountered it. If so, return a $ref/path object. This is a hard way,\r\n\t// linear search that will get slower as the number of unique objects grows.\r\n\t\r\n\t            for (i = 0; i < objects.length; i += 1) {\r\n\t                if (objects[i] === value) {\r\n\t                    return {$ref: paths[i]};\r\n\t                }\r\n\t            }\r\n\t\r\n\t// Otherwise, accumulate the unique value and its path.\r\n\t\r\n\t            objects.push(value);\r\n\t            paths.push(path);\r\n\t\r\n\t// If it is an array, replicate the array.\r\n\t\r\n\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\r\n\t                nu = [];\r\n\t                for (i = 0; i < value.length; i += 1) {\r\n\t                    nu[i] = derez(value[i], path + '[' + i + ']');\r\n\t                }\r\n\t            } else {\r\n\t\r\n\t// If it is an object, replicate the object.\r\n\t\r\n\t                nu = {};\r\n\t                for (name in value) {\r\n\t                    if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n\t                        nu[name] = derez(value[name],\r\n\t                            path + '[' + JSON.stringify(name) + ']');\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return nu;\r\n\t        }\r\n\t        return value;\r\n\t    }(object, '$'));\r\n\t};\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t/**\r\n\t * Expose `Emitter`.\r\n\t */\r\n\t\r\n\tif (true) {\r\n\t  module.exports = Emitter;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Initialize a new `Emitter`.\r\n\t *\r\n\t * @api public\r\n\t */\r\n\t\r\n\tfunction Emitter(obj) {\r\n\t  if (obj) return mixin(obj);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Mixin the emitter properties.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @return {Object}\r\n\t * @api private\r\n\t */\r\n\t\r\n\tfunction mixin(obj) {\r\n\t  for (var key in Emitter.prototype) {\r\n\t    obj[key] = Emitter.prototype[key];\r\n\t  }\r\n\t  return obj;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Listen on the given `event` with `fn`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.on =\r\n\tEmitter.prototype.addEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n\t    .push(fn);\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds an `event` listener that will be invoked a single\r\n\t * time then automatically removed.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.once = function(event, fn){\r\n\t  function on() {\r\n\t    this.off(event, on);\r\n\t    fn.apply(this, arguments);\r\n\t  }\r\n\t\r\n\t  on.fn = fn;\r\n\t  this.on(event, on);\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Remove the given callback for `event` or all\r\n\t * registered callbacks.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.off =\r\n\tEmitter.prototype.removeListener =\r\n\tEmitter.prototype.removeAllListeners =\r\n\tEmitter.prototype.removeEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t\r\n\t  // all\r\n\t  if (0 == arguments.length) {\r\n\t    this._callbacks = {};\r\n\t    return this;\r\n\t  }\r\n\t\r\n\t  // specific event\r\n\t  var callbacks = this._callbacks['$' + event];\r\n\t  if (!callbacks) return this;\r\n\t\r\n\t  // remove all handlers\r\n\t  if (1 == arguments.length) {\r\n\t    delete this._callbacks['$' + event];\r\n\t    return this;\r\n\t  }\r\n\t\r\n\t  // remove specific handler\r\n\t  var cb;\r\n\t  for (var i = 0; i < callbacks.length; i++) {\r\n\t    cb = callbacks[i];\r\n\t    if (cb === fn || cb.fn === fn) {\r\n\t      callbacks.splice(i, 1);\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Emit `event` with the given args.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Mixed} ...\r\n\t * @return {Emitter}\r\n\t */\r\n\t\r\n\tEmitter.prototype.emit = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  var args = [].slice.call(arguments, 1)\r\n\t    , callbacks = this._callbacks['$' + event];\r\n\t\r\n\t  if (callbacks) {\r\n\t    callbacks = callbacks.slice(0);\r\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n\t      callbacks[i].apply(this, args);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Return array of callbacks for `event`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Array}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.listeners = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  return this._callbacks['$' + event] || [];\r\n\t};\r\n\t\r\n\t/**\r\n\t * Check if this emitter has `event` handlers.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.hasListeners = function(event){\r\n\t  return !! this.listeners(event).length;\r\n\t};\r\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// neolab-socket-client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b6c7667c42326289d0e5","'use strict';\n\nimport NeoLabSocketClient from './neolab.socket';\n\nmodule.exports = NeoLabSocketClient;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\nimport { connect } from 'socketcluster-client';\n\nexport default class NeoLabSocketClient {\n  constructor(options) {\n    this.connection = connect(options);\n    return this.connection;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/neolab.socket.js","var SCSocket = require('./lib/scsocket');\nvar SCSocketCreator = require('./lib/scsocketcreator');\n\nmodule.exports.SCSocketCreator = SCSocketCreator;\nmodule.exports.SCSocket = SCSocket;\n\nmodule.exports.Emitter = require('component-emitter');\n\nmodule.exports.connect = function (options) {\n  return SCSocketCreator.connect(options);\n};\n\nmodule.exports.destroy = function (options) {\n  return SCSocketCreator.destroy(options);\n};\n\nmodule.exports.connections = SCSocketCreator.connections;\n\nmodule.exports.version = '8.0.1';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/index.js\n// module id = 2\n// module chunks = 0 1","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"NeoLabSocketClient\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NeoLabSocketClient\"] = factory();\n\telse\n\t\troot[\"NeoLabSocketClient\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _neolab = __webpack_require__(1);\n\n\tvar _neolab2 = _interopRequireDefault(_neolab);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tmodule.exports = _neolab2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _socket = __webpack_require__(2);\n\n\tvar _socket2 = _interopRequireDefault(_socket);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar NeoLabSocketClient = function () {\n\t  function NeoLabSocketClient(options) {\n\t    _classCallCheck(this, NeoLabSocketClient);\n\n\t    this.options = options;\n\t    this.socket = null;\n\t  }\n\n\t  _createClass(NeoLabSocketClient, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      if (!this.socket) {\n\t        this.socket = new _socket2.default(this.options).connect;\n\t      }\n\t      return this.socket;\n\t    }\n\t  }]);\n\n\t  return NeoLabSocketClient;\n\t}();\n\n\texports.default = NeoLabSocketClient;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _socketclusterClient = __webpack_require__(3);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar SocketConnect = function SocketConnect(options) {\n\t  _classCallCheck(this, SocketConnect);\n\n\t  _socketclusterClient.Emitter.call(this);\n\t  var sendEvent = new _socketclusterClient.Emitter();\n\t  this.emit = sendEvent;\n\t  this.connect = (0, _socketclusterClient.connect)(options);\n\n\t  this.connect.on('connect', function (status) {\n\t    sendEvent.emit('neolab:socket-connected', status);\n\t  });\n\n\t  this.connect.on('connecting', function () {\n\t    sendEvent.emit('neolab:socket-connecting');\n\t  });\n\n\t  this.connect.on('authenticate', function () {\n\t    sendEvent.emit('neolab:socket-authenticated');\n\t  });\n\n\t  this.connect.on('deauthenticate', function () {\n\t    sendEvent.emit('neolab:socket-deauthenticated');\n\t  });\n\n\t  this.connect.on('disconnect', function () {\n\t    sendEvent.emit('neolab:socket-disconnected');\n\t  });\n\n\t  this.connect.on('error', function (error) {\n\t    sendEvent.emit('neolab:socket-failed', error);\n\t  });\n\t};\n\n\texports.default = SocketConnect;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SCSocket = __webpack_require__(4);\n\tvar SCSocketCreator = __webpack_require__(26);\n\n\tmodule.exports.SCSocketCreator = SCSocketCreator;\n\tmodule.exports.SCSocket = SCSocket;\n\n\tmodule.exports.Emitter = __webpack_require__(9);\n\n\tmodule.exports.connect = function (options) {\n\t  return SCSocketCreator.connect(options);\n\t};\n\n\tmodule.exports.destroy = function (options) {\n\t  return SCSocketCreator.destroy(options);\n\t};\n\n\tmodule.exports.connections = SCSocketCreator.connections;\n\n\tmodule.exports.version = '8.0.1';\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, Buffer) {var Emitter = __webpack_require__(9);\n\tvar SCChannel = __webpack_require__(10).SCChannel;\n\tvar Response = __webpack_require__(11).Response;\n\tvar AuthEngine = __webpack_require__(14).AuthEngine;\n\tvar formatter = __webpack_require__(15);\n\tvar SCTransport = __webpack_require__(16).SCTransport;\n\tvar querystring = __webpack_require__(17);\n\tvar LinkedList = __webpack_require__(21);\n\tvar base64 = __webpack_require__(23);\n\tvar clone = __webpack_require__(25);\n\n\tvar scErrors = __webpack_require__(12);\n\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\tvar InvalidMessageError = scErrors.InvalidMessageError;\n\tvar SocketProtocolError = scErrors.SocketProtocolError;\n\tvar TimeoutError = scErrors.TimeoutError;\n\tvar BadConnectionError = scErrors.BadConnectionError;\n\n\tvar isBrowser = typeof window != 'undefined';\n\n\n\tvar SCSocket = function (opts) {\n\t  var self = this;\n\n\t  Emitter.call(this);\n\n\t  this.id = null;\n\t  this.state = this.CLOSED;\n\t  this.authState = this.UNAUTHENTICATED;\n\t  this.signedAuthToken = null;\n\t  this.authToken = null;\n\t  this.pendingReconnect = false;\n\t  this.pendingReconnectTimeout = null;\n\t  this.preparingPendingSubscriptions = false;\n\n\t  this.connectTimeout = opts.connectTimeout;\n\t  this.ackTimeout = opts.ackTimeout;\n\t  this.channelPrefix = opts.channelPrefix || null;\n\t  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\n\t  this.authTokenName = opts.authTokenName;\n\n\t  // pingTimeout will be ackTimeout at the start, but it will\n\t  // be updated with values provided by the 'connect' event\n\t  this.pingTimeout = this.ackTimeout;\n\n\t  var maxTimeout = Math.pow(2, 31) - 1;\n\n\t  var verifyDuration = function (propertyName) {\n\t    if (self[propertyName] > maxTimeout) {\n\t      throw new InvalidArgumentsError('The ' + propertyName +\n\t        ' value provided exceeded the maximum amount allowed');\n\t    }\n\t  };\n\n\t  verifyDuration('connectTimeout');\n\t  verifyDuration('ackTimeout');\n\t  verifyDuration('pingTimeout');\n\n\t  this._localEvents = {\n\t    'connect': 1,\n\t    'connectAbort': 1,\n\t    'disconnect': 1,\n\t    'message': 1,\n\t    'error': 1,\n\t    'raw': 1,\n\t    'fail': 1,\n\t    'kickOut': 1,\n\t    'subscribe': 1,\n\t    'unsubscribe': 1,\n\t    'subscribeStateChange': 1,\n\t    'authStateChange': 1,\n\t    'authenticate': 1,\n\t    'deauthenticate': 1,\n\t    'removeAuthToken': 1,\n\t    'subscribeRequest': 1\n\t  };\n\n\t  this.connectAttempts = 0;\n\n\t  this._emitBuffer = new LinkedList();\n\t  this.channels = {};\n\n\t  this.options = opts;\n\n\t  this._cid = 1;\n\n\t  this.options.callIdGenerator = function () {\n\t    return self._cid++;\n\t  };\n\n\t  if (this.options.autoReconnect) {\n\t    if (this.options.autoReconnectOptions == null) {\n\t      this.options.autoReconnectOptions = {};\n\t    }\n\n\t    // Add properties to the this.options.autoReconnectOptions object.\n\t    // We assign the reference to a reconnectOptions variable to avoid repetition.\n\t    var reconnectOptions = this.options.autoReconnectOptions;\n\t    if (reconnectOptions.initialDelay == null) {\n\t      reconnectOptions.initialDelay = 10000;\n\t    }\n\t    if (reconnectOptions.randomness == null) {\n\t      reconnectOptions.randomness = 10000;\n\t    }\n\t    if (reconnectOptions.multiplier == null) {\n\t      reconnectOptions.multiplier = 1.5;\n\t    }\n\t    if (reconnectOptions.maxDelay == null) {\n\t      reconnectOptions.maxDelay = 60000;\n\t    }\n\t  }\n\n\t  if (this.options.subscriptionRetryOptions == null) {\n\t    this.options.subscriptionRetryOptions = {};\n\t  }\n\n\t  if (this.options.authEngine) {\n\t    this.auth = this.options.authEngine;\n\t  } else {\n\t    this.auth = new AuthEngine();\n\t  }\n\n\t  if (this.options.codecEngine) {\n\t    this.codec = this.options.codecEngine;\n\t  } else {\n\t    // Default codec engine\n\t    this.codec = formatter;\n\t  }\n\n\t  this.options.path = this.options.path.replace(/\\/$/, '') + '/';\n\n\t  this.options.query = opts.query || {};\n\t  if (typeof this.options.query == 'string') {\n\t    this.options.query = querystring.parse(this.options.query);\n\t  }\n\n\t  if (this.options.autoConnect) {\n\t    this.connect();\n\t  }\n\n\t  this._channelEmitter = new Emitter();\n\n\t  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\n\t    this._unloadHandler = function () {\n\t      self.disconnect();\n\t    };\n\n\t    global.addEventListener('beforeunload', this._unloadHandler, false);\n\t  }\n\t};\n\n\tSCSocket.prototype = Object.create(Emitter.prototype);\n\n\tSCSocket.CONNECTING = SCSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\n\tSCSocket.OPEN = SCSocket.prototype.OPEN = SCTransport.prototype.OPEN;\n\tSCSocket.CLOSED = SCSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\n\n\tSCSocket.AUTHENTICATED = SCSocket.prototype.AUTHENTICATED = 'authenticated';\n\tSCSocket.UNAUTHENTICATED = SCSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\n\n\tSCSocket.PENDING = SCSocket.prototype.PENDING = 'pending';\n\n\tSCSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\n\tSCSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\n\n\tSCSocket.prototype._privateEventHandlerMap = {\n\t  '#publish': function (data) {\n\t    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n\t    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n\n\t    if (isSubscribed) {\n\t      this._channelEmitter.emit(undecoratedChannelName, data.data);\n\t    }\n\t  },\n\t  '#kickOut': function (data) {\n\t    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n\t    var channel = this.channels[undecoratedChannelName];\n\t    if (channel) {\n\t      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\n\t      channel.emit('kickOut', data.message, undecoratedChannelName);\n\t      this._triggerChannelUnsubscribe(channel);\n\t    }\n\t  },\n\t  '#setAuthToken': function (data, response) {\n\t    var self = this;\n\n\t    if (data) {\n\t      var triggerAuthenticate = function (err) {\n\t        if (err) {\n\t          // This is a non-fatal error, we don't want to close the connection\n\t          // because of this but we do want to notify the server and throw an error\n\t          // on the client.\n\t          response.error(err);\n\t          self._onSCError(err);\n\t        } else {\n\t          self._changeToAuthenticatedState(data.token);\n\t          response.end();\n\t        }\n\t      };\n\n\t      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\n\t    } else {\n\t      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\n\t    }\n\t  },\n\t  '#removeAuthToken': function (data, response) {\n\t    var self = this;\n\n\t    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n\t      if (err) {\n\t        // Non-fatal error - Do not close the connection\n\t        response.error(err);\n\t        self._onSCError(err);\n\t      } else {\n\t        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n\t        self._changeToUnauthenticatedStateAndClearTokens();\n\t        response.end();\n\t      }\n\t    });\n\t  },\n\t  '#disconnect': function (data) {\n\t    this.transport.close(data.code, data.data);\n\t  }\n\t};\n\n\tSCSocket.prototype.getState = function () {\n\t  return this.state;\n\t};\n\n\tSCSocket.prototype.getBytesReceived = function () {\n\t  return this.transport.getBytesReceived();\n\t};\n\n\tSCSocket.prototype.deauthenticate = function (callback) {\n\t  var self = this;\n\n\t  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n\t    if (err) {\n\t      // Non-fatal error - Do not close the connection\n\t      self._onSCError(err);\n\t    } else {\n\t      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n\t      if (self.state != self.CLOSED) {\n\t        self.emit('#removeAuthToken');\n\t      }\n\t      self._changeToUnauthenticatedStateAndClearTokens();\n\t    }\n\t    callback && callback(err);\n\t  });\n\t};\n\n\tSCSocket.prototype.connect = SCSocket.prototype.open = function () {\n\t  var self = this;\n\n\t  if (this.state == this.CLOSED) {\n\t    this.pendingReconnect = false;\n\t    this.pendingReconnectTimeout = null;\n\t    clearTimeout(this._reconnectTimeoutRef);\n\n\t    this.state = this.CONNECTING;\n\t    Emitter.prototype.emit.call(this, 'connecting');\n\n\t    if (this.transport) {\n\t      this.transport.off();\n\t    }\n\n\t    this.transport = new SCTransport(this.auth, this.codec, this.options);\n\n\t    this.transport.on('open', function (status) {\n\t      self.state = self.OPEN;\n\t      self._onSCOpen(status);\n\t    });\n\n\t    this.transport.on('error', function (err) {\n\t      self._onSCError(err);\n\t    });\n\n\t    this.transport.on('close', function (code, data) {\n\t      self.state = self.CLOSED;\n\t      self._onSCClose(code, data);\n\t    });\n\n\t    this.transport.on('openAbort', function (code, data) {\n\t      self.state = self.CLOSED;\n\t      self._onSCClose(code, data, true);\n\t    });\n\n\t    this.transport.on('event', function (event, data, res) {\n\t      self._onSCEvent(event, data, res);\n\t    });\n\t  }\n\t};\n\n\tSCSocket.prototype.reconnect = function () {\n\t  this.disconnect();\n\t  this.connect();\n\t};\n\n\tSCSocket.prototype.disconnect = function (code, data) {\n\t  code = code || 1000;\n\n\t  if (typeof code != 'number') {\n\t    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n\t  }\n\n\t  if (this.state == this.OPEN || this.state == this.CONNECTING) {\n\t    this.transport.close(code, data);\n\t  } else {\n\t    this.pendingReconnect = false;\n\t    this.pendingReconnectTimeout = null;\n\t    clearTimeout(this._reconnectTimeoutRef);\n\t  }\n\t};\n\n\tSCSocket.prototype.destroy = function () {\n\t  if (this._unloadHandler) {\n\t    global.removeEventListener('beforeunload', this._unloadHandler, false);\n\t  }\n\t  this.disconnect();\n\t};\n\n\tSCSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n\t  if (this.authState != this.UNAUTHENTICATED) {\n\t    var oldState = this.authState;\n\t    this.authState = this.UNAUTHENTICATED;\n\t    this.signedAuthToken = null;\n\t    this.authToken = null;\n\n\t    var stateChangeData = {\n\t      oldState: oldState,\n\t      newState: this.authState\n\t    };\n\t    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n\t    if (oldState == this.AUTHENTICATED) {\n\t      Emitter.prototype.emit.call(this, 'deauthenticate');\n\t    }\n\t    Emitter.prototype.emit.call(this, 'authTokenChange', this.signedAuthToken);\n\t  }\n\t};\n\n\tSCSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n\t  this.signedAuthToken = signedAuthToken;\n\t  this.authToken = this._extractAuthTokenData(signedAuthToken);\n\n\t  if (this.authState != this.AUTHENTICATED) {\n\t    var oldState = this.authState;\n\t    this.authState = this.AUTHENTICATED;\n\t    var stateChangeData = {\n\t      oldState: oldState,\n\t      newState: this.authState,\n\t      signedAuthToken: signedAuthToken,\n\t      authToken: this.authToken\n\t    };\n\t    if (!this.preparingPendingSubscriptions) {\n\t      this.processPendingSubscriptions();\n\t    }\n\n\t    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n\t    Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\n\t  }\n\t  Emitter.prototype.emit.call(this, 'authTokenChange', signedAuthToken);\n\t};\n\n\tSCSocket.prototype.decodeBase64 = function (encodedString) {\n\t  var decodedString;\n\t  if (typeof Buffer == 'undefined') {\n\t    if (global.atob) {\n\t      decodedString = global.atob(encodedString);\n\t    } else {\n\t      decodedString = base64.decode(encodedString);\n\t    }\n\t  } else {\n\t    var buffer = new Buffer(encodedString, 'base64');\n\t    decodedString = buffer.toString('utf8');\n\t  }\n\t  return decodedString;\n\t};\n\n\tSCSocket.prototype.encodeBase64 = function (decodedString) {\n\t  var encodedString;\n\t  if (typeof Buffer == 'undefined') {\n\t    if (global.btoa) {\n\t      encodedString = global.btoa(decodedString);\n\t    } else {\n\t      encodedString = base64.encode(decodedString);\n\t    }\n\t  } else {\n\t    var buffer = new Buffer(decodedString, 'utf8');\n\t    encodedString = buffer.toString('base64');\n\t  }\n\t  return encodedString;\n\t};\n\n\tSCSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n\t  var tokenParts = (signedAuthToken || '').split('.');\n\t  var encodedTokenData = tokenParts[1];\n\t  if (encodedTokenData != null) {\n\t    var tokenData = encodedTokenData;\n\t    try {\n\t      tokenData = this.decodeBase64(tokenData);\n\t      return JSON.parse(tokenData);\n\t    } catch (e) {\n\t      return tokenData;\n\t    }\n\t  }\n\t  return null;\n\t};\n\n\tSCSocket.prototype.getAuthToken = function () {\n\t  return this.authToken;\n\t};\n\n\tSCSocket.prototype.getSignedAuthToken = function () {\n\t  return this.signedAuthToken;\n\t};\n\n\t// Perform client-initiated authentication by providing an encrypted token string.\n\tSCSocket.prototype.authenticate = function (signedAuthToken, callback) {\n\t  var self = this;\n\n\t  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\n\n\t    if (authStatus && authStatus.isAuthenticated != null) {\n\t      // If authStatus is correctly formatted (has an isAuthenticated property),\n\t      // then we will rehydrate the authError.\n\t      if (authStatus.authError) {\n\t        authStatus.authError = scErrors.hydrateError(authStatus.authError);\n\t      }\n\t    } else {\n\t      // Some errors like BadConnectionError and TimeoutError will not pass a valid\n\t      // authStatus object to the current function, so we need to create it ourselves.\n\t      authStatus = {\n\t        isAuthenticated: self.authState,\n\t        authError: null\n\t      };\n\t    }\n\t    if (err) {\n\t      if (err.name != 'BadConnectionError' && err.name != 'TimeoutError') {\n\t        // In case of a bad/closed connection or a timeout, we maintain the last\n\t        // known auth state since those errors don't mean that the token is invalid.\n\n\t        self._changeToUnauthenticatedStateAndClearTokens();\n\t      }\n\t      callback && callback(err, authStatus);\n\t    } else {\n\t      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\n\t        if (err) {\n\t          self._onSCError(err);\n\t        }\n\t        if (authStatus.isAuthenticated) {\n\t          self._changeToAuthenticatedState(signedAuthToken);\n\t        } else {\n\t          self._changeToUnauthenticatedStateAndClearTokens();\n\t        }\n\t        callback && callback(err, authStatus);\n\t      });\n\t    }\n\t  });\n\t};\n\n\tSCSocket.prototype._tryReconnect = function (initialDelay) {\n\t  var self = this;\n\n\t  var exponent = this.connectAttempts++;\n\t  var reconnectOptions = this.options.autoReconnectOptions;\n\t  var timeout;\n\n\t  if (initialDelay == null || exponent > 0) {\n\t    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n\n\t    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n\t  } else {\n\t    timeout = initialDelay;\n\t  }\n\n\t  if (timeout > reconnectOptions.maxDelay) {\n\t    timeout = reconnectOptions.maxDelay;\n\t  }\n\n\t  clearTimeout(this._reconnectTimeoutRef);\n\n\t  this.pendingReconnect = true;\n\t  this.pendingReconnectTimeout = timeout;\n\t  this._reconnectTimeoutRef = setTimeout(function () {\n\t    self.connect();\n\t  }, timeout);\n\t};\n\n\tSCSocket.prototype._onSCOpen = function (status) {\n\t  var self = this;\n\n\t  this.preparingPendingSubscriptions = true;\n\n\t  if (status) {\n\t    this.id = status.id;\n\t    this.pingTimeout = status.pingTimeout;\n\t    this.transport.pingTimeout = this.pingTimeout;\n\t    if (status.isAuthenticated) {\n\t      this._changeToAuthenticatedState(status.authToken);\n\t    } else {\n\t      this._changeToUnauthenticatedStateAndClearTokens();\n\t    }\n\t  } else {\n\t    // This can happen if auth.loadToken (in sctransport.js) fails with\n\t    // an error - This means that the signedAuthToken cannot be loaded by\n\t    // the auth engine and therefore, we need to unauthenticate the socket.\n\t    this._changeToUnauthenticatedStateAndClearTokens();\n\t  }\n\n\t  this.connectAttempts = 0;\n\n\t  if (this.options.autoSubscribeOnConnect) {\n\t    this.processPendingSubscriptions();\n\t  }\n\n\t  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n\t  // won't break anything.\n\t  Emitter.prototype.emit.call(this, 'connect', status, function () {\n\t    self.processPendingSubscriptions();\n\t  });\n\n\t  this._flushEmitBuffer();\n\t};\n\n\tSCSocket.prototype._onSCError = function (err) {\n\t  var self = this;\n\n\t  // Throw error in different stack frame so that error handling\n\t  // cannot interfere with a reconnect action.\n\t  setTimeout(function () {\n\t    if (self.listeners('error').length < 1) {\n\t      throw err;\n\t    } else {\n\t      Emitter.prototype.emit.call(self, 'error', err);\n\t    }\n\t  }, 0);\n\t};\n\n\tSCSocket.prototype._suspendSubscriptions = function () {\n\t  var channel, newState;\n\t  for (var channelName in this.channels) {\n\t    if (this.channels.hasOwnProperty(channelName)) {\n\t      channel = this.channels[channelName];\n\t      if (channel.state == channel.SUBSCRIBED ||\n\t        channel.state == channel.PENDING) {\n\n\t        newState = channel.PENDING;\n\t      } else {\n\t        newState = channel.UNSUBSCRIBED;\n\t      }\n\n\t      this._triggerChannelUnsubscribe(channel, newState);\n\t    }\n\t  }\n\t};\n\n\tSCSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n\t  var currentNode = this._emitBuffer.head;\n\t  var nextNode;\n\n\t  while (currentNode) {\n\t    nextNode = currentNode.next;\n\t    var eventObject = currentNode.data;\n\t    clearTimeout(eventObject.timeout);\n\t    delete eventObject.timeout;\n\t    currentNode.detach();\n\t    currentNode = nextNode;\n\n\t    var callback = eventObject.callback;\n\t    if (callback) {\n\t      delete eventObject.callback;\n\t      var errorMessage = \"Event '\" + eventObject.event +\n\t        \"' was aborted due to a bad connection\";\n\t      var error = new BadConnectionError(errorMessage, failureType);\n\t      callback.call(eventObject, error, eventObject);\n\t    }\n\t  }\n\t};\n\n\tSCSocket.prototype._onSCClose = function (code, data, openAbort) {\n\t  var self = this;\n\n\t  this.id = null;\n\n\t  if (this.transport) {\n\t    this.transport.off();\n\t  }\n\t  this.pendingReconnect = false;\n\t  this.pendingReconnectTimeout = null;\n\t  clearTimeout(this._reconnectTimeoutRef);\n\n\t  this._suspendSubscriptions();\n\t  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\n\t  // Try to reconnect\n\t  // on server ping timeout (4000)\n\t  // or on client pong timeout (4001)\n\t  // or on close without status (1005)\n\t  // or on handshake failure (4003)\n\t  // or on socket hung up (1006)\n\t  if (this.options.autoReconnect) {\n\t    if (code == 4000 || code == 4001 || code == 1005) {\n\t      // If there is a ping or pong timeout or socket closes without\n\t      // status, don't wait before trying to reconnect - These could happen\n\t      // if the client wakes up after a period of inactivity and in this case we\n\t      // want to re-establish the connection as soon as possible.\n\t      this._tryReconnect(0);\n\n\t      // Codes 4500 and above will be treated as permanent disconnects.\n\t      // Socket will not try to auto-reconnect.\n\t    } else if (code != 1000 && code < 4500) {\n\t      this._tryReconnect();\n\t    }\n\t  }\n\n\t  if (openAbort) {\n\t    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\n\t  } else {\n\t    Emitter.prototype.emit.call(self, 'disconnect', code, data);\n\t  }\n\n\t  if (!SCSocket.ignoreStatuses[code]) {\n\t    var failureMessage;\n\t    if (data) {\n\t      failureMessage = 'Socket connection failed: ' + data;\n\t    } else {\n\t      failureMessage = 'Socket connection failed for unknown reasons';\n\t    }\n\t    var err = new SocketProtocolError(SCSocket.errorStatuses[code] || failureMessage, code);\n\t    this._onSCError(err);\n\t  }\n\t};\n\n\tSCSocket.prototype._onSCEvent = function (event, data, res) {\n\t  var handler = this._privateEventHandlerMap[event];\n\t  if (handler) {\n\t    handler.call(this, data, res);\n\t  } else {\n\t    Emitter.prototype.emit.call(this, event, data, function () {\n\t      res && res.callback.apply(res, arguments);\n\t    });\n\t  }\n\t};\n\n\tSCSocket.prototype.decode = function (message) {\n\t  return this.transport.decode(message);\n\t};\n\n\tSCSocket.prototype.encode = function (object) {\n\t  return this.transport.encode(object);\n\t};\n\n\tSCSocket.prototype._flushEmitBuffer = function () {\n\t  var currentNode = this._emitBuffer.head;\n\t  var nextNode;\n\n\t  while (currentNode) {\n\t    nextNode = currentNode.next;\n\t    var eventObject = currentNode.data;\n\t    currentNode.detach();\n\t    this.transport.emitObject(eventObject);\n\t    currentNode = nextNode;\n\t  }\n\t};\n\n\tSCSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n\t  if (eventNode) {\n\t    eventNode.detach();\n\t  }\n\t  delete eventObject.timeout;\n\n\t  var callback = eventObject.callback;\n\t  if (callback) {\n\t    delete eventObject.callback;\n\t    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n\t    callback.call(eventObject, error, eventObject);\n\t  }\n\t};\n\n\tSCSocket.prototype._emit = function (event, data, callback) {\n\t  var self = this;\n\n\t  if (this.state == this.CLOSED) {\n\t    this.connect();\n\t  }\n\t  var eventObject = {\n\t    event: event,\n\t    callback: callback\n\t  };\n\n\t  var eventNode = new LinkedList.Item();\n\n\t  if (this.options.cloneData) {\n\t    eventObject.data = clone(data);\n\t  } else {\n\t    eventObject.data = data;\n\t  }\n\t  eventNode.data = eventObject;\n\n\t  eventObject.timeout = setTimeout(function () {\n\t    self._handleEventAckTimeout(eventObject, eventNode);\n\t  }, this.ackTimeout);\n\n\t  this._emitBuffer.append(eventNode);\n\n\t  if (this.state == this.OPEN) {\n\t    this._flushEmitBuffer();\n\t  }\n\t};\n\n\tSCSocket.prototype.send = function (data) {\n\t  this.transport.send(data);\n\t};\n\n\tSCSocket.prototype.emit = function (event, data, callback) {\n\t  if (this._localEvents[event] == null) {\n\t    this._emit(event, data, callback);\n\t  } else {\n\t    Emitter.prototype.emit.call(this, event, data);\n\t  }\n\t};\n\n\tSCSocket.prototype.publish = function (channelName, data, callback) {\n\t  var pubData = {\n\t    channel: this._decorateChannelName(channelName),\n\t    data: data\n\t  };\n\t  this.emit('#publish', pubData, callback);\n\t};\n\n\tSCSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n\t  var channelName = channel.name;\n\n\t  if (channel.state != channel.SUBSCRIBED) {\n\t    var oldState = channel.state;\n\t    channel.state = channel.SUBSCRIBED;\n\n\t    var stateChangeData = {\n\t      channel: channelName,\n\t      oldState: oldState,\n\t      newState: channel.state,\n\t      subscriptionOptions: subscriptionOptions\n\t    };\n\t    channel.emit('subscribeStateChange', stateChangeData);\n\t    channel.emit('subscribe', channelName, subscriptionOptions);\n\t    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n\t    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\n\t  }\n\t};\n\n\tSCSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n\t  var channelName = channel.name;\n\t  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\n\t  if (channel.state != channel.UNSUBSCRIBED && meetsAuthRequirements) {\n\t    channel.state = channel.UNSUBSCRIBED;\n\n\t    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\n\t    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\n\t  }\n\t};\n\n\t// Cancel any pending subscribe callback\n\tSCSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n\t  if (channel._pendingSubscriptionCid != null) {\n\t    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n\t    delete channel._pendingSubscriptionCid;\n\t  }\n\t};\n\n\tSCSocket.prototype._decorateChannelName = function (channelName) {\n\t  if (this.channelPrefix) {\n\t    channelName = this.channelPrefix + channelName;\n\t  }\n\t  return channelName;\n\t};\n\n\tSCSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n\t  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) == 0) {\n\t    return decoratedChannelName.replace(this.channelPrefix, '');\n\t  }\n\t  return decoratedChannelName;\n\t};\n\n\tSCSocket.prototype._trySubscribe = function (channel) {\n\t  var self = this;\n\n\t  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;\n\n\t  // We can only ever have one pending subscribe action at any given time on a channel\n\t  if (this.state == this.OPEN && !this.preparingPendingSubscriptions &&\n\t    channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n\n\t    var options = {\n\t      noTimeout: true\n\t    };\n\n\t    var subscriptionOptions = {\n\t      channel: this._decorateChannelName(channel.name)\n\t    };\n\t    if (channel.waitForAuth) {\n\t      options.waitForAuth = true;\n\t      subscriptionOptions.waitForAuth = options.waitForAuth;\n\t    }\n\t    if (channel.data) {\n\t      subscriptionOptions.data = channel.data;\n\t    }\n\t    if (channel.batch) {\n\t      options.batch = true;\n\t      subscriptionOptions.batch = true;\n\t    }\n\n\t    channel._pendingSubscriptionCid = this.transport.emit(\n\t      '#subscribe', subscriptionOptions, options,\n\t      function (err) {\n\t        delete channel._pendingSubscriptionCid;\n\t        if (err) {\n\t          self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n\t        } else {\n\t          self._triggerChannelSubscribe(channel, subscriptionOptions);\n\t        }\n\t      }\n\t    );\n\t    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\n\t  }\n\t};\n\n\tSCSocket.prototype.subscribe = function (channelName, options) {\n\t  var channel = this.channels[channelName];\n\n\t  if (!channel) {\n\t    channel = new SCChannel(channelName, this, options);\n\t    this.channels[channelName] = channel;\n\t  } else if (options) {\n\t    channel.setOptions(options);\n\t  }\n\n\t  if (channel.state == channel.UNSUBSCRIBED) {\n\t    channel.state = channel.PENDING;\n\t    this._trySubscribe(channel);\n\t  }\n\n\t  return channel;\n\t};\n\n\tSCSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\n\t  var channelName = channel.name;\n\t  var oldState = channel.state;\n\n\t  if (newState) {\n\t    channel.state = newState;\n\t  } else {\n\t    channel.state = channel.UNSUBSCRIBED;\n\t  }\n\t  this._cancelPendingSubscribeCallback(channel);\n\n\t  if (oldState == channel.SUBSCRIBED) {\n\t    var stateChangeData = {\n\t      channel: channelName,\n\t      oldState: oldState,\n\t      newState: channel.state\n\t    };\n\t    channel.emit('subscribeStateChange', stateChangeData);\n\t    channel.emit('unsubscribe', channelName);\n\t    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n\t    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\n\t  }\n\t};\n\n\tSCSocket.prototype._tryUnsubscribe = function (channel) {\n\t  var self = this;\n\n\t  if (this.state == this.OPEN) {\n\t    var options = {\n\t      noTimeout: true\n\t    };\n\t    if (channel.batch) {\n\t      options.batch = true;\n\t    }\n\t    // If there is a pending subscribe action, cancel the callback\n\t    this._cancelPendingSubscribeCallback(channel);\n\n\t    // This operation cannot fail because the TCP protocol guarantees delivery\n\t    // so long as the connection remains open. If the connection closes,\n\t    // the server will automatically unsubscribe the socket and thus complete\n\t    // the operation on the server side.\n\t    var decoratedChannelName = this._decorateChannelName(channel.name);\n\t    this.transport.emit('#unsubscribe', decoratedChannelName, options);\n\t  }\n\t};\n\n\tSCSocket.prototype.unsubscribe = function (channelName) {\n\n\t  var channel = this.channels[channelName];\n\n\t  if (channel) {\n\t    if (channel.state != channel.UNSUBSCRIBED) {\n\n\t      this._triggerChannelUnsubscribe(channel);\n\t      this._tryUnsubscribe(channel);\n\t    }\n\t  }\n\t};\n\n\tSCSocket.prototype.channel = function (channelName, options) {\n\t  var currentChannel = this.channels[channelName];\n\n\t  if (!currentChannel) {\n\t    currentChannel = new SCChannel(channelName, this, options);\n\t    this.channels[channelName] = currentChannel;\n\t  }\n\t  return currentChannel;\n\t};\n\n\tSCSocket.prototype.destroyChannel = function (channelName) {\n\t  var channel = this.channels[channelName];\n\t  channel.unwatch();\n\t  channel.unsubscribe();\n\t  delete this.channels[channelName];\n\t};\n\n\tSCSocket.prototype.subscriptions = function (includePending) {\n\t  var subs = [];\n\t  var channel, includeChannel;\n\t  for (var channelName in this.channels) {\n\t    if (this.channels.hasOwnProperty(channelName)) {\n\t      channel = this.channels[channelName];\n\n\t      if (includePending) {\n\t        includeChannel = channel && (channel.state == channel.SUBSCRIBED ||\n\t          channel.state == channel.PENDING);\n\t      } else {\n\t        includeChannel = channel && channel.state == channel.SUBSCRIBED;\n\t      }\n\n\t      if (includeChannel) {\n\t        subs.push(channelName);\n\t      }\n\t    }\n\t  }\n\t  return subs;\n\t};\n\n\tSCSocket.prototype.isSubscribed = function (channelName, includePending) {\n\t  var channel = this.channels[channelName];\n\t  if (includePending) {\n\t    return !!channel && (channel.state == channel.SUBSCRIBED ||\n\t      channel.state == channel.PENDING);\n\t  }\n\t  return !!channel && channel.state == channel.SUBSCRIBED;\n\t};\n\n\tSCSocket.prototype.processPendingSubscriptions = function () {\n\t  var self = this;\n\n\t  this.preparingPendingSubscriptions = false;\n\n\t  var pendingChannels = [];\n\n\t  for (var i in this.channels) {\n\t    if (this.channels.hasOwnProperty(i)) {\n\t      var channel = this.channels[i];\n\t      if (channel.state == channel.PENDING) {\n\t        pendingChannels.push(channel);\n\t      }\n\t    }\n\t  }\n\n\t  pendingChannels.sort(function (a, b) {\n\t    var ap = a.priority || 0;\n\t    var bp = b.priority || 0;\n\t    if (ap > bp) {\n\t      return -1;\n\t    }\n\t    if (ap < bp) {\n\t      return 1;\n\t    }\n\t    return 0;\n\t  });\n\n\t  pendingChannels.forEach(function (channel) {\n\t    self._trySubscribe(channel);\n\t  });\n\t};\n\n\tSCSocket.prototype.watch = function (channelName, handler) {\n\t  if (typeof handler != 'function') {\n\t    throw new InvalidArgumentsError('No handler function was provided');\n\t  }\n\t  this._channelEmitter.on(channelName, handler);\n\t};\n\n\tSCSocket.prototype.unwatch = function (channelName, handler) {\n\t  if (handler) {\n\t    this._channelEmitter.removeListener(channelName, handler);\n\t  } else {\n\t    this._channelEmitter.removeAllListeners(channelName);\n\t  }\n\t};\n\n\tSCSocket.prototype.watchers = function (channelName) {\n\t  return this._channelEmitter.listeners(channelName);\n\t};\n\n\tmodule.exports = SCSocket;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5).Buffer))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\n\t'use strict'\n\n\tvar base64 = __webpack_require__(6)\n\tvar ieee754 = __webpack_require__(7)\n\tvar isArray = __webpack_require__(8)\n\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\n\t  return that\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192 // not used by this implementation\n\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\n\t  return fromObject(that, value)\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\n\t  var actual = that.write(string, encoding)\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\n\t  return that\n\t}\n\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\n\t  if (a === b) return 0\n\n\t  var x = a.length\n\t  var y = b.length\n\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\n\t  var len = string.length\n\t  if (len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8'\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\n\t  if (this === target) return 0\n\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8'\n\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\n\t  if (end < start) end = start\n\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\n\t  return newBuf\n\t}\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\n\t  return val\n\t}\n\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\n\t  return val\n\t}\n\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n\t  return val\n\t}\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n\t  return val\n\t}\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\n\t  return offset + byteLength\n\t}\n\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\n\t  return offset + byteLength\n\t}\n\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\n\t  return offset + byteLength\n\t}\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\n\t  return offset + byteLength\n\t}\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\n\t  var len = end - start\n\t  var i\n\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\n\t  return len\n\t}\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\n\t  if (!val) val = 0\n\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\n\t  return this\n\t}\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\n\t    leadSurrogate = null\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\n\t  return byteArray\n\t}\n\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t'use strict'\n\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\n\t  var L = 0\n\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\n\t  return arr\n\t}\n\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\n\t  parts.push(output)\n\n\t  return parts.join('')\n\t}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\n\t  i += d\n\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n\t  value = Math.abs(value)\n\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tvar toString = {}.toString;\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\t/**\n\t * Expose `Emitter`.\n\t */\n\n\tif (true) {\n\t  module.exports = Emitter;\n\t}\n\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\n\tEmitter.prototype.once = function(event, fn){\n\t  function on() {\n\t    this.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\n\t  // specific event\n\t  var callbacks = this._callbacks['$' + event];\n\t  if (!callbacks) return this;\n\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks['$' + event];\n\t    return this;\n\t  }\n\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks['$' + event];\n\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\n\t  return this;\n\t};\n\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks['$' + event] || [];\n\t};\n\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Emitter = __webpack_require__(9);\n\n\tvar SCChannel = function (name, client, options) {\n\t  var self = this;\n\n\t  Emitter.call(this);\n\n\t  this.PENDING = 'pending';\n\t  this.SUBSCRIBED = 'subscribed';\n\t  this.UNSUBSCRIBED = 'unsubscribed';\n\n\t  this.name = name;\n\t  this.state = this.UNSUBSCRIBED;\n\t  this.client = client;\n\n\t  this.options = options || {};\n\t  this.setOptions(this.options);\n\t};\n\n\tSCChannel.prototype = Object.create(Emitter.prototype);\n\n\tSCChannel.prototype.setOptions = function (options) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  this.waitForAuth = options.waitForAuth || false;\n\t  this.batch = options.batch || false;\n\n\t  if (options.data !== undefined) {\n\t    this.data = options.data;\n\t  }\n\t};\n\n\tSCChannel.prototype.getState = function () {\n\t  return this.state;\n\t};\n\n\tSCChannel.prototype.subscribe = function (options) {\n\t  this.client.subscribe(this.name, options);\n\t};\n\n\tSCChannel.prototype.unsubscribe = function () {\n\t  this.client.unsubscribe(this.name);\n\t};\n\n\tSCChannel.prototype.isSubscribed = function (includePending) {\n\t  return this.client.isSubscribed(this.name, includePending);\n\t};\n\n\tSCChannel.prototype.publish = function (data, callback) {\n\t  this.client.publish(this.name, data, callback);\n\t};\n\n\tSCChannel.prototype.watch = function (handler) {\n\t  this.client.watch(this.name, handler);\n\t};\n\n\tSCChannel.prototype.unwatch = function (handler) {\n\t  this.client.unwatch(this.name, handler);\n\t};\n\n\tSCChannel.prototype.watchers = function () {\n\t  return this.client.watchers(this.name);\n\t};\n\n\tSCChannel.prototype.destroy = function () {\n\t  this.client.destroyChannel(this.name);\n\t};\n\n\tmodule.exports.SCChannel = SCChannel;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar scErrors = __webpack_require__(12);\n\tvar InvalidActionError = scErrors.InvalidActionError;\n\n\tvar Response = function (socket, id) {\n\t  this.socket = socket;\n\t  this.id = id;\n\t  this.sent = false;\n\t};\n\n\tResponse.prototype._respond = function (responseData) {\n\t  if (this.sent) {\n\t    throw new InvalidActionError('Response ' + this.id + ' has already been sent');\n\t  } else {\n\t    this.sent = true;\n\t    this.socket.send(this.socket.encode(responseData));\n\t  }\n\t};\n\n\tResponse.prototype.end = function (data) {\n\t  if (this.id) {\n\t    var responseData = {\n\t      rid: this.id\n\t    };\n\t    if (data !== undefined) {\n\t      responseData.data = data;\n\t    }\n\t    this._respond(responseData);\n\t  }\n\t};\n\n\tResponse.prototype.error = function (error, data) {\n\t  if (this.id) {\n\t    var err = scErrors.dehydrateError(error);\n\n\t    var responseData = {\n\t      rid: this.id,\n\t      error: err\n\t    };\n\t    if (data !== undefined) {\n\t      responseData.data = data;\n\t    }\n\n\t    this._respond(responseData);\n\t  }\n\t};\n\n\tResponse.prototype.callback = function (error, data) {\n\t  if (error) {\n\t    this.error(error, data);\n\t  } else {\n\t    this.end(data);\n\t  }\n\t};\n\n\tmodule.exports.Response = Response;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar decycle = __webpack_require__(13);\n\n\tvar isStrict = (function () { return !this; })();\n\n\tfunction AuthTokenExpiredError(message, expiry) {\n\t  this.name = 'AuthTokenExpiredError';\n\t  this.message = message;\n\t  this.expiry = expiry;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tAuthTokenExpiredError.prototype = Object.create(Error.prototype);\n\n\n\tfunction AuthTokenInvalidError(message) {\n\t  this.name = 'AuthTokenInvalidError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tAuthTokenInvalidError.prototype = Object.create(Error.prototype);\n\n\n\tfunction AuthTokenNotBeforeError(message, date) {\n\t  this.name = 'AuthTokenNotBeforeError';\n\t  this.message = message;\n\t  this.date = date;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\n\n\n\t// For any other auth token error.\n\tfunction AuthTokenError(message) {\n\t  this.name = 'AuthTokenError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tAuthTokenError.prototype = Object.create(Error.prototype);\n\n\n\tfunction SilentMiddlewareBlockedError(message, type) {\n\t  this.name = 'SilentMiddlewareBlockedError';\n\t  this.message = message;\n\t  this.type = type;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\n\n\n\tfunction InvalidActionError(message) {\n\t  this.name = 'InvalidActionError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tInvalidActionError.prototype = Object.create(Error.prototype);\n\n\tfunction InvalidArgumentsError(message) {\n\t  this.name = 'InvalidArgumentsError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tInvalidArgumentsError.prototype = Object.create(Error.prototype);\n\n\tfunction InvalidOptionsError(message) {\n\t  this.name = 'InvalidOptionsError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tInvalidOptionsError.prototype = Object.create(Error.prototype);\n\n\n\tfunction InvalidMessageError(message) {\n\t  this.name = 'InvalidMessageError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tInvalidMessageError.prototype = Object.create(Error.prototype);\n\n\n\tfunction SocketProtocolError(message, code) {\n\t  this.name = 'SocketProtocolError';\n\t  this.message = message;\n\t  this.code = code;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tSocketProtocolError.prototype = Object.create(Error.prototype);\n\n\n\tfunction ServerProtocolError(message) {\n\t  this.name = 'ServerProtocolError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tServerProtocolError.prototype = Object.create(Error.prototype);\n\n\tfunction HTTPServerError(message) {\n\t  this.name = 'HTTPServerError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tHTTPServerError.prototype = Object.create(Error.prototype);\n\n\n\tfunction ResourceLimitError(message) {\n\t  this.name = 'ResourceLimitError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tResourceLimitError.prototype = Object.create(Error.prototype);\n\n\n\tfunction TimeoutError(message) {\n\t  this.name = 'TimeoutError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tTimeoutError.prototype = Object.create(Error.prototype);\n\n\n\tfunction BadConnectionError(message, type) {\n\t  this.name = 'BadConnectionError';\n\t  this.message = message;\n\t  this.type = type;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tBadConnectionError.prototype = Object.create(Error.prototype);\n\n\n\tfunction BrokerError(message) {\n\t  this.name = 'BrokerError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tBrokerError.prototype = Object.create(Error.prototype);\n\n\n\tfunction ProcessExitError(message, code) {\n\t  this.name = 'ProcessExitError';\n\t  this.message = message;\n\t  this.code = code;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tProcessExitError.prototype = Object.create(Error.prototype);\n\n\n\tfunction UnknownError(message) {\n\t  this.name = 'UnknownError';\n\t  this.message = message;\n\t  if (Error.captureStackTrace && !isStrict) {\n\t    Error.captureStackTrace(this, arguments.callee);\n\t  } else {\n\t    this.stack = (new Error()).stack;\n\t  }\n\t}\n\tUnknownError.prototype = Object.create(Error.prototype);\n\n\n\t// Expose all error types\n\n\tmodule.exports = {\n\t  AuthTokenExpiredError: AuthTokenExpiredError,\n\t  AuthTokenInvalidError: AuthTokenInvalidError,\n\t  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\n\t  AuthTokenError: AuthTokenError,\n\t  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\n\t  InvalidActionError: InvalidActionError,\n\t  InvalidArgumentsError: InvalidArgumentsError,\n\t  InvalidOptionsError: InvalidOptionsError,\n\t  InvalidMessageError: InvalidMessageError,\n\t  SocketProtocolError: SocketProtocolError,\n\t  ServerProtocolError: ServerProtocolError,\n\t  HTTPServerError: HTTPServerError,\n\t  ResourceLimitError: ResourceLimitError,\n\t  TimeoutError: TimeoutError,\n\t  BadConnectionError: BadConnectionError,\n\t  BrokerError: BrokerError,\n\t  ProcessExitError: ProcessExitError,\n\t  UnknownError: UnknownError\n\t};\n\n\tmodule.exports.socketProtocolErrorStatuses = {\n\t  1001: 'Socket was disconnected',\n\t  1002: 'A WebSocket protocol error was encountered',\n\t  1003: 'Server terminated socket because it received invalid data',\n\t  1005: 'Socket closed without status code',\n\t  1006: 'Socket hung up',\n\t  1007: 'Message format was incorrect',\n\t  1008: 'Encountered a policy violation',\n\t  1009: 'Message was too big to process',\n\t  1010: 'Client ended the connection because the server did not comply with extension requirements',\n\t  1011: 'Server encountered an unexpected fatal condition',\n\t  4000: 'Server ping timed out',\n\t  4001: 'Client pong timed out',\n\t  4002: 'Server failed to sign auth token',\n\t  4003: 'Failed to complete handshake',\n\t  4004: 'Client failed to save auth token',\n\t  4005: 'Did not receive #handshake from client before timeout',\n\t  4006: 'Failed to bind socket to message broker',\n\t  4007: 'Client connection establishment timed out'\n\t};\n\n\tmodule.exports.socketProtocolIgnoreStatuses = {\n\t  1000: 'Socket closed normally',\n\t  1001: 'Socket hung up'\n\t};\n\n\t// Properties related to error domains cannot be serialized.\n\tvar unserializableErrorProperties = {\n\t  domain: 1,\n\t  domainEmitter: 1,\n\t  domainThrown: 1\n\t};\n\n\tmodule.exports.dehydrateError = function (error, includeStackTrace) {\n\t  var dehydratedError;\n\n\t  if (error && typeof error == 'object') {\n\t    dehydratedError = {\n\t      message: error.message\n\t    };\n\t    if (includeStackTrace) {\n\t      dehydratedError.stack = error.stack;\n\t    }\n\t    for (var i in error) {\n\t      if (!unserializableErrorProperties[i]) {\n\t        dehydratedError[i] = error[i];\n\t      }\n\t    }\n\t  } else if (typeof error == 'function') {\n\t    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\n\t  } else {\n\t    dehydratedError = error;\n\t  }\n\n\t  return decycle(dehydratedError);\n\t};\n\n\tmodule.exports.hydrateError = function (error) {\n\t  var hydratedError = null;\n\t  if (error != null) {\n\t    if (typeof error == 'object') {\n\t      hydratedError = new Error(error.message);\n\t      for (var i in error) {\n\t        if (error.hasOwnProperty(i)) {\n\t          hydratedError[i] = error[i];\n\t        }\n\t      }\n\t    } else {\n\t      hydratedError = error;\n\t    }\n\t  }\n\t  return hydratedError;\n\t};\n\n\tmodule.exports.decycle = decycle;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t// Based on https://github.com/dscape/cycle/blob/master/cycle.js\n\n\tmodule.exports = function decycle(object) {\n\t// Make a deep copy of an object or array, assuring that there is at most\n\t// one instance of each object or array in the resulting structure. The\n\t// duplicate references (which might be forming cycles) are replaced with\n\t// an object of the form\n\t//      {$ref: PATH}\n\t// where the PATH is a JSONPath string that locates the first occurance.\n\t// So,\n\t//      var a = [];\n\t//      a[0] = a;\n\t//      return JSON.stringify(JSON.decycle(a));\n\t// produces the string '[{\"$ref\":\"$\"}]'.\n\n\t// JSONPath is used to locate the unique object. $ indicates the top level of\n\t// the object or array. [NUMBER] or [STRING] indicates a child member or\n\t// property.\n\n\t    var objects = [],   // Keep a reference to each unique object or array\n\t        paths = [];     // Keep the path to each unique object or array\n\n\t    return (function derez(value, path) {\n\n\t// The derez recurses through the object, producing the deep copy.\n\n\t        var i,          // The loop counter\n\t            name,       // Property name\n\t            nu;         // The new object or array\n\n\t// typeof null === 'object', so go on if this value is really an object but not\n\t// one of the weird builtin objects.\n\n\t        if (typeof value === 'object' && value !== null &&\n\t                !(value instanceof Boolean) &&\n\t                !(value instanceof Date)    &&\n\t                !(value instanceof Number)  &&\n\t                !(value instanceof RegExp)  &&\n\t                !(value instanceof String)) {\n\n\t// If the value is an object or array, look to see if we have already\n\t// encountered it. If so, return a $ref/path object. This is a hard way,\n\t// linear search that will get slower as the number of unique objects grows.\n\n\t            for (i = 0; i < objects.length; i += 1) {\n\t                if (objects[i] === value) {\n\t                    return {$ref: paths[i]};\n\t                }\n\t            }\n\n\t// Otherwise, accumulate the unique value and its path.\n\n\t            objects.push(value);\n\t            paths.push(path);\n\n\t// If it is an array, replicate the array.\n\n\t            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\t                nu = [];\n\t                for (i = 0; i < value.length; i += 1) {\n\t                    nu[i] = derez(value[i], path + '[' + i + ']');\n\t                }\n\t            } else {\n\n\t// If it is an object, replicate the object.\n\n\t                nu = {};\n\t                for (name in value) {\n\t                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n\t                        nu[name] = derez(value[name],\n\t                            path + '[' + JSON.stringify(name) + ']');\n\t                    }\n\t                }\n\t            }\n\t            return nu;\n\t        }\n\t        return value;\n\t    }(object, '$'));\n\t};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var AuthEngine = function () {\n\t  this._internalStorage = {};\n\t  this.isLocalStorageEnabled = this._checkLocalStorageEnabled();\n\t};\n\n\tAuthEngine.prototype._checkLocalStorageEnabled = function () {\n\t  var err;\n\t  try {\n\t    // Some browsers will throw an error here if localStorage is disabled.\n\t    global.localStorage;\n\n\t    // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n\t    // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.\n\t    global.localStorage.setItem('__scLocalStorageTest', 1);\n\t    global.localStorage.removeItem('__scLocalStorageTest');\n\t  } catch (e) {\n\t    err = e;\n\t  }\n\t  return !err;\n\t};\n\n\tAuthEngine.prototype.saveToken = function (name, token, options, callback) {\n\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t    global.localStorage.setItem(name, token);\n\t  } else {\n\t    this._internalStorage[name] = token;\n\t  }\n\t  callback && callback(null, token);\n\t};\n\n\tAuthEngine.prototype.removeToken = function (name, callback) {\n\t  var token;\n\n\t  this.loadToken(name, function (err, authToken) {\n\t    token = authToken;\n\t  });\n\n\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t    global.localStorage.removeItem(name);\n\t  } else {\n\t    delete this._internalStorage[name];\n\t  }\n\n\t  callback && callback(null, token);\n\t};\n\n\tAuthEngine.prototype.loadToken = function (name, callback) {\n\t  var token;\n\n\t  if (this.isLocalStorageEnabled && global.localStorage) {\n\t    token = global.localStorage.getItem(name);\n\t  } else {\n\t    token = this._internalStorage[name] || null;\n\t  }\n\t  callback(null, token);\n\t};\n\n\tmodule.exports.AuthEngine = AuthEngine;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\tvar arrayBufferToBase64 = function (arraybuffer) {\n\t  var bytes = new Uint8Array(arraybuffer);\n\t  var len = bytes.length;\n\t  var base64 = '';\n\n\t  for (var i = 0; i < len; i += 3) {\n\t    base64 += base64Chars[bytes[i] >> 2];\n\t    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t    base64 += base64Chars[bytes[i + 2] & 63];\n\t  }\n\n\t  if ((len % 3) === 2) {\n\t    base64 = base64.substring(0, base64.length - 1) + '=';\n\t  } else if (len % 3 === 1) {\n\t    base64 = base64.substring(0, base64.length - 2) + '==';\n\t  }\n\n\t  return base64;\n\t};\n\n\tvar binaryToBase64Replacer = function (key, value) {\n\t  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n\t    return {\n\t      base64: true,\n\t      data: arrayBufferToBase64(value)\n\t    };\n\t  } else if (global.Buffer) {\n\t    if (value instanceof global.Buffer){\n\t      return {\n\t        base64: true,\n\t        data: value.toString('base64')\n\t      };\n\t    }\n\t    // Some versions of Node.js convert Buffers to Objects before they are passed to\n\t    // the replacer function - Because of this, we need to rehydrate Buffers\n\t    // before we can convert them to base64 strings.\n\t    if (value && value.type == 'Buffer' && value.data instanceof Array) {\n\t      var rehydratedBuffer;\n\t      if (global.Buffer.from) {\n\t        rehydratedBuffer = global.Buffer.from(value.data);\n\t      } else {\n\t        rehydratedBuffer = new global.Buffer(value.data);\n\t      }\n\t      return {\n\t        base64: true,\n\t        data: rehydratedBuffer.toString('base64')\n\t      };\n\t    }\n\t  }\n\t  return value;\n\t};\n\n\t// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n\t// See encode function below for more details.\n\tmodule.exports.decode = function (input) {\n\t  if (input == null) {\n\t   return null;\n\t  }\n\t  // Leave ping or pong message as is\n\t  if (input == '#1' || input == '#2') {\n\t    return input;\n\t  }\n\t  var message = input.toString();\n\n\t  try {\n\t    return JSON.parse(message);\n\t  } catch (err) {}\n\t  return message;\n\t};\n\n\n\t// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n\t// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n\t// If you want to create your own custom codec, you can encode the object into any format\n\t// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n\t// function is able to rehydrate that object back into its original JavaScript Object format\n\t// (which adheres to the SC protocol).\n\t// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n\t// for details about the SC protocol.\n\tmodule.exports.encode = function (object) {\n\t  // Leave ping or pong message as is\n\t  if (object == '#1' || object == '#2') {\n\t    return object;\n\t  }\n\t  return JSON.stringify(object, binaryToBase64Replacer);\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var Emitter = __webpack_require__(9);\n\tvar Response = __webpack_require__(11).Response;\n\tvar querystring = __webpack_require__(17);\n\tvar WebSocket;\n\tvar createWebSocket;\n\n\tif (global.WebSocket) {\n\t  WebSocket = global.WebSocket;\n\t  createWebSocket = function (uri, options) {\n\t    return new WebSocket(uri);\n\t  };\n\t} else {\n\t  WebSocket = __webpack_require__(20);\n\t  createWebSocket = function (uri, options) {\n\t    return new WebSocket(uri, null, options);\n\t  };\n\t}\n\n\tvar scErrors = __webpack_require__(12);\n\tvar TimeoutError = scErrors.TimeoutError;\n\tvar BadConnectionError = scErrors.BadConnectionError;\n\n\n\tvar SCTransport = function (authEngine, codecEngine, options) {\n\t  this.state = this.CLOSED;\n\t  this.auth = authEngine;\n\t  this.codec = codecEngine;\n\t  this.options = options;\n\t  this.connectTimeout = options.connectTimeout;\n\t  this.pingTimeout = options.ackTimeout;\n\t  this.callIdGenerator = options.callIdGenerator;\n\t  this.authTokenName = options.authTokenName;\n\n\t  this._pingTimeoutTicker = null;\n\t  this._callbackMap = {};\n\t  this._batchSendList = [];\n\n\t  this.open();\n\t};\n\n\tSCTransport.prototype = Object.create(Emitter.prototype);\n\n\tSCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';\n\tSCTransport.OPEN = SCTransport.prototype.OPEN = 'open';\n\tSCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';\n\n\tSCTransport.prototype.uri = function () {\n\t  var query = this.options.query || {};\n\t  var schema = this.options.secure ? 'wss' : 'ws';\n\n\t  if (this.options.timestampRequests) {\n\t    query[this.options.timestampParam] = (new Date()).getTime();\n\t  }\n\n\t  query = querystring.encode(query);\n\n\t  if (query.length) {\n\t    query = '?' + query;\n\t  }\n\n\t  var host;\n\t  if (this.options.host) {\n\t    host = this.options.host;\n\t  } else {\n\t    var port = '';\n\n\t    if (this.options.port && ((schema == 'wss' && this.options.port != 443)\n\t      || (schema == 'ws' && this.options.port != 80))) {\n\t      port = ':' + this.options.port;\n\t    }\n\t    host = this.options.hostname + port;\n\t  }\n\n\t  return schema + '://' + host + this.options.path + query;\n\t};\n\n\tSCTransport.prototype.open = function () {\n\t  var self = this;\n\n\t  this.state = this.CONNECTING;\n\t  var uri = this.uri();\n\n\t  var wsSocket = createWebSocket(uri, this.options);\n\t  wsSocket.binaryType = this.options.binaryType;\n\t  this.socket = wsSocket;\n\n\t  wsSocket.onopen = function () {\n\t    self._onOpen();\n\t  };\n\n\t  wsSocket.onclose = function (event) {\n\t    var code;\n\t    if (event.code == null) {\n\t      // This is to handle an edge case in React Native whereby\n\t      // event.code is undefined when the mobile device is locked.\n\t      // TODO: This is not perfect since this condition could also apply to\n\t      // an abnormal close (no close control frame) which would be a 1006.\n\t      code = 1005;\n\t    } else {\n\t      code = event.code;\n\t    }\n\t    self._onClose(code, event.reason);\n\t  };\n\n\t  wsSocket.onmessage = function (message, flags) {\n\t    self._onMessage(message.data);\n\t  };\n\n\t  wsSocket.onerror = function (error) {\n\t    // The onclose event will be called automatically after the onerror event\n\t    // if the socket is connected - Otherwise, if it's in the middle of\n\t    // connecting, we want to close it manually with a 1006 - This is necessary\n\t    // to prevent inconsistent behavior when running the client in Node.js\n\t    // vs in a browser.\n\n\t    if (self.state === self.CONNECTING) {\n\t      self._onClose(1006);\n\t    }\n\t  };\n\n\t  this._connectTimeoutRef = setTimeout(function () {\n\t    self._onClose(4007);\n\t    self.socket.close(4007);\n\t  }, this.connectTimeout);\n\t};\n\n\tSCTransport.prototype._onOpen = function () {\n\t  var self = this;\n\n\t  clearTimeout(this._connectTimeoutRef);\n\t  this._resetPingTimeout();\n\n\t  this._handshake(function (err, status) {\n\t    if (err) {\n\t      self._onError(err);\n\t      self._onClose(4003);\n\t      self.socket.close(4003);\n\t    } else {\n\t      self.state = self.OPEN;\n\t      Emitter.prototype.emit.call(self, 'open', status);\n\t      self._resetPingTimeout();\n\t    }\n\t  });\n\t};\n\n\tSCTransport.prototype._handshake = function (callback) {\n\t  var self = this;\n\t  this.auth.loadToken(this.authTokenName, function (err, token) {\n\t    if (err) {\n\t      callback(err);\n\t    } else {\n\t      // Don't wait for this.state to be 'open'.\n\t      // The underlying WebSocket (this.socket) is already open.\n\t      var options = {\n\t        force: true\n\t      };\n\t      self.emit('#handshake', {\n\t        authToken: token\n\t      }, options, function (err, status) {\n\t        if (status) {\n\t          // Add the token which was used as part of authentication attempt\n\t          // to the status object.\n\t          status.authToken = token;\n\t          if (status.authError) {\n\t            status.authError = scErrors.hydrateError(status.authError);\n\t          }\n\t        }\n\t        callback(err, status);\n\t      });\n\t    }\n\t  });\n\t};\n\n\tSCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n\t  for (var i in this._callbackMap) {\n\t    if (this._callbackMap.hasOwnProperty(i)) {\n\t      var eventObject = this._callbackMap[i];\n\t      delete this._callbackMap[i];\n\n\t      clearTimeout(eventObject.timeout);\n\t      delete eventObject.timeout;\n\n\t      var errorMessage = \"Event '\" + eventObject.event +\n\t        \"' was aborted due to a bad connection\";\n\t      var badConnectionError = new BadConnectionError(errorMessage, failureType);\n\n\t      var callback = eventObject.callback;\n\t      delete eventObject.callback;\n\t      callback.call(eventObject, badConnectionError, eventObject);\n\t    }\n\t  }\n\t};\n\n\tSCTransport.prototype._onClose = function (code, data) {\n\t  delete this.socket.onopen;\n\t  delete this.socket.onclose;\n\t  delete this.socket.onmessage;\n\t  delete this.socket.onerror;\n\n\t  clearTimeout(this._connectTimeoutRef);\n\n\t  if (this.state == this.OPEN) {\n\t    this.state = this.CLOSED;\n\t    Emitter.prototype.emit.call(this, 'close', code, data);\n\t    this._abortAllPendingEventsDueToBadConnection('disconnect');\n\n\t  } else if (this.state == this.CONNECTING) {\n\t    this.state = this.CLOSED;\n\t    Emitter.prototype.emit.call(this, 'openAbort', code, data);\n\t    this._abortAllPendingEventsDueToBadConnection('connectAbort');\n\t  }\n\t};\n\n\tSCTransport.prototype._handleEventObject = function (obj, message) {\n\t  if (obj && obj.event != null) {\n\t    var response = new Response(this, obj.cid);\n\t    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);\n\t  } else if (obj && obj.rid != null) {\n\t    var eventObject = this._callbackMap[obj.rid];\n\t    if (eventObject) {\n\t      clearTimeout(eventObject.timeout);\n\t      delete eventObject.timeout;\n\t      delete this._callbackMap[obj.rid];\n\n\t      if (eventObject.callback) {\n\t        var rehydratedError = scErrors.hydrateError(obj.error);\n\t        eventObject.callback(rehydratedError, obj.data);\n\t      }\n\t    }\n\t  } else {\n\t    Emitter.prototype.emit.call(this, 'event', 'raw', message);\n\t  }\n\t};\n\n\tSCTransport.prototype._onMessage = function (message) {\n\t  Emitter.prototype.emit.call(this, 'event', 'message', message);\n\n\t  var obj = this.decode(message);\n\n\t  // If ping\n\t  if (obj == '#1') {\n\t    this._resetPingTimeout();\n\t    if (this.socket.readyState == this.socket.OPEN) {\n\t      this.sendObject('#2');\n\t    }\n\t  } else {\n\t    if (Array.isArray(obj)) {\n\t      var len = obj.length;\n\t      for (var i = 0; i < len; i++) {\n\t        this._handleEventObject(obj[i], message);\n\t      }\n\t    } else {\n\t      this._handleEventObject(obj, message);\n\t    }\n\t  }\n\t};\n\n\tSCTransport.prototype._onError = function (err) {\n\t  Emitter.prototype.emit.call(this, 'error', err);\n\t};\n\n\tSCTransport.prototype._resetPingTimeout = function () {\n\t  var self = this;\n\n\t  var now = (new Date()).getTime();\n\t  clearTimeout(this._pingTimeoutTicker);\n\n\t  this._pingTimeoutTicker = setTimeout(function () {\n\t    self._onClose(4000);\n\t    self.socket.close(4000);\n\t  }, this.pingTimeout);\n\t};\n\n\tSCTransport.prototype.getBytesReceived = function () {\n\t  return this.socket.bytesReceived;\n\t};\n\n\tSCTransport.prototype.close = function (code, data) {\n\t  code = code || 1000;\n\n\t  if (this.state == this.OPEN) {\n\t    var packet = {\n\t      code: code,\n\t      data: data\n\t    };\n\t    this.emit('#disconnect', packet);\n\n\t    this._onClose(code, data);\n\t    this.socket.close(code);\n\n\t  } else if (this.state == this.CONNECTING) {\n\t    this._onClose(code, data);\n\t    this.socket.close(code);\n\t  }\n\t};\n\n\tSCTransport.prototype.emitObject = function (eventObject, options) {\n\t  var simpleEventObject = {\n\t    event: eventObject.event,\n\t    data: eventObject.data\n\t  };\n\n\t  if (eventObject.callback) {\n\t    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();\n\t    this._callbackMap[eventObject.cid] = eventObject;\n\t  }\n\n\t  this.sendObject(simpleEventObject, options);\n\n\t  return eventObject.cid || null;\n\t};\n\n\tSCTransport.prototype._handleEventAckTimeout = function (eventObject) {\n\n\t  if (eventObject.cid) {\n\t    delete this._callbackMap[eventObject.cid];\n\t  }\n\t  delete eventObject.timeout;\n\n\t  var callback = eventObject.callback;\n\t  if (callback) {\n\t    delete eventObject.callback;\n\t    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n\t    callback.call(eventObject, error, eventObject);\n\t  }\n\t};\n\n\t// The last two optional arguments (a and b) can be options and/or callback\n\tSCTransport.prototype.emit = function (event, data, a, b) {\n\t  var self = this;\n\n\t  var callback, options;\n\n\t  if (b) {\n\t    options = a;\n\t    callback = b;\n\t  } else {\n\t    if (a instanceof Function) {\n\t      options = {};\n\t      callback = a;\n\t    } else {\n\t      options = a;\n\t    }\n\t  }\n\n\t  var eventObject = {\n\t    event: event,\n\t    data: data,\n\t    callback: callback\n\t  };\n\n\t  if (callback && !options.noTimeout) {\n\t    eventObject.timeout = setTimeout(function () {\n\t      self._handleEventAckTimeout(eventObject);\n\t    }, this.options.ackTimeout);\n\t  }\n\n\t  var cid = null;\n\t  if (this.state == this.OPEN || options.force) {\n\t    cid = this.emitObject(eventObject, options);\n\t  }\n\t  return cid;\n\t};\n\n\tSCTransport.prototype.cancelPendingResponse = function (cid) {\n\t  delete this._callbackMap[cid];\n\t};\n\n\tSCTransport.prototype.decode = function (message) {\n\t  return this.codec.decode(message);\n\t};\n\n\tSCTransport.prototype.encode = function (object) {\n\t  return this.codec.encode(object);\n\t};\n\n\tSCTransport.prototype.send = function (data) {\n\t  if (this.socket.readyState != this.socket.OPEN) {\n\t    this._onClose(1005);\n\t  } else {\n\t    this.socket.send(data);\n\t  }\n\t};\n\n\tSCTransport.prototype.serializeObject = function (object) {\n\t  var str, formatError;\n\t  try {\n\t    str = this.encode(object);\n\t  } catch (err) {\n\t    formatError = err;\n\t    this._onError(formatError);\n\t  }\n\t  if (!formatError) {\n\t    return str;\n\t  }\n\t  return null;\n\t};\n\n\tSCTransport.prototype.sendObjectBatch = function (object) {\n\t  var self = this;\n\n\t  this._batchSendList.push(object);\n\t  if (this._batchTimeout) {\n\t    return;\n\t  }\n\n\t  this._batchTimeout = setTimeout(function () {\n\t    delete self._batchTimeout;\n\t    if (self._batchSendList.length) {\n\t      var str = self.serializeObject(self._batchSendList);\n\t      if (str != null) {\n\t        self.send(str);\n\t      }\n\t      self._batchSendList = [];\n\t    }\n\t  }, this.options.pubSubBatchDuration || 0);\n\t};\n\n\tSCTransport.prototype.sendObjectSingle = function (object) {\n\t  var str = this.serializeObject(object);\n\t  if (str != null) {\n\t    this.send(str);\n\t  }\n\t};\n\n\tSCTransport.prototype.sendObject = function (object, options) {\n\t  if (options && options.batch) {\n\t    this.sendObjectBatch(object);\n\t  } else {\n\t    this.sendObjectSingle(object);\n\t  }\n\t};\n\n\tmodule.exports.SCTransport = SCTransport;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.decode = exports.parse = __webpack_require__(18);\n\texports.encode = exports.stringify = __webpack_require__(19);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\t'use strict';\n\n\t// If obj.hasOwnProperty has been overridden, then calling\n\t// obj.hasOwnProperty(prop) will break.\n\t// See: https://github.com/joyent/node/issues/1707\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\n\tmodule.exports = function(qs, sep, eq, options) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  var obj = {};\n\n\t  if (typeof qs !== 'string' || qs.length === 0) {\n\t    return obj;\n\t  }\n\n\t  var regexp = /\\+/g;\n\t  qs = qs.split(sep);\n\n\t  var maxKeys = 1000;\n\t  if (options && typeof options.maxKeys === 'number') {\n\t    maxKeys = options.maxKeys;\n\t  }\n\n\t  var len = qs.length;\n\t  // maxKeys <= 0 means that we should not limit keys count\n\t  if (maxKeys > 0 && len > maxKeys) {\n\t    len = maxKeys;\n\t  }\n\n\t  for (var i = 0; i < len; ++i) {\n\t    var x = qs[i].replace(regexp, '%20'),\n\t        idx = x.indexOf(eq),\n\t        kstr, vstr, k, v;\n\n\t    if (idx >= 0) {\n\t      kstr = x.substr(0, idx);\n\t      vstr = x.substr(idx + 1);\n\t    } else {\n\t      kstr = x;\n\t      vstr = '';\n\t    }\n\n\t    k = decodeURIComponent(kstr);\n\t    v = decodeURIComponent(vstr);\n\n\t    if (!hasOwnProperty(obj, k)) {\n\t      obj[k] = v;\n\t    } else if (Array.isArray(obj[k])) {\n\t      obj[k].push(v);\n\t    } else {\n\t      obj[k] = [obj[k], v];\n\t    }\n\t  }\n\n\t  return obj;\n\t};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\t'use strict';\n\n\tvar stringifyPrimitive = function(v) {\n\t  switch (typeof v) {\n\t    case 'string':\n\t      return v;\n\n\t    case 'boolean':\n\t      return v ? 'true' : 'false';\n\n\t    case 'number':\n\t      return isFinite(v) ? v : '';\n\n\t    default:\n\t      return '';\n\t  }\n\t};\n\n\tmodule.exports = function(obj, sep, eq, name) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  if (obj === null) {\n\t    obj = undefined;\n\t  }\n\n\t  if (typeof obj === 'object') {\n\t    return Object.keys(obj).map(function(k) {\n\t      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\t      if (Array.isArray(obj[k])) {\n\t        return obj[k].map(function(v) {\n\t          return ks + encodeURIComponent(stringifyPrimitive(v));\n\t        }).join(sep);\n\t      } else {\n\t        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n\t      }\n\t    }).join(sep);\n\n\t  }\n\n\t  if (!name) return '';\n\t  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n\t         encodeURIComponent(stringifyPrimitive(obj));\n\t};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\tvar global;\n\tif (typeof WorkerGlobalScope !== 'undefined') {\n\t  global = self;\n\t} else {\n\t  global = typeof window != 'undefined' && window || (function() { return this; })();\n\t}\n\n\tvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n\t/**\n\t * WebSocket constructor.\n\t *\n\t * The third `opts` options object gets ignored in web browsers, since it's\n\t * non-standard, and throws a TypeError if passed to the constructor.\n\t * See: https://github.com/einaros/ws/issues/227\n\t *\n\t * @param {String} uri\n\t * @param {Array} protocols (optional)\n\t * @param {Object} opts (optional)\n\t * @api public\n\t */\n\n\tfunction ws(uri, protocols, opts) {\n\t  var instance;\n\t  if (protocols) {\n\t    instance = new WebSocket(uri, protocols);\n\t  } else {\n\t    instance = new WebSocket(uri);\n\t  }\n\t  return instance;\n\t}\n\n\tif (WebSocket) ws.prototype = WebSocket.prototype;\n\n\tmodule.exports = WebSocket ? ws : null;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(22);\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\t/**\n\t * Constants.\n\t */\n\n\tvar errorMessage;\n\n\terrorMessage = 'An argument without append, prepend, ' +\n\t    'or detach methods was given to `List';\n\n\t/**\n\t * Creates a new List: A linked list is a bit like an Array, but\n\t * knows nothing about how many items are in it, and knows only about its\n\t * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n\t * &c.) knows which item comes before or after it (its more like the\n\t * implementation of the DOM in JavaScript).\n\t * @global\n\t * @private\n\t * @constructor\n\t * @class Represents an instance of List.\n\t */\n\n\tfunction List(/*items...*/) {\n\t    if (arguments.length) {\n\t        return List.from(arguments);\n\t    }\n\t}\n\n\tvar ListPrototype;\n\n\tListPrototype = List.prototype;\n\n\t/**\n\t * Creates a new list from the arguments (each a list item) passed in.\n\t * @name List.of\n\t * @param {...ListItem} [items] - Zero or more items to attach.\n\t * @returns {list} - A new instance of List.\n\t */\n\n\tList.of = function (/*items...*/) {\n\t    return List.from.call(this, arguments);\n\t};\n\n\t/**\n\t * Creates a new list from the given array-like object (each a list item)\n\t * passed in.\n\t * @name List.from\n\t * @param {ListItem[]} [items] - The items to append.\n\t * @returns {list} - A new instance of List.\n\t */\n\tList.from = function (items) {\n\t    var list = new this(), length, iterator, item;\n\n\t    if (items && (length = items.length)) {\n\t        iterator = -1;\n\n\t        while (++iterator < length) {\n\t            item = items[iterator];\n\n\t            if (item !== null && item !== undefined) {\n\t                list.append(item);\n\t            }\n\t        }\n\t    }\n\n\t    return list;\n\t};\n\n\t/**\n\t * List#head\n\t * Default to `null`.\n\t */\n\tListPrototype.head = null;\n\n\t/**\n\t * List#tail\n\t * Default to `null`.\n\t */\n\tListPrototype.tail = null;\n\n\t/**\n\t * Returns the list's items as an array. This does *not* detach the items.\n\t * @name List#toArray\n\t * @returns {ListItem[]} - An array of (still attached) ListItems.\n\t */\n\tListPrototype.toArray = function () {\n\t    var item = this.head,\n\t        result = [];\n\n\t    while (item) {\n\t        result.push(item);\n\t        item = item.next;\n\t    }\n\n\t    return result;\n\t};\n\n\t/**\n\t * Prepends the given item to the list: Item will be the new first item\n\t * (`head`).\n\t * @name List#prepend\n\t * @param {ListItem} item - The item to prepend.\n\t * @returns {ListItem} - An instance of ListItem (the given item).\n\t */\n\tListPrototype.prepend = function (item) {\n\t    if (!item) {\n\t        return false;\n\t    }\n\n\t    if (!item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + '#prepend`.');\n\t    }\n\n\t    var self, head;\n\n\t    // Cache self.\n\t    self = this;\n\n\t    // If self has a first item, defer prepend to the first items prepend\n\t    // method, and return the result.\n\t    head = self.head;\n\n\t    if (head) {\n\t        return head.prepend(item);\n\t    }\n\n\t    // ...otherwise, there is no `head` (or `tail`) item yet.\n\n\t    // Detach the prependee.\n\t    item.detach();\n\n\t    // Set the prependees parent list to reference self.\n\t    item.list = self;\n\n\t    // Set self's first item to the prependee, and return the item.\n\t    self.head = item;\n\n\t    return item;\n\t};\n\n\t/**\n\t * Appends the given item to the list: Item will be the new last item (`tail`)\n\t * if the list had a first item, and its first item (`head`) otherwise.\n\t * @name List#append\n\t * @param {ListItem} item - The item to append.\n\t * @returns {ListItem} - An instance of ListItem (the given item).\n\t */\n\n\tListPrototype.append = function (item) {\n\t    if (!item) {\n\t        return false;\n\t    }\n\n\t    if (!item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + '#append`.');\n\t    }\n\n\t    var self, head, tail;\n\n\t    // Cache self.\n\t    self = this;\n\n\t    // If self has a last item, defer appending to the last items append\n\t    // method, and return the result.\n\t    tail = self.tail;\n\n\t    if (tail) {\n\t        return tail.append(item);\n\t    }\n\n\t    // If self has a first item, defer appending to the first items append\n\t    // method, and return the result.\n\t    head = self.head;\n\n\t    if (head) {\n\t        return head.append(item);\n\t    }\n\n\t    // ...otherwise, there is no `tail` or `head` item yet.\n\n\t    // Detach the appendee.\n\t    item.detach();\n\n\t    // Set the appendees parent list to reference self.\n\t    item.list = self;\n\n\t    // Set self's first item to the appendee, and return the item.\n\t    self.head = item;\n\n\t    return item;\n\t};\n\n\t/**\n\t * Creates a new ListItem: A linked list item is a bit like DOM node:\n\t * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n\t * and the item after it (`next`).\n\t * @global\n\t * @private\n\t * @constructor\n\t * @class Represents an instance of ListItem.\n\t */\n\n\tfunction ListItem() {}\n\n\tList.Item = ListItem;\n\n\tvar ListItemPrototype = ListItem.prototype;\n\n\tListItemPrototype.next = null;\n\n\tListItemPrototype.prev = null;\n\n\tListItemPrototype.list = null;\n\n\t/**\n\t * Detaches the item operated on from its parent list.\n\t * @name ListItem#detach\n\t * @returns {ListItem} - The item operated on.\n\t */\n\tListItemPrototype.detach = function () {\n\t    // Cache self, the parent list, and the previous and next items.\n\t    var self = this,\n\t        list = self.list,\n\t        prev = self.prev,\n\t        next = self.next;\n\n\t    // If the item is already detached, return self.\n\t    if (!list) {\n\t        return self;\n\t    }\n\n\t    // If self is the last item in the parent list, link the lists last item\n\t    // to the previous item.\n\t    if (list.tail === self) {\n\t        list.tail = prev;\n\t    }\n\n\t    // If self is the first item in the parent list, link the lists first item\n\t    // to the next item.\n\t    if (list.head === self) {\n\t        list.head = next;\n\t    }\n\n\t    // If both the last and first items in the parent list are the same,\n\t    // remove the link to the last item.\n\t    if (list.tail === list.head) {\n\t        list.tail = null;\n\t    }\n\n\t    // If a previous item exists, link its next item to selfs next item.\n\t    if (prev) {\n\t        prev.next = next;\n\t    }\n\n\t    // If a next item exists, link its previous item to selfs previous item.\n\t    if (next) {\n\t        next.prev = prev;\n\t    }\n\n\t    // Remove links from self to both the next and previous items, and to the\n\t    // parent list.\n\t    self.prev = self.next = self.list = null;\n\n\t    // Return self.\n\t    return self;\n\t};\n\n\t/**\n\t * Prepends the given item *before* the item operated on.\n\t * @name ListItem#prepend\n\t * @param {ListItem} item - The item to prepend.\n\t * @returns {ListItem} - The item operated on, or false when that item is not\n\t * attached.\n\t */\n\tListItemPrototype.prepend = function (item) {\n\t    if (!item || !item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + 'Item#prepend`.');\n\t    }\n\n\t    // Cache self, the parent list, and the previous item.\n\t    var self = this,\n\t        list = self.list,\n\t        prev = self.prev;\n\n\t    // If self is detached, return false.\n\t    if (!list) {\n\t        return false;\n\t    }\n\n\t    // Detach the prependee.\n\t    item.detach();\n\n\t    // If self has a previous item...\n\t    if (prev) {\n\t        // ...link the prependees previous item, to selfs previous item.\n\t        item.prev = prev;\n\n\t        // ...link the previous items next item, to self.\n\t        prev.next = item;\n\t    }\n\n\t    // Set the prependees next item to self.\n\t    item.next = self;\n\n\t    // Set the prependees parent list to selfs parent list.\n\t    item.list = list;\n\n\t    // Set the previous item of self to the prependee.\n\t    self.prev = item;\n\n\t    // If self is the first item in the parent list, link the lists first item\n\t    // to the prependee.\n\t    if (self === list.head) {\n\t        list.head = item;\n\t    }\n\n\t    // If the the parent list has no last item, link the lists last item to\n\t    // self.\n\t    if (!list.tail) {\n\t        list.tail = self;\n\t    }\n\n\t    // Return the prependee.\n\t    return item;\n\t};\n\n\t/**\n\t * Appends the given item *after* the item operated on.\n\t * @name ListItem#append\n\t * @param {ListItem} item - The item to append.\n\t * @returns {ListItem} - The item operated on, or false when that item is not\n\t * attached.\n\t */\n\tListItemPrototype.append = function (item) {\n\t    // If item is falsey, return false.\n\t    if (!item || !item.append || !item.prepend || !item.detach) {\n\t        throw new Error(errorMessage + 'Item#append`.');\n\t    }\n\n\t    // Cache self, the parent list, and the next item.\n\t    var self = this,\n\t        list = self.list,\n\t        next = self.next;\n\n\t    // If self is detached, return false.\n\t    if (!list) {\n\t        return false;\n\t    }\n\n\t    // Detach the appendee.\n\t    item.detach();\n\n\t    // If self has a next item...\n\t    if (next) {\n\t        // ...link the appendees next item, to selfs next item.\n\t        item.next = next;\n\n\t        // ...link the next items previous item, to the appendee.\n\t        next.prev = item;\n\t    }\n\n\t    // Set the appendees previous item to self.\n\t    item.prev = self;\n\n\t    // Set the appendees parent list to selfs parent list.\n\t    item.list = list;\n\n\t    // Set the next item of self to the appendee.\n\t    self.next = item;\n\n\t    // If the the parent list has no last item or if self is the parent lists\n\t    // last item, link the lists last item to the appendee.\n\t    if (self === list.tail || !list.tail) {\n\t        list.tail = item;\n\t    }\n\n\t    // Return the appendee.\n\t    return item;\n\t};\n\n\t/**\n\t * Expose `List`.\n\t */\n\n\tmodule.exports = List;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */\n\t;(function(root) {\n\n\t\t// Detect free variables `exports`.\n\t\tvar freeExports = typeof exports == 'object' && exports;\n\n\t\t// Detect free variable `module`.\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\tmodule.exports == freeExports && module;\n\n\t\t// Detect free variable `global`, from Node.js or Browserified code, and use\n\t\t// it as `root`.\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\n\t\t/*--------------------------------------------------------------------------*/\n\n\t\tvar InvalidCharacterError = function(message) {\n\t\t\tthis.message = message;\n\t\t};\n\t\tInvalidCharacterError.prototype = new Error;\n\t\tInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\t\tvar error = function(message) {\n\t\t\t// Note: the error messages used throughout this file match those used by\n\t\t\t// the native `atob`/`btoa` implementation in Chromium.\n\t\t\tthrow new InvalidCharacterError(message);\n\t\t};\n\n\t\tvar TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t// http://whatwg.org/html/common-microsyntaxes.html#space-character\n\t\tvar REGEX_SPACE_CHARACTERS = /[\\t\\n\\f\\r ]/g;\n\n\t\t// `decode` is designed to be fully compatible with `atob` as described in the\n\t\t// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob\n\t\t// The optimized base64-decoding algorithm used is based on @atks excellent\n\t\t// implementation. https://gist.github.com/atk/1020396\n\t\tvar decode = function(input) {\n\t\t\tinput = String(input)\n\t\t\t\t.replace(REGEX_SPACE_CHARACTERS, '');\n\t\t\tvar length = input.length;\n\t\t\tif (length % 4 == 0) {\n\t\t\t\tinput = input.replace(/==?$/, '');\n\t\t\t\tlength = input.length;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tlength % 4 == 1 ||\n\t\t\t\t// http://whatwg.org/C#alphanumeric-ascii-characters\n\t\t\t\t/[^+a-zA-Z0-9/]/.test(input)\n\t\t\t) {\n\t\t\t\terror(\n\t\t\t\t\t'Invalid character: the string to be decoded is not correctly encoded.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tvar bitCounter = 0;\n\t\t\tvar bitStorage;\n\t\t\tvar buffer;\n\t\t\tvar output = '';\n\t\t\tvar position = -1;\n\t\t\twhile (++position < length) {\n\t\t\t\tbuffer = TABLE.indexOf(input.charAt(position));\n\t\t\t\tbitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;\n\t\t\t\t// Unless this is the first of a group of 4 characters\n\t\t\t\tif (bitCounter++ % 4) {\n\t\t\t\t\t// convert the first 8 bits to a single ASCII character.\n\t\t\t\t\toutput += String.fromCharCode(\n\t\t\t\t\t\t0xFF & bitStorage >> (-2 * bitCounter & 6)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t};\n\n\t\t// `encode` is designed to be fully compatible with `btoa` as described in the\n\t\t// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa\n\t\tvar encode = function(input) {\n\t\t\tinput = String(input);\n\t\t\tif (/[^\\0-\\xFF]/.test(input)) {\n\t\t\t\t// Note: no need to special-case astral symbols here, as surrogates are\n\t\t\t\t// matched, and the input is supposed to only contain ASCII anyway.\n\t\t\t\terror(\n\t\t\t\t\t'The string to be encoded contains characters outside of the ' +\n\t\t\t\t\t'Latin1 range.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tvar padding = input.length % 3;\n\t\t\tvar output = '';\n\t\t\tvar position = -1;\n\t\t\tvar a;\n\t\t\tvar b;\n\t\t\tvar c;\n\t\t\tvar d;\n\t\t\tvar buffer;\n\t\t\t// Make sure any padding is handled outside of the loop.\n\t\t\tvar length = input.length - padding;\n\n\t\t\twhile (++position < length) {\n\t\t\t\t// Read three bytes, i.e. 24 bits.\n\t\t\t\ta = input.charCodeAt(position) << 16;\n\t\t\t\tb = input.charCodeAt(++position) << 8;\n\t\t\t\tc = input.charCodeAt(++position);\n\t\t\t\tbuffer = a + b + c;\n\t\t\t\t// Turn the 24 bits into four chunks of 6 bits each, and append the\n\t\t\t\t// matching character for each of them to the output.\n\t\t\t\toutput += (\n\t\t\t\t\tTABLE.charAt(buffer >> 18 & 0x3F) +\n\t\t\t\t\tTABLE.charAt(buffer >> 12 & 0x3F) +\n\t\t\t\t\tTABLE.charAt(buffer >> 6 & 0x3F) +\n\t\t\t\t\tTABLE.charAt(buffer & 0x3F)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (padding == 2) {\n\t\t\t\ta = input.charCodeAt(position) << 8;\n\t\t\t\tb = input.charCodeAt(++position);\n\t\t\t\tbuffer = a + b;\n\t\t\t\toutput += (\n\t\t\t\t\tTABLE.charAt(buffer >> 10) +\n\t\t\t\t\tTABLE.charAt((buffer >> 4) & 0x3F) +\n\t\t\t\t\tTABLE.charAt((buffer << 2) & 0x3F) +\n\t\t\t\t\t'='\n\t\t\t\t);\n\t\t\t} else if (padding == 1) {\n\t\t\t\tbuffer = input.charCodeAt(position);\n\t\t\t\toutput += (\n\t\t\t\t\tTABLE.charAt(buffer >> 2) +\n\t\t\t\t\tTABLE.charAt((buffer << 4) & 0x3F) +\n\t\t\t\t\t'=='\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn output;\n\t\t};\n\n\t\tvar base64 = {\n\t\t\t'encode': encode,\n\t\t\t'decode': decode,\n\t\t\t'version': '0.1.0'\n\t\t};\n\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn base64;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = base64;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tfor (var key in base64) {\n\t\t\t\t\tbase64.hasOwnProperty(key) && (freeExports[key] = base64[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.base64 = base64;\n\t\t}\n\n\t}(this));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)(module), (function() { return this; }())))\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {\n\t'use strict';\n\n\tfunction _instanceof(obj, type) {\n\t  return type != null && obj instanceof type;\n\t}\n\n\tvar nativeMap;\n\ttry {\n\t  nativeMap = Map;\n\t} catch(_) {\n\t  // maybe a reference error because no `Map`. Give it a dummy value that no\n\t  // value will ever be an instanceof.\n\t  nativeMap = function() {};\n\t}\n\n\tvar nativeSet;\n\ttry {\n\t  nativeSet = Set;\n\t} catch(_) {\n\t  nativeSet = function() {};\n\t}\n\n\tvar nativePromise;\n\ttry {\n\t  nativePromise = Promise;\n\t} catch(_) {\n\t  nativePromise = function() {};\n\t}\n\n\t/**\n\t * Clones (copies) an Object using deep copying.\n\t *\n\t * This function supports circular references by default, but if you are certain\n\t * there are no circular references in your object, you can save some CPU time\n\t * by calling clone(obj, false).\n\t *\n\t * Caution: if `circular` is false and `parent` contains circular references,\n\t * your program may enter an infinite loop and crash.\n\t *\n\t * @param `parent` - the object to be cloned\n\t * @param `circular` - set to true if the object to be cloned may contain\n\t *    circular references. (optional - true by default)\n\t * @param `depth` - set to a number if the object is only to be cloned to\n\t *    a particular depth. (optional - defaults to Infinity)\n\t * @param `prototype` - sets the prototype to be used when cloning an object.\n\t *    (optional - defaults to parent prototype).\n\t * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n\t *    should be cloned as well. Non-enumerable properties on the prototype\n\t *    chain will be ignored. (optional - false by default)\n\t*/\n\tfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n\t  if (typeof circular === 'object') {\n\t    depth = circular.depth;\n\t    prototype = circular.prototype;\n\t    includeNonEnumerable = circular.includeNonEnumerable;\n\t    circular = circular.circular;\n\t  }\n\t  // maintain two arrays for circular references, where corresponding parents\n\t  // and children have the same index\n\t  var allParents = [];\n\t  var allChildren = [];\n\n\t  var useBuffer = typeof Buffer != 'undefined';\n\n\t  if (typeof circular == 'undefined')\n\t    circular = true;\n\n\t  if (typeof depth == 'undefined')\n\t    depth = Infinity;\n\n\t  // recurse this function so we don't reset allParents and allChildren\n\t  function _clone(parent, depth) {\n\t    // cloning null always returns null\n\t    if (parent === null)\n\t      return null;\n\n\t    if (depth === 0)\n\t      return parent;\n\n\t    var child;\n\t    var proto;\n\t    if (typeof parent != 'object') {\n\t      return parent;\n\t    }\n\n\t    if (_instanceof(parent, nativeMap)) {\n\t      child = new nativeMap();\n\t    } else if (_instanceof(parent, nativeSet)) {\n\t      child = new nativeSet();\n\t    } else if (_instanceof(parent, nativePromise)) {\n\t      child = new nativePromise(function (resolve, reject) {\n\t        parent.then(function(value) {\n\t          resolve(_clone(value, depth - 1));\n\t        }, function(err) {\n\t          reject(_clone(err, depth - 1));\n\t        });\n\t      });\n\t    } else if (clone.__isArray(parent)) {\n\t      child = [];\n\t    } else if (clone.__isRegExp(parent)) {\n\t      child = new RegExp(parent.source, __getRegExpFlags(parent));\n\t      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n\t    } else if (clone.__isDate(parent)) {\n\t      child = new Date(parent.getTime());\n\t    } else if (useBuffer && Buffer.isBuffer(parent)) {\n\t      child = new Buffer(parent.length);\n\t      parent.copy(child);\n\t      return child;\n\t    } else if (_instanceof(parent, Error)) {\n\t      child = Object.create(parent);\n\t    } else {\n\t      if (typeof prototype == 'undefined') {\n\t        proto = Object.getPrototypeOf(parent);\n\t        child = Object.create(proto);\n\t      }\n\t      else {\n\t        child = Object.create(prototype);\n\t        proto = prototype;\n\t      }\n\t    }\n\n\t    if (circular) {\n\t      var index = allParents.indexOf(parent);\n\n\t      if (index != -1) {\n\t        return allChildren[index];\n\t      }\n\t      allParents.push(parent);\n\t      allChildren.push(child);\n\t    }\n\n\t    if (_instanceof(parent, nativeMap)) {\n\t      parent.forEach(function(value, key) {\n\t        var keyChild = _clone(key, depth - 1);\n\t        var valueChild = _clone(value, depth - 1);\n\t        child.set(keyChild, valueChild);\n\t      });\n\t    }\n\t    if (_instanceof(parent, nativeSet)) {\n\t      parent.forEach(function(value) {\n\t        var entryChild = _clone(value, depth - 1);\n\t        child.add(entryChild);\n\t      });\n\t    }\n\n\t    for (var i in parent) {\n\t      var attrs;\n\t      if (proto) {\n\t        attrs = Object.getOwnPropertyDescriptor(proto, i);\n\t      }\n\n\t      if (attrs && attrs.set == null) {\n\t        continue;\n\t      }\n\t      child[i] = _clone(parent[i], depth - 1);\n\t    }\n\n\t    if (Object.getOwnPropertySymbols) {\n\t      var symbols = Object.getOwnPropertySymbols(parent);\n\t      for (var i = 0; i < symbols.length; i++) {\n\t        // Don't need to worry about cloning a symbol because it is a primitive,\n\t        // like a number or string.\n\t        var symbol = symbols[i];\n\t        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n\t        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n\t          continue;\n\t        }\n\t        child[symbol] = _clone(parent[symbol], depth - 1);\n\t        if (!descriptor.enumerable) {\n\t          Object.defineProperty(child, symbol, {\n\t            enumerable: false\n\t          });\n\t        }\n\t      }\n\t    }\n\n\t    if (includeNonEnumerable) {\n\t      var allPropertyNames = Object.getOwnPropertyNames(parent);\n\t      for (var i = 0; i < allPropertyNames.length; i++) {\n\t        var propertyName = allPropertyNames[i];\n\t        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n\t        if (descriptor && descriptor.enumerable) {\n\t          continue;\n\t        }\n\t        child[propertyName] = _clone(parent[propertyName], depth - 1);\n\t        Object.defineProperty(child, propertyName, {\n\t          enumerable: false\n\t        });\n\t      }\n\t    }\n\n\t    return child;\n\t  }\n\n\t  return _clone(parent, depth);\n\t}\n\n\t/**\n\t * Simple flat clone using prototype, accepts only objects, usefull for property\n\t * override on FLAT configuration object (no nested props).\n\t *\n\t * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n\t * works.\n\t */\n\tclone.clonePrototype = function clonePrototype(parent) {\n\t  if (parent === null)\n\t    return null;\n\n\t  var c = function () {};\n\t  c.prototype = parent;\n\t  return new c();\n\t};\n\n\t// private utility functions\n\n\tfunction __objToStr(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\tclone.__objToStr = __objToStr;\n\n\tfunction __isDate(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n\t}\n\tclone.__isDate = __isDate;\n\n\tfunction __isArray(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n\t}\n\tclone.__isArray = __isArray;\n\n\tfunction __isRegExp(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n\t}\n\tclone.__isRegExp = __isRegExp;\n\n\tfunction __getRegExpFlags(re) {\n\t  var flags = '';\n\t  if (re.global) flags += 'g';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.multiline) flags += 'm';\n\t  return flags;\n\t}\n\tclone.__getRegExpFlags = __getRegExpFlags;\n\n\treturn clone;\n\t})();\n\n\tif (typeof module === 'object' && module.exports) {\n\t  module.exports = clone;\n\t}\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var SCSocket = __webpack_require__(4);\n\tvar scErrors = __webpack_require__(12);\n\tvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\n\tvar _connections = {};\n\n\tfunction getMultiplexId(options) {\n\t  var protocolPrefix = options.secure ? 'https://' : 'http://';\n\t  var queryString = '';\n\t  if (options.query) {\n\t    if (typeof options.query == 'string') {\n\t      queryString = options.query;\n\t    } else {\n\t      var queryArray = [];\n\t      var queryMap = options.query;\n\t      for (var key in queryMap) {\n\t        if (queryMap.hasOwnProperty(key)) {\n\t          queryArray.push(key + '=' + queryMap[key]);\n\t        }\n\t      }\n\t      if (queryArray.length) {\n\t        queryString = '?' + queryArray.join('&');\n\t      }\n\t    }\n\t  }\n\t  var host;\n\t  if (options.host) {\n\t    host = options.host;\n\t  } else {\n\t    host = options.hostname + ':' + options.port;\n\t  }\n\t  return protocolPrefix + host + options.path + queryString;\n\t}\n\n\tfunction isUrlSecure() {\n\t  return global.location && location.protocol == 'https:';\n\t}\n\n\tfunction getPort(options, isSecureDefault) {\n\t  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n\t  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n\t}\n\n\tfunction connect(options) {\n\t  var self = this;\n\n\t  options = options || {};\n\n\t  if (options.host && options.port) {\n\t    throw new InvalidArgumentsError('The host option should already include the' +\n\t      ' port number in the format hostname:port - Because of this, the host and port options' +\n\t      ' cannot be specified together; use the hostname option instead');\n\t  }\n\n\t  var isSecureDefault = isUrlSecure();\n\n\t  var opts = {\n\t    port: getPort(options, isSecureDefault),\n\t    hostname: global.location && location.hostname,\n\t    path: '/socketcluster/',\n\t    secure: isSecureDefault,\n\t    autoConnect: true,\n\t    autoReconnect: true,\n\t    autoSubscribeOnConnect: true,\n\t    connectTimeout: 20000,\n\t    ackTimeout: 10000,\n\t    timestampRequests: false,\n\t    timestampParam: 't',\n\t    authEngine: null,\n\t    authTokenName: 'socketCluster.authToken',\n\t    binaryType: 'arraybuffer',\n\t    multiplex: true,\n\t    pubSubBatchDuration: null,\n\t    cloneData: false\n\t  };\n\t  for (var i in options) {\n\t    if (options.hasOwnProperty(i)) {\n\t      opts[i] = options[i];\n\t    }\n\t  }\n\t  var multiplexId = getMultiplexId(opts);\n\t  if (opts.multiplex === false) {\n\t    return new SCSocket(opts);\n\t  }\n\t  if (_connections[multiplexId]) {\n\t    _connections[multiplexId].connect();\n\t  } else {\n\t    _connections[multiplexId] = new SCSocket(opts);\n\t  }\n\t  return _connections[multiplexId];\n\t}\n\n\tfunction destroy(options) {\n\t  var self = this;\n\n\t  options = options || {};\n\t  var isSecureDefault = isUrlSecure();\n\n\t  var opts = {\n\t    port: getPort(options, isSecureDefault),\n\t    hostname: global.location && location.hostname,\n\t    path: '/socketcluster/',\n\t    secure: isSecureDefault\n\t  };\n\t  for (var i in options) {\n\t    if (options.hasOwnProperty(i)) {\n\t      opts[i] = options[i];\n\t    }\n\t  }\n\t  var multiplexId = getMultiplexId(opts);\n\t  var socket = _connections[multiplexId];\n\t  if (socket) {\n\t    socket.destroy();\n\t  }\n\t  delete _connections[multiplexId];\n\t}\n\n\tmodule.exports = {\n\t  connect: connect,\n\t  destroy: destroy,\n\t  connections: _connections\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ })\n/******/ ])\n});\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/scsocket.js\n// module id = 3\n// module chunks = 0 1","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 4\n// module chunks = 0 1","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 5\n// module chunks = 0 1","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 6\n// module chunks = 0 1","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 7\n// module chunks = 0 1","var SCSocket = require('./scsocket');\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\nvar _connections = {};\n\nfunction getMultiplexId(options) {\n  var protocolPrefix = options.secure ? 'https://' : 'http://';\n  var queryString = '';\n  if (options.query) {\n    if (typeof options.query == 'string') {\n      queryString = options.query;\n    } else {\n      var queryArray = [];\n      var queryMap = options.query;\n      for (var key in queryMap) {\n        if (queryMap.hasOwnProperty(key)) {\n          queryArray.push(key + '=' + queryMap[key]);\n        }\n      }\n      if (queryArray.length) {\n        queryString = '?' + queryArray.join('&');\n      }\n    }\n  }\n  var host;\n  if (options.host) {\n    host = options.host;\n  } else {\n    host = options.hostname + ':' + options.port;\n  }\n  return protocolPrefix + host + options.path + queryString;\n}\n\nfunction isUrlSecure() {\n  return global.location && location.protocol == 'https:';\n}\n\nfunction getPort(options, isSecureDefault) {\n  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n}\n\nfunction connect(options) {\n  var self = this;\n\n  options = options || {};\n\n  if (options.host && options.port) {\n    throw new InvalidArgumentsError('The host option should already include the' +\n      ' port number in the format hostname:port - Because of this, the host and port options' +\n      ' cannot be specified together; use the hostname option instead');\n  }\n\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname,\n    path: '/socketcluster/',\n    secure: isSecureDefault,\n    autoConnect: true,\n    autoReconnect: true,\n    autoSubscribeOnConnect: true,\n    connectTimeout: 20000,\n    ackTimeout: 10000,\n    timestampRequests: false,\n    timestampParam: 't',\n    authEngine: null,\n    authTokenName: 'socketCluster.authToken',\n    binaryType: 'arraybuffer',\n    multiplex: true,\n    pubSubBatchDuration: null,\n    cloneData: false\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  var multiplexId = getMultiplexId(opts);\n  if (opts.multiplex === false) {\n    return new SCSocket(opts);\n  }\n  if (_connections[multiplexId]) {\n    _connections[multiplexId].connect();\n  } else {\n    _connections[multiplexId] = new SCSocket(opts);\n  }\n  return _connections[multiplexId];\n}\n\nfunction destroy(options) {\n  var self = this;\n\n  options = options || {};\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname,\n    path: '/socketcluster/',\n    secure: isSecureDefault\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  var multiplexId = getMultiplexId(opts);\n  var socket = _connections[multiplexId];\n  if (socket) {\n    socket.destroy();\n  }\n  delete _connections[multiplexId];\n}\n\nmodule.exports = {\n  connect: connect,\n  destroy: destroy,\n  connections: _connections\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socketcluster-client/lib/scsocketcreator.js\n// module id = 8\n// module chunks = 0 1","var decycle = require('./decycle');\r\n\r\nvar isStrict = (function () { return !this; })();\r\n\r\nfunction AuthTokenExpiredError(message, expiry) {\r\n  this.name = 'AuthTokenExpiredError';\r\n  this.message = message;\r\n  this.expiry = expiry;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenExpiredError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction AuthTokenInvalidError(message) {\r\n  this.name = 'AuthTokenInvalidError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenInvalidError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction AuthTokenNotBeforeError(message, date) {\r\n  this.name = 'AuthTokenNotBeforeError';\r\n  this.message = message;\r\n  this.date = date;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenNotBeforeError.prototype = Object.create(Error.prototype);\r\n\r\n\r\n// For any other auth token error.\r\nfunction AuthTokenError(message) {\r\n  this.name = 'AuthTokenError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nAuthTokenError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction SilentMiddlewareBlockedError(message, type) {\r\n  this.name = 'SilentMiddlewareBlockedError';\r\n  this.message = message;\r\n  this.type = type;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nSilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction InvalidActionError(message) {\r\n  this.name = 'InvalidActionError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidActionError.prototype = Object.create(Error.prototype);\r\n\r\nfunction InvalidArgumentsError(message) {\r\n  this.name = 'InvalidArgumentsError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidArgumentsError.prototype = Object.create(Error.prototype);\r\n\r\nfunction InvalidOptionsError(message) {\r\n  this.name = 'InvalidOptionsError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidOptionsError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction InvalidMessageError(message) {\r\n  this.name = 'InvalidMessageError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nInvalidMessageError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction SocketProtocolError(message, code) {\r\n  this.name = 'SocketProtocolError';\r\n  this.message = message;\r\n  this.code = code;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nSocketProtocolError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction ServerProtocolError(message) {\r\n  this.name = 'ServerProtocolError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nServerProtocolError.prototype = Object.create(Error.prototype);\r\n\r\nfunction HTTPServerError(message) {\r\n  this.name = 'HTTPServerError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nHTTPServerError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction ResourceLimitError(message) {\r\n  this.name = 'ResourceLimitError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nResourceLimitError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction TimeoutError(message) {\r\n  this.name = 'TimeoutError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nTimeoutError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction BadConnectionError(message, type) {\r\n  this.name = 'BadConnectionError';\r\n  this.message = message;\r\n  this.type = type;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nBadConnectionError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction BrokerError(message) {\r\n  this.name = 'BrokerError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nBrokerError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction ProcessExitError(message, code) {\r\n  this.name = 'ProcessExitError';\r\n  this.message = message;\r\n  this.code = code;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nProcessExitError.prototype = Object.create(Error.prototype);\r\n\r\n\r\nfunction UnknownError(message) {\r\n  this.name = 'UnknownError';\r\n  this.message = message;\r\n  if (Error.captureStackTrace && !isStrict) {\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  } else {\r\n    this.stack = (new Error()).stack;\r\n  }\r\n}\r\nUnknownError.prototype = Object.create(Error.prototype);\r\n\r\n\r\n// Expose all error types\r\n\r\nmodule.exports = {\r\n  AuthTokenExpiredError: AuthTokenExpiredError,\r\n  AuthTokenInvalidError: AuthTokenInvalidError,\r\n  AuthTokenNotBeforeError: AuthTokenNotBeforeError,\r\n  AuthTokenError: AuthTokenError,\r\n  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,\r\n  InvalidActionError: InvalidActionError,\r\n  InvalidArgumentsError: InvalidArgumentsError,\r\n  InvalidOptionsError: InvalidOptionsError,\r\n  InvalidMessageError: InvalidMessageError,\r\n  SocketProtocolError: SocketProtocolError,\r\n  ServerProtocolError: ServerProtocolError,\r\n  HTTPServerError: HTTPServerError,\r\n  ResourceLimitError: ResourceLimitError,\r\n  TimeoutError: TimeoutError,\r\n  BadConnectionError: BadConnectionError,\r\n  BrokerError: BrokerError,\r\n  ProcessExitError: ProcessExitError,\r\n  UnknownError: UnknownError\r\n};\r\n\r\nmodule.exports.socketProtocolErrorStatuses = {\r\n  1001: 'Socket was disconnected',\r\n  1002: 'A WebSocket protocol error was encountered',\r\n  1003: 'Server terminated socket because it received invalid data',\r\n  1005: 'Socket closed without status code',\r\n  1006: 'Socket hung up',\r\n  1007: 'Message format was incorrect',\r\n  1008: 'Encountered a policy violation',\r\n  1009: 'Message was too big to process',\r\n  1010: 'Client ended the connection because the server did not comply with extension requirements',\r\n  1011: 'Server encountered an unexpected fatal condition',\r\n  4000: 'Server ping timed out',\r\n  4001: 'Client pong timed out',\r\n  4002: 'Server failed to sign auth token',\r\n  4003: 'Failed to complete handshake',\r\n  4004: 'Client failed to save auth token',\r\n  4005: 'Did not receive #handshake from client before timeout',\r\n  4006: 'Failed to bind socket to message broker',\r\n  4007: 'Client connection establishment timed out'\r\n};\r\n\r\nmodule.exports.socketProtocolIgnoreStatuses = {\r\n  1000: 'Socket closed normally',\r\n  1001: 'Socket hung up'\r\n};\r\n\r\n// Properties related to error domains cannot be serialized.\r\nvar unserializableErrorProperties = {\r\n  domain: 1,\r\n  domainEmitter: 1,\r\n  domainThrown: 1\r\n};\r\n\r\nmodule.exports.dehydrateError = function (error, includeStackTrace) {\r\n  var dehydratedError;\r\n\r\n  if (error && typeof error == 'object') {\r\n    dehydratedError = {\r\n      message: error.message\r\n    };\r\n    if (includeStackTrace) {\r\n      dehydratedError.stack = error.stack;\r\n    }\r\n    for (var i in error) {\r\n      if (!unserializableErrorProperties[i]) {\r\n        dehydratedError[i] = error[i];\r\n      }\r\n    }\r\n  } else if (typeof error == 'function') {\r\n    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';\r\n  } else {\r\n    dehydratedError = error;\r\n  }\r\n\r\n  return decycle(dehydratedError);\r\n};\r\n\r\nmodule.exports.hydrateError = function (error) {\r\n  var hydratedError = null;\r\n  if (error != null) {\r\n    if (typeof error == 'object') {\r\n      hydratedError = new Error(error.message);\r\n      for (var i in error) {\r\n        if (error.hasOwnProperty(i)) {\r\n          hydratedError[i] = error[i];\r\n        }\r\n      }\r\n    } else {\r\n      hydratedError = error;\r\n    }\r\n  }\r\n  return hydratedError;\r\n};\r\n\r\nmodule.exports.decycle = decycle;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sc-errors/index.js\n// module id = 9\n// module chunks = 0 1","// Based on https://github.com/dscape/cycle/blob/master/cycle.js\r\n\r\nmodule.exports = function decycle(object) {\r\n// Make a deep copy of an object or array, assuring that there is at most\r\n// one instance of each object or array in the resulting structure. The\r\n// duplicate references (which might be forming cycles) are replaced with\r\n// an object of the form\r\n//      {$ref: PATH}\r\n// where the PATH is a JSONPath string that locates the first occurance.\r\n// So,\r\n//      var a = [];\r\n//      a[0] = a;\r\n//      return JSON.stringify(JSON.decycle(a));\r\n// produces the string '[{\"$ref\":\"$\"}]'.\r\n\r\n// JSONPath is used to locate the unique object. $ indicates the top level of\r\n// the object or array. [NUMBER] or [STRING] indicates a child member or\r\n// property.\r\n\r\n    var objects = [],   // Keep a reference to each unique object or array\r\n        paths = [];     // Keep the path to each unique object or array\r\n\r\n    return (function derez(value, path) {\r\n\r\n// The derez recurses through the object, producing the deep copy.\r\n\r\n        var i,          // The loop counter\r\n            name,       // Property name\r\n            nu;         // The new object or array\r\n\r\n// typeof null === 'object', so go on if this value is really an object but not\r\n// one of the weird builtin objects.\r\n\r\n        if (typeof value === 'object' && value !== null &&\r\n                !(value instanceof Boolean) &&\r\n                !(value instanceof Date)    &&\r\n                !(value instanceof Number)  &&\r\n                !(value instanceof RegExp)  &&\r\n                !(value instanceof String)) {\r\n\r\n// If the value is an object or array, look to see if we have already\r\n// encountered it. If so, return a $ref/path object. This is a hard way,\r\n// linear search that will get slower as the number of unique objects grows.\r\n\r\n            for (i = 0; i < objects.length; i += 1) {\r\n                if (objects[i] === value) {\r\n                    return {$ref: paths[i]};\r\n                }\r\n            }\r\n\r\n// Otherwise, accumulate the unique value and its path.\r\n\r\n            objects.push(value);\r\n            paths.push(path);\r\n\r\n// If it is an array, replicate the array.\r\n\r\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\r\n                nu = [];\r\n                for (i = 0; i < value.length; i += 1) {\r\n                    nu[i] = derez(value[i], path + '[' + i + ']');\r\n                }\r\n            } else {\r\n\r\n// If it is an object, replicate the object.\r\n\r\n                nu = {};\r\n                for (name in value) {\r\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n                        nu[name] = derez(value[name],\r\n                            path + '[' + JSON.stringify(name) + ']');\r\n                    }\r\n                }\r\n            }\r\n            return nu;\r\n        }\r\n        return value;\r\n    }(object, '$'));\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sc-errors/decycle.js\n// module id = 10\n// module chunks = 0 1","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/component-emitter/index.js\n// module id = 11\n// module chunks = 0 1"],"sourceRoot":""}